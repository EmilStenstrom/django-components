{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Docs (Work in progress)</p> <p>Django-components is a package that introduces component-based architecture to Django's server-side rendering. It aims to combine Django's templating system with the modularity seen in modern frontend frameworks.</p>"},{"location":"#features","title":"Features","text":"<ol> <li>\ud83e\udde9 Reusability: Allows creation of self-contained, reusable UI elements.</li> <li>\ud83d\udce6 Encapsulation: Each component can include its own HTML, CSS, and JavaScript.</li> <li>\ud83d\ude80 Server-side rendering: Components render on the server, improving initial load times and SEO.</li> <li>\ud83d\udc0d Django integration: Works within the Django ecosystem, using familiar concepts like template tags.</li> <li>\u26a1 Asynchronous loading: Components can render independently opening up for integration with JS frameworks like HTMX or AlpineJS.</li> </ol> <p>Potential benefits:</p> <ul> <li>\ud83d\udd04 Reduced code duplication</li> <li>\ud83d\udee0\ufe0f Improved maintainability through modular design</li> <li>\ud83e\udde0 Easier management of complex UIs</li> <li>\ud83e\udd1d Enhanced collaboration between frontend and backend developers</li> </ul> <p>Django-components can be particularly useful for larger Django projects that require a more structured approach to UI development, without necessitating a shift to a separate frontend framework.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>django-components lets you create reusable blocks of code needed to generate the front end code you need for a modern app. </p> <p>Define a component in <code>components/calendar/calendar.py</code> like this: <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    template_name = \"template.html\"\n\n    def get_context_data(self, date):\n        return {\"date\": date}\n</code></pre></p> <p>With this <code>template.html</code> file:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;&lt;/div&gt;\n</code></pre> <p>Use the component like this:</p> <pre><code>{% component \"calendar\" date=\"2024-11-06\" %}{% endcomponent %}\n</code></pre> <p>And this is what gets rendered:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;Today's date is &lt;span&gt;2024-11-06&lt;/span&gt;&lt;/div&gt;\n</code></pre> <p>Read on to learn about all the exciting details and configuration possibilities!</p> <p>(If you instead prefer to jump right into the code, check out the example project)</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ul> <li>Release notes</li> <li>Security notes \ud83d\udea8</li> <li>Installation</li> <li>Compatibility</li> <li>Create your first component</li> <li>Using single-file components</li> <li>Use components in templates</li> <li>Use components outside of templates</li> <li>Use components as views</li> <li>Typing and validating components</li> <li>Pre-defined components</li> <li>Registering components</li> <li>Autodiscovery</li> <li>Using slots in templates</li> <li>Accessing data passed to the component</li> <li>Rendering HTML attributes</li> <li>Template tag syntax</li> <li>Prop drilling and dependency injection (provide / inject)</li> <li>Component hooks</li> <li>Component context and scope</li> <li>Pre-defined template variables</li> <li>Customizing component tags with TagFormatter</li> <li>Defining HTML/JS/CSS files</li> <li>Rendering JS/CSS dependencies</li> <li>Available settings</li> <li>Running with development server</li> <li>Logging and debugging</li> <li>Management Command</li> <li>Writing and sharing component libraries</li> <li>Community examples</li> <li>Running django-components project locally</li> <li>Development guides</li> </ul>"},{"location":"#release-notes","title":"Release notes","text":"<p>Read the Release Notes to see the latest features and fixes.</p>"},{"location":"#security-notes","title":"Security notes \ud83d\udea8","text":"<p>It is strongly recommended to read this section before using django-components in production.</p>"},{"location":"#static-files","title":"Static files","text":"<p>Components can be organized however you prefer. That said, our prefered way is to keep the files of a component close together by bundling them in the same directory.</p> <p>This means that files containing backend logic, such as Python modules and HTML templates, live in the same directory as static files, e.g. JS and CSS.</p> <p>From v0.100 onwards, we keep component files (as defined by <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code>) separate from the rest of the static files (defined by <code>STATICFILES_DIRS</code>). That way, the Python and HTML files are NOT exposed by the server. Only the static JS, CSS, and other common formats.</p> <p>NOTE: If you need to expose different file formats, you can configure these with <code>COMPONENTS.static_files_allowed</code> and <code>COMPONENTS.static_files_forbidden</code>.</p>"},{"location":"#static-files-prior-to-v0100","title":"Static files prior to v0.100","text":"<p>Prior to v0.100, if your were using django.contrib.staticfiles to collect static files, no distinction was made between the different kinds of files.</p> <p>As a result, your Python code and templates may inadvertently become available on your static file server. You probably don't want this, as parts of your backend logic will be exposed, posing a potential security vulnerability.</p> <p>From v0.27 until v0.100, django-components shipped with an additional installable app django_components.safer_staticfiles. It was a drop-in replacement for django.contrib.staticfiles. Its behavior is 100% identical except it ignores .py and .html files, meaning these will not end up on your static files server. To use it, add it to INSTALLED_APPS and remove django.contrib.staticfiles.</p> <pre><code>INSTALLED_APPS = [\n    # 'django.contrib.staticfiles',   # &lt;-- REMOVE\n    'django_components',\n    'django_components.safer_staticfiles'  # &lt;-- ADD\n]\n</code></pre> <p>If you are on an older version of django-components, your alternatives are a) passing <code>--ignore &lt;pattern&gt;</code> options to the collecstatic CLI command, or b) defining a subclass of StaticFilesConfig. Both routes are described in the official docs of the staticfiles app.</p> <p>Note that <code>safer_staticfiles</code> excludes the <code>.py</code> and <code>.html</code> files for collectstatic command:</p> <pre><code>python manage.py collectstatic\n</code></pre> <p>but it is ignored on the development server:</p> <pre><code>python manage.py runserver\n</code></pre> <p>For a step-by-step guide on deploying production server with static files, see the demo project.</p>"},{"location":"#installation","title":"Installation","text":"<ol> <li>Install <code>django_components</code> into your environment:</li> </ol> <p><code>pip install django_components</code></p> <ol> <li>Load <code>django_components</code> into Django by adding it into <code>INSTALLED_APPS</code> in settings.py:</li> </ol> <pre><code>INSTALLED_APPS = [\n   ...,\n   'django_components',\n]\n</code></pre> <ol> <li><code>BASE_DIR</code> setting is required. Ensure that it is defined in settings.py:</li> </ol> <pre><code>BASE_DIR = Path(__file__).resolve().parent.parent\n</code></pre> <ol> <li>Add / modify <code>COMPONENTS.dirs</code> and / or <code>COMPONENTS.app_dirs</code> so django_components knows where to find component HTML, JS and CSS files:</li> </ol> <pre><code>COMPONENTS = {\n    \"dirs\": [\n         ...,\n         os.path.join(BASE_DIR, \"components\"),\n     ],\n}\n</code></pre> <p>If <code>COMPONENTS.dirs</code> is omitted, django-components will by default look for a top-level <code>/components</code> directory,    <code>{BASE_DIR}/components</code>.</p> <p>In addition to <code>COMPONENTS.dirs</code>, django_components will also load components from app-level directories, such as <code>my-app/components/</code>.    The directories within apps are configured with <code>COMPONENTS.app_dirs</code>, and the default is <code>[app]/components</code>.</p> <p>NOTE: The input to <code>COMPONENTS.dirs</code> is the same as for <code>STATICFILES_DIRS</code>, and the paths must be full paths. See Django docs.</p> <ol> <li> <p>Next, to make Django load component HTML files as Django templates, modify <code>TEMPLATES</code> section of settings.py as follows:</p> </li> <li> <p>Remove <code>'APP_DIRS': True,</code></p> <ul> <li>NOTE: Instead of APP_DIRS, for the same effect, we will use <code>django.template.loaders.app_directories.Loader</code></li> </ul> </li> <li>Add <code>loaders</code> to <code>OPTIONS</code> list and set it to following value:</li> </ol> <pre><code>TEMPLATES = [\n   {\n      ...,\n      'OPTIONS': {\n            'context_processors': [\n               ...\n            ],\n            'loaders':[(\n               'django.template.loaders.cached.Loader', [\n                  # Default Django loader\n                  'django.template.loaders.filesystem.Loader',\n                  # Inluding this is the same as APP_DIRS=True\n                  'django.template.loaders.app_directories.Loader',\n                  # Components loader\n                  'django_components.template_loader.Loader',\n               ]\n            )],\n      },\n   },\n]\n</code></pre> <ol> <li>Lastly, be able to serve the component JS and CSS files as static files, modify <code>STATICFILES_FINDERS</code> section of settings.py as follows:</li> </ol> <pre><code>STATICFILES_FINDERS = [\n    # Default finders\n    \"django.contrib.staticfiles.finders.FileSystemFinder\",\n    \"django.contrib.staticfiles.finders.AppDirectoriesFinder\",\n    # Django components\n    \"django_components.finders.ComponentsFileSystemFinder\",\n]\n</code></pre>"},{"location":"#adding-support-for-js-and-css","title":"Adding support for JS and CSS","text":"<p>If you want to use JS or CSS with components, you will need to:</p> <ol> <li>Add <code>ComponentDependencyMiddleware</code> to <code>MIDDLEWARE</code> setting.</li> </ol> <p>The middleware searches the outgoing HTML for all components that were rendered to generate the HTML, and adds the JS and CSS associated with those components.</p> <pre><code>MIDDLEWARE = [\n    ...\n    \"django_components.middleware.ComponentDependencyMiddleware\",\n]\n</code></pre> <p>Read more in Rendering JS/CSS dependencies.</p> <ol> <li>Add django-component's URL paths to your <code>urlpatterns</code>:</li> </ol> <pre><code>from django.urls import include, path\n\nurlpatterns = [\n    ...\n    path(\"\", include(\"django_components.urls\")),\n]\n</code></pre>"},{"location":"#optional","title":"Optional","text":"<p>To avoid loading the app in each template using <code>{% load component_tags %}</code>, you can add the tag as a 'builtin' in settings.py</p> <pre><code>TEMPLATES = [\n    {\n        ...,\n        'OPTIONS': {\n            'context_processors': [\n                ...\n            ],\n            'builtins': [\n                'django_components.templatetags.component_tags',\n            ]\n        },\n    },\n]\n</code></pre> <p>Read on to find out how to build your first component!</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p>Django-components supports all supported combinations versions of Django and Python.</p> Python version Django version 3.8 4.2 3.9 4.2 3.10 4.2, 5.0 3.11 4.2, 5.0 3.12 4.2, 5.0"},{"location":"#create-your-first-component","title":"Create your first component","text":"<p>A component in django-components is the combination of four things: CSS, Javascript, a Django template, and some Python code to put them all together.</p> <pre><code>    sampleproject/\n    \u251c\u2500\u2500 calendarapp/\n    \u251c\u2500\u2500 components/             \ud83c\udd95\n    \u2502   \u2514\u2500\u2500 calendar/           \ud83c\udd95\n    \u2502       \u251c\u2500\u2500 calendar.py     \ud83c\udd95\n    \u2502       \u251c\u2500\u2500 script.js       \ud83c\udd95\n    \u2502       \u251c\u2500\u2500 style.css       \ud83c\udd95\n    \u2502       \u2514\u2500\u2500 template.html   \ud83c\udd95\n    \u251c\u2500\u2500 sampleproject/\n    \u251c\u2500\u2500 manage.py\n    \u2514\u2500\u2500 requirements.txt\n</code></pre> <p>Start by creating empty files in the structure above.</p> <p>First, you need a CSS file. Be sure to prefix all rules with a unique class so they don't clash with other rules.</p> [project root]/components/calendar/style.css<pre><code>/* In a file called [project root]/components/calendar/style.css */\n.calendar-component {\n  width: 200px;\n  background: pink;\n}\n.calendar-component span {\n  font-weight: bold;\n}\n</code></pre> <p>Then you need a javascript file that specifies how you interact with this component. You are free to use any javascript framework you want. A good way to make sure this component doesn't clash with other components is to define all code inside an anonymous function that calls itself. This makes all variables defined only be defined inside this component and not affect other components.</p> [project root]/components/calendar/script.js<pre><code>/* In a file called [project root]/components/calendar/script.js */\n(function () {\n  if (document.querySelector(\".calendar-component\")) {\n    document.querySelector(\".calendar-component\").onclick = function () {\n      alert(\"Clicked calendar!\");\n    };\n  }\n})();\n</code></pre> <p>Now you need a Django template for your component. Feel free to define more variables like <code>date</code> in this example. When creating an instance of this component we will send in the values for these variables. The template will be rendered with whatever template backend you've specified in your Django settings file.</p> [project root]/components/calendar/calendar.html<pre><code>{# In a file called [project root]/components/calendar/template.html #}\n&lt;div class=\"calendar-component\"&gt;Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;&lt;/div&gt;\n</code></pre> <p>Finally, we use django-components to tie this together. Start by creating a file called <code>calendar.py</code> in your component calendar directory. It will be auto-detected and loaded by the app.</p> <p>Inside this file we create a Component by inheriting from the Component class and specifying the context method. We also register the global component registry so that we easily can render it anywhere in our templates.</p> [project root]/components/calendar/calendar.py<pre><code># In a file called [project root]/components/calendar/calendar.py\nfrom django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    # Templates inside `[your apps]/components` dir and `[project root]/components` dir\n    # will be automatically found.\n    #\n    # `template_name` can be relative to dir where `calendar.py` is, or relative to COMPONENTS.dirs\n    template_name = \"template.html\"\n    # Or\n    def get_template_name(context):\n        return f\"template-{context['name']}.html\"\n\n    # This component takes one parameter, a date string to show in the template\n    def get_context_data(self, date):\n        return {\n            \"date\": date,\n        }\n\n    # Both `css` and `js` can be relative to dir where `calendar.py` is, or relative to COMPONENTS.dirs\n    class Media:\n        css = \"style.css\"\n        js = \"script.js\"\n</code></pre> <p>And voil\u00e1!! We've created our first component.</p>"},{"location":"#using-single-file-components","title":"Using single-file components","text":"<p>Components can also be defined in a single file, which is useful for small components. To do this, you can use the <code>template</code>, <code>js</code>, and <code>css</code> class attributes instead of the <code>template_name</code> and <code>Media</code>. For example, here's the calendar component from above, defined in a single file:</p> [project root]/components/calendar.py<pre><code># In a file called [project root]/components/calendar.py\nfrom django_components import Component, register, types\n\n@register(\"calendar\")\nclass Calendar(Component):\n    def get_context_data(self, date):\n        return {\n            \"date\": date,\n        }\n\n    template: types.django_html = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;&lt;/div&gt;\n    \"\"\"\n\n    css: types.css = \"\"\"\n        .calendar-component { width: 200px; background: pink; }\n        .calendar-component span { font-weight: bold; }\n    \"\"\"\n\n    js: types.js = \"\"\"\n        (function(){\n            if (document.querySelector(\".calendar-component\")) {\n                document.querySelector(\".calendar-component\").onclick = function(){ alert(\"Clicked calendar!\"); };\n            }\n        })()\n    \"\"\"\n</code></pre> <p>This makes it easy to create small components without having to create a separate template, CSS, and JS file.</p>"},{"location":"#syntax-highlight-and-code-assistance","title":"Syntax highlight and code assistance","text":""},{"location":"#vscode","title":"VSCode","text":"<p>Note, in the above example, that the <code>t.django_html</code>, <code>t.css</code>, and <code>t.js</code> types are used to specify the type of the template, CSS, and JS files, respectively. This is not necessary, but if you're using VSCode with the Python Inline Source Syntax Highlighting extension, it will give you syntax highlighting for the template, CSS, and JS.</p>"},{"location":"#pycharm-or-other-jetbrains-ides","title":"Pycharm (or other Jetbrains IDEs)","text":"<p>If you're a Pycharm user (or any other editor from Jetbrains), you can have coding assistance as well:</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    def get_context_data(self, date):\n        return {\n            \"date\": date,\n        }\n\n    # language=HTML\n    template= \"\"\"\n        &lt;div class=\"calendar-component\"&gt;Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;&lt;/div&gt;\n    \"\"\"\n\n    # language=CSS\n    css = \"\"\"\n        .calendar-component { width: 200px; background: pink; }\n        .calendar-component span { font-weight: bold; }\n    \"\"\"\n\n    # language=JS\n    js = \"\"\"\n        (function(){\n            if (document.querySelector(\".calendar-component\")) {\n                document.querySelector(\".calendar-component\").onclick = function(){ alert(\"Clicked calendar!\"); };\n            }\n        })()\n    \"\"\"\n</code></pre> <p>You don't need to use <code>types.django_html</code>, <code>types.css</code>, <code>types.js</code> since Pycharm uses language injections. You only need to write the comments <code># language=&lt;lang&gt;</code> above the variables.</p>"},{"location":"#use-components-in-templates","title":"Use components in templates","text":"<p>First load the <code>component_tags</code> tag library, then use the <code>component_[js/css]_dependencies</code> and <code>component</code> tags to render the component to the page.</p> <pre><code>{% load component_tags %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;My example calendar&lt;/title&gt;\n    {% component_css_dependencies %}\n&lt;/head&gt;\n&lt;body&gt;\n    {% component \"calendar\" date=\"2015-06-19\" %}{% endcomponent %}\n    {% component_js_dependencies %}\n&lt;/body&gt;\n&lt;html&gt;\n</code></pre> <p>NOTE: Instead of writing <code>{% endcomponent %}</code> at the end, you can use a self-closing tag:</p> <p><code>{% component \"calendar\" date=\"2015-06-19\" / %}</code></p> <p>The output from the above template will be:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;My example calendar&lt;/title&gt;\n    &lt;link\n      href=\"/static/calendar/style.css\"\n      type=\"text/css\"\n      media=\"all\"\n      rel=\"stylesheet\"\n    /&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=\"calendar-component\"&gt;\n      Today's date is &lt;span&gt;2015-06-19&lt;/span&gt;\n    &lt;/div&gt;\n    &lt;script src=\"/static/calendar/script.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n  &lt;html&gt;&lt;/html&gt;\n&lt;/html&gt;\n</code></pre> <p>This makes it possible to organize your front-end around reusable components. Instead of relying on template tags and keeping your CSS and Javascript in the static directory.</p>"},{"location":"#use-components-outside-of-templates","title":"Use components outside of templates","text":"<p>New in version 0.81</p> <p>Components can be rendered outside of Django templates, calling them as regular functions (\"React-style\").</p> <p>The component class defines <code>render</code> and <code>render_to_response</code> class methods. These methods accept positional args, kwargs, and slots, offering the same flexibility as the <code>{% component %}</code> tag:</p> <pre><code>class SimpleComponent(Component):\n    template = \"\"\"\n        {% load component_tags %}\n        hello: {{ hello }}\n        foo: {{ foo }}\n        kwargs: {{ kwargs|safe }}\n        slot_first: {% slot \"first\" required / %}\n    \"\"\"\n\n    def get_context_data(self, arg1, arg2, **kwargs):\n        return {\n            \"hello\": arg1,\n            \"foo\": arg2,\n            \"kwargs\": kwargs,\n        }\n\nrendered = SimpleComponent.render(\n    args=[\"world\", \"bar\"],\n    kwargs={\"kw1\": \"test\", \"kw2\": \"ooo\"},\n    slots={\"first\": \"FIRST_SLOT\"},\n    context={\"from_context\": 98},\n)\n</code></pre> <p>Renders:</p> <pre><code>hello: world\nfoo: bar\nkwargs: {'kw1': 'test', 'kw2': 'ooo'}\nslot_first: FIRST_SLOT\n</code></pre>"},{"location":"#inputs-of-render-and-render_to_response","title":"Inputs of <code>render</code> and <code>render_to_response</code>","text":"<p>Both <code>render</code> and <code>render_to_response</code> accept the same input:</p> <pre><code>Component.render(\n    context: Mapping | django.template.Context | None = None,\n    args: List[Any] | None = None,\n    kwargs: Dict[str, Any] | None = None,\n    slots: Dict[str, str | SafeString | SlotFunc] | None = None,\n    escape_slots_content: bool = True\n) -&gt; str:\n</code></pre> <ul> <li> <p><code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code></p> </li> <li> <p><code>kwargs</code> - Keyword args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code></p> </li> <li> <p><code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.   Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string   or <code>SlotFunc</code>.</p> </li> <li> <p><code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. <code>True</code> by default to prevent XSS attacks. If you disable escaping, you should make sure that any content you pass to the slots is safe, especially if it comes from user input.</p> </li> <li> <p><code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.</p> </li> <li>NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via     component's args and kwargs.</li> </ul>"},{"location":"#slotfunc","title":"<code>SlotFunc</code>","text":"<p>When rendering components with slots in <code>render</code> or <code>render_to_response</code>, you can pass either a string or a function.</p> <p>The function has following signature:</p> <pre><code>def render_func(\n   context: Context,\n   data: Dict[str, Any],\n   slot_ref: SlotRef,\n) -&gt; str | SafeString:\n    return nodelist.render(ctx)\n</code></pre> <ul> <li><code>context</code> - Django's Context available to the Slot Node.</li> <li><code>data</code> - Data passed to the <code>{% slot %}</code> tag. See Scoped Slots.</li> <li><code>slot_ref</code> - The default slot content. See Accessing original content of slots.</li> <li>NOTE: The slot is lazily evaluated. To render the slot, convert it to string with <code>str(slot_ref)</code>.</li> </ul> <p>Example:</p> <pre><code>def footer_slot(ctx, data, slot_ref):\n   return f\"\"\"\n      SLOT_DATA: {data['abc']}\n      ORIGINAL: {slot_ref}\n   \"\"\"\n\nMyComponent.render_to_response(\n    slots={\n        \"footer\": footer_slot,\n   },\n)\n</code></pre>"},{"location":"#response-class-of-render_to_response","title":"Response class of <code>render_to_response</code>","text":"<p>While <code>render</code> method returns a plain string, <code>render_to_response</code> wraps the rendered content in a \"Response\" class. By default, this is <code>django.http.HttpResponse</code>.</p> <p>If you want to use a different Response class in <code>render_to_response</code>, set the <code>Component.response_class</code> attribute:</p> <pre><code>class MyResponse(HttpResponse):\n   def __init__(self, *args, **kwargs) -&gt; None:\n      super().__init__(*args, **kwargs)\n      # Configure response\n      self.headers = ...\n      self.status = ...\n\nclass SimpleComponent(Component):\n   response_class = MyResponse\n   template: types.django_html = \"HELLO\"\n\nresponse = SimpleComponent.render_to_response()\nassert isinstance(response, MyResponse)\n</code></pre>"},{"location":"#use-components-as-views","title":"Use components as views","text":"<p>New in version 0.34</p> <p>Note: Since 0.92, Component no longer subclasses View. To configure the View class, set the nested <code>Component.View</code> class</p> <p>Components can now be used as views: - Components define the <code>Component.as_view()</code> class method that can be used the same as <code>View.as_view()</code>.</p> <ul> <li> <p>By default, you can define GET, POST or other HTTP handlers directly on the Component, same as you do with View. For example, you can override <code>get</code> and <code>post</code> to handle GET and POST requests, respectively.</p> </li> <li> <p>In addition, <code>Component</code> now has a <code>render_to_response</code> method that renders the component template based on the provided context and slots' data and returns an <code>HttpResponse</code> object.</p> </li> </ul>"},{"location":"#component-as-view-example","title":"Component as view example","text":"<p>Here's an example of a calendar component defined as a view:</p> <pre><code># In a file called [project root]/components/calendar.py\nfrom django_components import Component, ComponentView, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n\n    template = \"\"\"\n        &lt;div class=\"calendar-component\"&gt;\n            &lt;div class=\"header\"&gt;\n                {% slot \"header\" / %}\n            &lt;/div&gt;\n            &lt;div class=\"body\"&gt;\n                Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    # Handle GET requests\n    def get(self, request, *args, **kwargs):\n        context = {\n            \"date\": request.GET.get(\"date\", \"2020-06-06\"),\n        }\n        slots = {\n            \"header\": \"Calendar header\",\n        }\n        # Return HttpResponse with the rendered content\n        return self.render_to_response(\n            context=context,\n            slots=slots,\n        )\n</code></pre> <p>Then, to use this component as a view, you should create a <code>urls.py</code> file in your components directory, and add a path to the component's view:</p> <pre><code># In a file called [project root]/components/urls.py\nfrom django.urls import path\nfrom components.calendar.calendar import Calendar\n\nurlpatterns = [\n    path(\"calendar/\", Calendar.as_view()),\n]\n</code></pre> <p><code>Component.as_view()</code> is a shorthand for calling <code>View.as_view()</code> and passing the component instance as one of the arguments.</p> <p>Remember to add <code>__init__.py</code> to your components directory, so that Django can find the <code>urls.py</code> file.</p> <p>Finally, include the component's urls in your project's <code>urls.py</code> file:</p> <pre><code># In a file called [project root]/urls.py\nfrom django.urls import include, path\n\nurlpatterns = [\n    path(\"components/\", include(\"components.urls\")),\n]\n</code></pre> <p>Note: Slots content are automatically escaped by default to prevent XSS attacks. To disable escaping, set <code>escape_slots_content=False</code> in the <code>render_to_response</code> method. If you do so, you should make sure that any content you pass to the slots is safe, especially if it comes from user input.</p> <p>If you're planning on passing an HTML string, check Django's use of <code>format_html</code> and <code>mark_safe</code>.</p>"},{"location":"#modifying-the-view-class","title":"Modifying the View class","text":"<p>The View class that handles the requests is defined on <code>Component.View</code>.</p> <p>When you define a GET or POST handlers on the <code>Component</code> class, like so:</p> <pre><code>class MyComponent(Component):\n    def get(self, request, *args, **kwargs):\n        return self.render_to_response(\n            context={\n                \"date\": request.GET.get(\"date\", \"2020-06-06\"),\n            },\n        )\n\n    def post(self, request, *args, **kwargs) -&gt; HttpResponse:\n        variable = request.POST.get(\"variable\")\n        return self.render_to_response(\n            kwargs={\"variable\": variable}\n        )\n</code></pre> <p>Then the request is still handled by <code>Component.View.get()</code> or <code>Component.View.post()</code> methods. However, by default, <code>Component.View.get()</code> points to <code>Component.get()</code>, and so on.</p> <pre><code>class ComponentView(View):\n    component: Component = None\n    ...\n\n    def get(self, request, *args, **kwargs):\n        return self.component.get(request, *args, **kwargs)\n\n    def post(self, request, *args, **kwargs):\n        return self.component.post(request, *args, **kwargs)\n\n    ...\n</code></pre> <p>If you want to define your own <code>View</code> class, you need to: 1. Set the class as <code>Component.View</code> 2. Subclass from <code>ComponentView</code>, so the View instance has access to the component instance.</p> <p>In the example below, we added extra logic into <code>View.setup()</code>.</p> <p>Note that the POST handler is still defined at the top. This is because <code>View</code> subclasses <code>ComponentView</code>, which defines the <code>post()</code> method that calls <code>Component.post()</code>.</p> <p>If you were to overwrite the <code>View.post()</code> method, then <code>Component.post()</code> would be ignored.</p> <pre><code>from django_components import Component, ComponentView\n\nclass MyComponent(Component):\n\n    def post(self, request, *args, **kwargs) -&gt; HttpResponse:\n        variable = request.POST.get(\"variable\")\n        return self.component.render_to_response(\n            kwargs={\"variable\": variable}\n        )\n\n    class View(ComponentView):\n        def setup(self, request, *args, **kwargs):\n            super(request, *args, **kwargs)\n\n            do_something_extra(request, *args, **kwargs)\n</code></pre>"},{"location":"#typing-and-validating-components","title":"Typing and validating components","text":""},{"location":"#adding-type-hints-with-generics","title":"Adding type hints with Generics","text":"<p>New in version 0.92</p> <p>The <code>Component</code> class optionally accepts type parameters that allow you to specify the types of args, kwargs, slots, and data:</p> <pre><code>class Button(Component[Args, Kwargs, Slots, Data, JsData, CssData]):\n    ...\n</code></pre> <ul> <li><code>Args</code> - Must be a <code>Tuple</code> or <code>Any</code></li> <li><code>Kwargs</code> - Must be a <code>TypedDict</code> or <code>Any</code></li> <li><code>Data</code> - Must be a <code>TypedDict</code> or <code>Any</code></li> <li><code>Slots</code> - Must be a <code>TypedDict</code> or <code>Any</code></li> </ul> <p>Here's a full example:</p> <pre><code>from typing import NotRequired, Tuple, TypedDict, SlotContent, SlotFunc\n\n# Positional inputs\nArgs = Tuple[int, str]\n\n# Kwargs inputs\nclass Kwargs(TypedDict):\n    variable: str\n    another: int\n    maybe_var: NotRequired[int] # May be ommited\n\n# Data returned from `get_context_data`\nclass Data(TypedDict):\n    variable: str\n\n# The data available to the `my_slot` scoped slot\nclass MySlotData(TypedDict):\n    value: int\n\n# Slots\nclass Slots(TypedDict):\n    # Use SlotFunc for slot functions.\n    # The generic specifies the `data` dictionary\n    my_slot: NotRequired[SlotFunc[MySlotData]]\n    # SlotContent == Union[str, SafeString]\n    another_slot: SlotContent\n\nclass Button(Component[Args, Kwargs, Slots, Data, JsData, CssData]):\n    def get_context_data(self, variable, another):\n        return {\n            \"variable\": variable,\n        }\n</code></pre> <p>When you then call <code>Component.render</code> or <code>Component.render_to_response</code>, you will get type hints:</p> <pre><code>Button.render(\n    # Error: First arg must be `int`, got `float`\n    args=(1.25, \"abc\"),\n    # Error: Key \"another\" is missing\n    kwargs={\n        \"variable\": \"text\",\n    },\n)\n</code></pre>"},{"location":"#usage-for-python-311","title":"Usage for Python &lt;3.11","text":"<p>On Python 3.8-3.10, use <code>typing_extensions</code></p> <pre><code>from typing_extensions import TypedDict, NotRequired\n</code></pre> <p>Additionally on Python 3.8-3.9, also import <code>annotations</code>:</p> <pre><code>from __future__ import annotations\n</code></pre> <p>Moreover, on 3.10 and less, you may not be able to use <code>NotRequired</code>, and instead you will need to mark either all keys are required, or all keys as optional, using TypeDict's <code>total</code> kwarg.</p> <p>See PEP-655 for more info.</p>"},{"location":"#passing-additional-args-or-kwargs","title":"Passing additional args or kwargs","text":"<p>You may have a function that supports any number of args or kwargs:</p> <pre><code>def get_context_data(self, *args, **kwargs):\n    ...\n</code></pre> <p>This is not supported with the typed components.</p> <p>As a workaround: - For <code>*args</code>, set a positional argument that accepts a list of values:</p> <pre><code>```py\n# Tuple of one member of list of strings\nArgs = Tuple[List[str]]\n```\n</code></pre> <ul> <li> <p>For <code>*kwargs</code>, set a keyword argument that accepts a dictionary of values:</p> <pre><code>class Kwargs(TypedDict):\n    variable: str\n    another: int\n    # Pass any extra keys under `extra`\n    extra: Dict[str, any]\n</code></pre> </li> </ul>"},{"location":"#handling-no-args-or-no-kwargs","title":"Handling no args or no kwargs","text":"<p>To declare that a component accepts no Args, Kwargs, etc, you can use <code>EmptyTuple</code> and <code>EmptyDict</code> types:</p> <pre><code>from django_components import Component, EmptyDict, EmptyTuple\n\nArgs = EmptyTuple\nKwargs = Data = Slots = EmptyDict\n\nclass Button(Component[Args, Kwargs, Slots, Data, JsData, CssData]):\n    ...\n</code></pre>"},{"location":"#runtime-input-validation-with-types","title":"Runtime input validation with types","text":"<p>New in version 0.96</p> <p>NOTE: Kwargs, slots, and data validation is supported only for Python &gt;=3.11</p> <p>In Python 3.11 and later, when you specify the component types, you will get also runtime validation of the inputs you pass to <code>Component.render</code> or <code>Component.render_to_response</code>.</p> <p>So, using the example from before, if you ignored the type errors and still ran the following code:</p> <pre><code>Button.render(\n    # Error: First arg must be `int`, got `float`\n    args=(1.25, \"abc\"),\n    # Error: Key \"another\" is missing\n    kwargs={\n        \"variable\": \"text\",\n    },\n)\n</code></pre> <p>This would raise a <code>TypeError</code>:</p> <pre><code>Component 'Button' expected positional argument at index 0 to be &lt;class 'int'&gt;, got 1.25 of type &lt;class 'float'&gt;\n</code></pre> <p>In case you need to skip these errors, you can either set the faulty member to <code>Any</code>, e.g.:</p> <pre><code># Changed `int` to `Any`\nArgs = Tuple[Any, str]\n</code></pre> <p>Or you can replace <code>Args</code> with <code>Any</code> altogether, to skip the validation of args:</p> <pre><code># Replaced `Args` with `Any`\nclass Button(Component[Any, Kwargs, Slots, Data, JsData, CssData]):\n    ...\n</code></pre> <p>Same applies to kwargs, data, and slots.</p>"},{"location":"#pre-defined-components","title":"Pre-defined components","text":""},{"location":"#dynamic-components","title":"Dynamic components","text":"<p>If you are writing something like a form component, you may design it such that users give you the component names, and your component renders it.</p> <p>While you can handle this with a series of if / else statements, this is not an extensible solution.</p> <p>Instead, you can use dynamic components. Dynamic components are used in place of normal components.</p> <pre><code>{% load component_tags %}\n{% component \"dynamic\" is=component_name title=\"Cat Museum\" %}\n    {% fill \"content\" %}\n        HELLO_FROM_SLOT_1\n    {% endfill %}\n    {% fill \"sidebar\" %}\n        HELLO_FROM_SLOT_2\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>or in case you use the <code>django_components.component_shorthand_formatter</code> tag formatter:</p> <pre><code>{% dynamic is=component_name title=\"Cat Museu\" %}\n    {% fill \"content\" %}\n        HELLO_FROM_SLOT_1\n    {% endfill %}\n    {% fill \"sidebar\" %}\n        HELLO_FROM_SLOT_2\n    {% endfill %}\n{% enddynamic %}\n</code></pre> <p>These behave same way as regular components. You pass it the same args, kwargs, and slots as you would to the component that you want to render.</p> <p>The only exception is that also you supply 1-2 additional inputs: - <code>is</code> - Required - The component name or a component class to render - <code>registry</code> - Optional - The <code>ComponentRegistry</code> that will be searched if <code>is</code> is a component name. If omitted, ALL registries are searched.</p> <p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can change the name used for the dynamic components by defining the <code>COMPONENTS.dynamic_component_name</code> setting.</p> <p>If you need to use the dynamic components in Python, you can also import it from <code>django_components</code>: <pre><code>from django_components import DynamicComponent\n\ncomp = SimpleTableComp if is_readonly else TableComp\n\noutput = DynamicComponent.render(\n    kwargs={\n        \"is\": comp,\n        # Other kwargs...\n    },\n    # args: [...],\n    # slots: {...},\n)\n</code></pre></p>"},{"location":"#registering-components","title":"Registering components","text":"<p>In previous examples you could repeatedly see us using <code>@register()</code> to \"register\" the components. In this section we dive deeper into what it actually means and how you can manage (add or remove) components.</p> <p>As a reminder, we may have a component like this:</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_name = \"template.html\"\n\n    # This component takes one parameter, a date string to show in the template\n    def get_context_data(self, date):\n        return {\n            \"date\": date,\n        }\n</code></pre> <p>which we then render in the template as:</p> <pre><code>{% component \"calendar\" date=\"1970-01-01\" %}\n{% endcomponent %}\n</code></pre> <p>As you can see, <code>@register</code> links up the component class with the <code>{% component %}</code> template tag. So when the template tag comes across a component called <code>\"calendar\"</code>, it can look up it's class and instantiate it.</p>"},{"location":"#what-is-componentregistry","title":"What is ComponentRegistry","text":"<p>The <code>@register</code> decorator is a shortcut for working with the <code>ComponentRegistry</code>.</p> <p><code>ComponentRegistry</code> manages which components can be used in the template tags.</p> <p>Each <code>ComponentRegistry</code> instance is associated with an instance of Django's <code>Library</code>. And Libraries are inserted into Django template using the <code>{% load %}</code> tags.</p> <p>The <code>@register</code> decorator accepts an optional kwarg <code>registry</code>, which specifies, the <code>ComponentRegistry</code> to register components into. If omitted, the default <code>ComponentRegistry</code> instance defined in django_components is used.</p> <pre><code>my_registry = ComponentRegistry()\n\n@register(registry=my_registry)\nclass MyComponent(Component):\n    ...\n</code></pre> <p>The default <code>ComponentRegistry</code> is associated with the <code>Library</code> that you load when you call <code>{% load component_tags %}</code> inside your template, or when you add <code>django_components.templatetags.component_tags</code> to the template builtins.</p> <p>So when you register or unregister a component to/from a component registry, then behind the scenes the registry automatically adds/removes the component's template tags to/from the Library, so you can call the component from within the templates such as <code>{% component \"my_comp\" %}</code>.</p>"},{"location":"#working-with-componentregistry","title":"Working with ComponentRegistry","text":"<p>The default <code>ComponentRegistry</code> instance can be imported as:</p> <pre><code>from django_components import registry\n</code></pre> <p>You can use the registry to manually add/remove/get components:</p> <pre><code>from django_components import registry\n\n# Register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n\n# Get all or single\nregistry.all()  # {\"button\": ButtonComponent, \"card\": CardComponent}\nregistry.get(\"card\")  # CardComponent\n\n# Unregister single component\nregistry.unregister(\"card\")\n\n# Unregister all components\nregistry.clear()\n</code></pre>"},{"location":"#registering-components-to-custom-componentregistry","title":"Registering components to custom ComponentRegistry","text":"<p>If you are writing a component library to be shared with others, you may want to manage your own instance of <code>ComponentRegistry</code> and register components onto a different <code>Library</code> instance than the default one.</p> <p>The <code>Library</code> instance can be set at instantiation of <code>ComponentRegistry</code>. If omitted, then the default Library instance from django_components is used.</p> <pre><code>from django.template import Library\nfrom django_components import ComponentRegistry\n\nmy_library = Library(...)\nmy_registry = ComponentRegistry(library=my_library)\n</code></pre> <p>When you have defined your own <code>ComponentRegistry</code>, you can either register the components with <code>my_registry.register()</code>, or pass the registry to the <code>@component.register()</code> decorator via the <code>registry</code> kwarg:</p> <pre><code>from path.to.my.registry import my_registry\n\n@register(\"my_component\", registry=my_registry)\nclass MyComponent(Component):\n    ...\n</code></pre> <p>NOTE: The Library instance can be accessed under <code>library</code> attribute of <code>ComponentRegistry</code>.</p>"},{"location":"#componentregistry-settings","title":"ComponentRegistry settings","text":"<p>When you are creating an instance of <code>ComponentRegistry</code>, you can define the components' behavior within the template.</p> <p>The registry accepts these settings: - <code>context_behavior</code> - <code>tag_formatter</code></p> <pre><code>from django.template import Library\nfrom django_components import ComponentRegistry, RegistrySettings\n\nregister = library = django.template.Library()\ncomp_registry = ComponentRegistry(\n    library=library,\n    settings=RegistrySettings(\n        context_behavior=\"isolated\",\n        tag_formatter=\"django_components.component_formatter\",\n    ),\n)\n</code></pre> <p>These settings are the same as the ones you can set for django_components.</p> <p>In fact, when you set <code>COMPONENT.tag_formatter</code> or <code>COMPONENT.context_behavior</code>, these are forwarded to the default <code>ComponentRegistry</code>.</p> <p>This makes it possible to have multiple registries with different settings in one projects, and makes sharing of component libraries possible.</p>"},{"location":"#autodiscovery","title":"Autodiscovery","text":"<p>Every component that you want to use in the template with the <code>{% component %}</code> tag needs to be registered with the ComponentRegistry. Normally, we use the <code>@register</code> decorator for that:</p> <pre><code>from django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    ...\n</code></pre> <p>But for the component to be registered, the code needs to be executed - the file needs to be imported as a module.</p> <p>One way to do that is by importing all your components in <code>apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\nclass MyAppConfig(AppConfig):\n    name = \"my_app\"\n\n    def ready(self) -&gt; None:\n        from components.card.card import Card\n        from components.list.list import List\n        from components.menu.menu import Menu\n        from components.button.button import Button\n        ...\n</code></pre> <p>However, there's a simpler way!</p> <p>By default, the Python files in the <code>COMPONENTS.dirs</code> directories (or app-level <code>[app]/components/</code>) are auto-imported in order to auto-register the components.</p> <p>Autodiscovery occurs when Django is loaded, during the <code>ready</code> hook of the <code>apps.py</code> file.</p> <p>If you are using autodiscovery, keep a few points in mind:</p> <ul> <li>Avoid defining any logic on the module-level inside the <code>components</code> dir, that you would not want to run anyway.</li> <li>Components inside the auto-imported files still need to be registered with <code>@register()</code></li> <li>Auto-imported component files must be valid Python modules, they must use suffix <code>.py</code>, and module name should follow PEP-8.</li> </ul> <p>Autodiscovery can be disabled in the settings.</p>"},{"location":"#manually-trigger-autodiscovery","title":"Manually trigger autodiscovery","text":"<p>Autodiscovery can be also triggered manually as a function call. This is useful if you want to run autodiscovery at a custom point of the lifecycle:</p> <pre><code>from django_components import autodiscover\n\nautodiscover()\n</code></pre>"},{"location":"#using-slots-in-templates","title":"Using slots in templates","text":"<p>New in version 0.26:</p> <ul> <li>The <code>slot</code> tag now serves only to declare new slots inside the component template.</li> <li>To override the content of a declared slot, use the newly introduced <code>fill</code> tag instead.</li> <li>Whereas unfilled slots used to raise a warning, filling a slot is now optional by default.</li> <li>To indicate that a slot must be filled, the new <code>required</code> option should be added at the end of the <code>slot</code> tag.</li> </ul> <p>Components support something called 'slots'. When a component is used inside another template, slots allow the parent template to override specific parts of the child component by passing in different content. This mechanism makes components more reusable and composable. This behavior is similar to slots in Vue.</p> <p>In the example below we introduce two block tags that work hand in hand to make this work. These are...</p> <ul> <li><code>{% slot &lt;name&gt; %}</code>/<code>{% endslot %}</code>: Declares a new slot in the component template.</li> <li><code>{% fill &lt;name&gt; %}</code>/<code>{% endfill %}</code>: (Used inside a <code>{% component %}</code> tag pair.) Fills a declared slot with the specified content.</li> </ul> <p>Let's update our calendar component to support more customization. We'll add <code>slot</code> tag pairs to its template, template.html.</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"header\" %}Calendar header{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"body\" %}Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>When using the component, you specify which slots you want to fill and where you want to use the defaults from the template. It looks like this:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"body\" %}\n        Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Since the 'header' fill is unspecified, it's taken from the base template. If you put this in a template, and pass in <code>date=2020-06-06</code>, this is what gets rendered:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        Calendar header\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        Can you believe it's already &lt;span&gt;2020-06-06&lt;/span&gt;??\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"#named-slots","title":"Named slots","text":"<p>As seen in the previouse section, you can use <code>{% fill slot_name %}</code> to insert content into a specific slot.</p> <p>You can define fills for multiple slot simply by defining them all within the <code>{% component %} {% endcomponent %}</code> tags:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"header\" %}\n        Hi this is header!\n    {% endfill %}\n    {% fill \"body\" %}\n        Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>You can also use <code>{% for %}</code>, <code>{% with %}</code>, or other non-component tags (even <code>{% include %}</code>) to construct the <code>{% fill %}</code> tags, as long as these other tags do not leave any text behind!</p> <pre><code>{% component \"table\" %}\n  {% for slot_name in slots %}\n    {% fill name=slot_name %}\n      {{ slot_name }}\n    {% endfill %}\n  {% endfor %}\n\n  {% with slot_name=\"abc\" %}\n    {% fill name=slot_name %}\n      {{ slot_name }}\n    {% endfill %}\n  {% endwith %}\n{% endcomponent %}\n</code></pre>"},{"location":"#default-slot","title":"Default slot","text":"<p>Added in version 0.28</p> <p>As you can see, component slots lets you write reusable containers that you fill in when you use a component. This makes for highly reusable components that can be used in different circumstances.</p> <p>It can become tedious to use <code>fill</code> tags everywhere, especially when you're using a component that declares only one slot. To make things easier, <code>slot</code> tags can be marked with an optional keyword: <code>default</code>.</p> <p>When added to the tag (as shown below), this option lets you pass filling content directly in the body of a <code>component</code> tag pair \u2013 without using a <code>fill</code> tag. Choose carefully, though: a component template may contain at most one slot that is marked as <code>default</code>. The <code>default</code> option can be combined with other slot options, e.g. <code>required</code>.</p> <p>Here's the same example as before, except with default slots and implicit filling.</p> <p>The template:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"header\" %}Calendar header{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"body\" default %}Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Including the component (notice how the <code>fill</code> tag is omitted):</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n{% endcomponent %}\n</code></pre> <p>The rendered result (exactly the same as before):</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n  &lt;div class=\"header\"&gt;Calendar header&lt;/div&gt;\n  &lt;div class=\"body\"&gt;Can you believe it's already &lt;span&gt;2020-06-06&lt;/span&gt;??&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>You may be tempted to combine implicit fills with explicit <code>fill</code> tags. This will not work. The following component template will raise an error when rendered.</p> <pre><code>{# DON'T DO THIS #}\n{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"header\" %}Totally new header!{% endfill %}\n    Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n{% endcomponent %}\n</code></pre> <p>Instead, you can use a named fill with name <code>default</code> to target the default fill:</p> <pre><code>{# THIS WORKS #}\n{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"header\" %}Totally new header!{% endfill %}\n    {% fill \"default\" %}\n        Can you believe it's already &lt;span&gt;{{ date }}&lt;/span&gt;??\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>NOTE: If you doubly-fill a slot, that is, that both <code>{% fill \"default\" %}</code> and <code>{% fill \"header\" %}</code> would point to the same slot, this will raise an error when rendered.</p>"},{"location":"#accessing-default-slot-in-python","title":"Accessing default slot in Python","text":"<p>Since the default slot is stored under the slot name <code>default</code>, you can access the default slot like so:</p> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        default_slot = self.input.slots[\"default\"]\n        return {\n            \"default_slot\": default_slot,\n        }\n</code></pre>"},{"location":"#render-fill-in-multiple-places","title":"Render fill in multiple places","text":"<p>Added in version 0.70</p> <p>You can render the same content in multiple places by defining multiple slots with identical names:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"image\" %}Image here{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"image\" %}Image here{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>So if used like:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"image\" %}\n        &lt;img src=\"...\" /&gt;\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>This renders:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        &lt;img src=\"...\" /&gt;\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        &lt;img src=\"...\" /&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>"},{"location":"#default-and-required-slots","title":"Default and required slots","text":"<p>If you use a slot multiple times, you can still mark the slot as <code>default</code> or <code>required</code>. For that, you must mark each slot individually, e.g.:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>Which you can then use as regular default slot:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    &lt;img src=\"...\" /&gt;\n{% endcomponent %}\n</code></pre> <p>Since each slot is tagged individually, you can have multiple slots with the same name but different conditions.</p> <p>E.g. in this example, we have a component that renders a user avatar - a small circular image with a profile picture of name initials.</p> <p>If the component is given <code>image_src</code> or <code>name_initials</code> variables, the <code>image</code> slot is optional. But if neither of those are provided, you MUST fill the <code>image</code> slot.</p> <pre><code>&lt;div class=\"avatar\"&gt;\n    {% if image_src %}\n        {% slot \"image\" default %}\n            &lt;img src=\"{{ image_src }}\" /&gt;\n        {% endslot %}\n    {% elif name_initials %}\n        {% slot \"image\" default %}\n            &lt;div style=\"\n                border-radius: 25px;\n                width: 50px;\n                height: 50px;\n                background: blue;\n            \"&gt;\n                {{ name_initials }}\n            &lt;/div&gt;\n        {% endslot %}\n    {% else %}\n        {% slot \"image\" default required / %}\n    {% endif %}\n&lt;/div&gt;\n</code></pre>"},{"location":"#accessing-original-content-of-slots","title":"Accessing original content of slots","text":"<p>Added in version 0.26</p> <p>NOTE: In version 0.77, the syntax was changed from</p> <pre><code>{% fill \"my_slot\" as \"alias\" %} {{ alias.default }}\n</code></pre> <p>to</p> <pre><code>{% fill \"my_slot\" default=\"slot_default\" %} {{ slot_default }}\n</code></pre> <p>Sometimes you may want to keep the original slot, but only wrap or prepend/append content to it. To do so, you can access the default slot via the <code>default</code> kwarg.</p> <p>Similarly to the <code>data</code> attribute, you specify the variable name through which the default slot will be made available.</p> <p>For instance, let's say you're filling a slot called 'body'. To render the original slot, assign it to a variable using the <code>'default'</code> keyword. You then render this variable to insert the default content:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"body\" default=\"body_default\" %}\n        {{ body_default }}. Have a great day!\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>This produces:</p> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        Calendar header\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        Today's date is &lt;span&gt;2020-06-06&lt;/span&gt;. Have a great day!\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>To access the original content of a default slot, set the name to <code>default</code>:</p> <pre><code>{% component \"calendar\" date=\"2020-06-06\" %}\n    {% fill \"default\" default=\"slot_default\" %}\n        {{ slot_default }}. Have a great day!\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"#conditional-slots","title":"Conditional slots","text":"<p>Added in version 0.26.</p> <p>NOTE: In version 0.70, <code>{% if_filled %}</code> tags were replaced with <code>{{ component_vars.is_filled }}</code> variables. If your slot name contained special characters, see the section Accessing <code>is_filled</code> of slot names with special characters.</p> <p>In certain circumstances, you may want the behavior of slot filling to depend on whether or not a particular slot is filled.</p> <p>For example, suppose we have the following component template:</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        {% slot \"title\" %}Title{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"subtitle\"&gt;\n        {% slot \"subtitle\" %}{# Optional subtitle #}{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>By default the slot named 'subtitle' is empty. Yet when the component is used without explicit fills, the div containing the slot is still rendered, as shown below:</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n  &lt;div class=\"title\"&gt;Title&lt;/div&gt;\n  &lt;div class=\"subtitle\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>This may not be what you want. What if instead the outer 'subtitle' div should only be included when the inner slot is in fact filled?</p> <p>The answer is to use the <code>{{ component_vars.is_filled.&lt;name&gt; }}</code> variable. You can use this together with Django's <code>{% if/elif/else/endif %}</code> tags to define a block whose contents will be rendered only if the component slot with the corresponding 'name' is filled.</p> <p>This is what our example looks like with <code>component_vars.is_filled</code>.</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        {% slot \"title\" %}Title{% endslot %}\n    &lt;/div&gt;\n    {% if component_vars.is_filled.subtitle %}\n    &lt;div class=\"subtitle\"&gt;\n        {% slot \"subtitle\" %}{# Optional subtitle #}{% endslot %}\n    &lt;/div&gt;\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <p>Here's our example with more complex branching.</p> <pre><code>&lt;div class=\"frontmatter-component\"&gt;\n    &lt;div class=\"title\"&gt;\n        {% slot \"title\" %}Title{% endslot %}\n    &lt;/div&gt;\n    {% if component_vars.is_filled.subtitle %}\n    &lt;div class=\"subtitle\"&gt;\n        {% slot \"subtitle\" %}{# Optional subtitle #}{% endslot %}\n    &lt;/div&gt;\n    {% elif component_vars.is_filled.title %}\n        ...\n    {% elif component_vars.is_filled.&lt;name&gt; %}\n        ...\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <p>Sometimes you're not interested in whether a slot is filled, but rather that it isn't. To negate the meaning of <code>component_vars.is_filled</code>, simply treat it as boolean and negate it with <code>not</code>:</p> <pre><code>{% if not component_vars.is_filled.subtitle %}\n&lt;div class=\"subtitle\"&gt;\n    {% slot \"subtitle\" / %}\n&lt;/div&gt;\n{% endif %}\n</code></pre>"},{"location":"#accessing-is_filled-of-slot-names-with-special-characters","title":"Accessing <code>is_filled</code> of slot names with special characters","text":"<p>To be able to access a slot name via <code>component_vars.is_filled</code>, the slot name needs to be composed of only alphanumeric characters and underscores (e.g. <code>this__isvalid_123</code>).</p> <p>However, you can still define slots with other special characters. In such case, the slot name in <code>component_vars.is_filled</code> is modified to replace all invalid characters into <code>_</code>.</p> <p>So a slot named <code>\"my super-slot :)\"</code> will be available as <code>component_vars.is_filled.my_super_slot___</code>.</p> <p>Same applies when you are accessing <code>is_filled</code> from within the Python, e.g.:</p> <pre><code>class MyTable(Component):\n    def on_render_before(self, context, template) -&gt; None:\n        # \u2705 Works\n        if self.is_filled[\"my_super_slot___\"]:\n            # Do something\n\n        # \u274c Does not work\n        if self.is_filled[\"my super-slot :)\"]:\n            # Do something\n</code></pre>"},{"location":"#scoped-slots","title":"Scoped slots","text":"<p>Added in version 0.76:</p> <p>Consider a component with slot(s). This component may do some processing on the inputs, and then use the processed variable in the slot's default template:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        &lt;div&gt;\n            {% slot \"content\" default %}\n                input: {{ input }}\n            {% endslot %}\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_context_data(self, input):\n        processed_input = do_something(input)\n        return {\"input\": processed_input}\n</code></pre> <p>You may want to design a component so that users of your component can still access the <code>input</code> variable, so they don't have to recompute it.</p> <p>This behavior is called \"scoped slots\". This is inspired by Vue scoped slots and scoped slots of django-web-components.</p> <p>Using scoped slots consists of two steps:</p> <ol> <li>Passing data to <code>slot</code> tag</li> <li>Accessing data in <code>fill</code> tag</li> </ol>"},{"location":"#passing-data-to-slots","title":"Passing data to slots","text":"<p>To pass the data to the <code>slot</code> tag, simply pass them as keyword attributes (<code>key=value</code>):</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        &lt;div&gt;\n            {% slot \"content\" default input=input %}\n                input: {{ input }}\n            {% endslot %}\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_context_data(self, input):\n        processed_input = do_something(input)\n        return {\n            \"input\": processed_input,\n        }\n</code></pre>"},{"location":"#accessing-slot-data-in-fill","title":"Accessing slot data in fill","text":"<p>Next, we head over to where we define a fill for this slot. Here, to access the slot data we set the <code>data</code> attribute to the name of the variable through which we want to access the slot data. In the example below, we set it to <code>data</code>:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"content\" data=\"slot_data\" %}\n        {{ slot_data.input }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>To access slot data on a default slot, you have to explictly define the <code>{% fill %}</code> tags.</p> <p>So this works:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"default\" data=\"slot_data\" %}\n        {{ slot_data.input }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>While this does not:</p> <pre><code>{% component \"my_comp\" data=\"data\" %}\n    {{ data.input }}\n{% endcomponent %}\n</code></pre> <p>Note: You cannot set the <code>data</code> attribute and <code>default</code> attribute) to the same name. This raises an error:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"content\" data=\"slot_var\" default=\"slot_var\" %}\n        {{ slot_var.input }}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"#dynamic-slots-and-fills","title":"Dynamic slots and fills","text":"<p>Until now, we were declaring slot and fill names statically, as a string literal, e.g.</p> <pre><code>{% slot \"content\" / %}\n</code></pre> <p>However, sometimes you may want to generate slots based on the given input. One example of this is a table component like that of Vuetify, which creates a header and an item slots for each user-defined column.</p> <p>In django_components you can achieve the same, simply by using a variable (or a template expression) instead of a string literal:</p> <pre><code>&lt;table&gt;\n  &lt;tr&gt;\n    {% for header in headers %}\n      &lt;th&gt;\n        {% slot \"header-{{ header.key }}\" value=header.title %}\n          {{ header.title }}\n        {% endslot %}\n      &lt;/th&gt;\n    {% endfor %}\n  &lt;/tr&gt;\n&lt;/table&gt;\n</code></pre> <p>When using the component, you can either set the fill explicitly:</p> <pre><code>{% component \"table\" headers=headers items=items %}\n  {% fill \"header-name\" data=\"data\" %}\n    &lt;b&gt;{{ data.value }}&lt;/b&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Or also use a variable:</p> <pre><code>{% component \"table\" headers=headers items=items %}\n  {# Make only the active column bold #}\n  {% fill \"header-{{ active_header_name }}\" data=\"data\" %}\n    &lt;b&gt;{{ data.value }}&lt;/b&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>NOTE: It's better to use static slot names whenever possible for clarity. The dynamic slot names should be reserved for advanced use only.</p> <p>Lastly, in rare cases, you can also pass the slot name via the spread operator. This is possible, because the slot name argument is actually a shortcut for a <code>name</code> keyword argument.</p> <p>So this:</p> <pre><code>{% slot \"content\" / %}\n</code></pre> <p>is the same as:</p> <pre><code>{% slot name=\"content\" / %}\n</code></pre> <p>So it's possible to define a <code>name</code> key on a dictionary, and then spread that onto the slot tag:</p> <pre><code>{# slot_props = {\"name\": \"content\"} #}\n{% slot ...slot_props / %}\n</code></pre>"},{"location":"#pass-through-all-the-slots","title":"Pass through all the slots","text":"<p>You can dynamically pass all slots to a child component. This is similar to passing all slots in Vue:</p> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        return {\n            \"slots\": self.input.slots,\n        }\n\n    template: \"\"\"\n    &lt;div&gt;\n      {% component \"child\" %}\n        {% for slot_name in slots %}\n          {% fill name=slot_name data=\"data\" %}\n            {% slot name=slot_name ...data / %}\n          {% endfill %}\n        {% endfor %}\n      {% endcomponent %}\n    &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"#accessing-data-passed-to-the-component","title":"Accessing data passed to the component","text":"<p>When you call <code>Component.render</code> or <code>Component.render_to_response</code>, the inputs to these methods can be accessed from within the instance under <code>self.input</code>.</p> <p>This means that you can use <code>self.input</code> inside: - <code>get_context_data</code> - <code>get_template_name</code> - <code>get_template</code> - <code>on_render_before</code> - <code>on_render_after</code></p> <p><code>self.input</code> is only defined during the execution of <code>Component.render</code>, and raises a <code>RuntimeError</code> when called outside of this context.</p> <p><code>self.input</code> has the same fields as the input to <code>Component.render</code>:</p> <pre><code>class TestComponent(Component):\n    def get_context_data(self, var1, var2, variable, another, **attrs):\n        assert self.input.args == (123, \"str\")\n        assert self.input.kwargs == {\"variable\": \"test\", \"another\": 1}\n        assert self.input.slots == {\"my_slot\": ...}\n        assert isinstance(self.input.context, Context)\n\n        return {\n            \"variable\": variable,\n        }\n\nrendered = TestComponent.render(\n    kwargs={\"variable\": \"test\", \"another\": 1},\n    args=(123, \"str\"),\n    slots={\"my_slot\": \"MY_SLOT\"},\n)\n</code></pre> <p>NOTE: The slots in <code>self.input.slots</code> are normalized to slot functions.</p>"},{"location":"#rendering-html-attributes","title":"Rendering HTML attributes","text":"<p>New in version 0.74:</p> <p>You can use the <code>html_attrs</code> tag to render HTML attributes, given a dictionary of values.</p> <p>So if you have a template:</p> <pre><code>&lt;div class=\"{{ classes }}\" data-id=\"{{ my_id }}\"&gt;\n&lt;/div&gt;\n</code></pre> <p>You can simplify it with <code>html_attrs</code> tag:</p> <pre><code>&lt;div {% html_attrs attrs %}&gt;\n&lt;/div&gt;\n</code></pre> <p>where <code>attrs</code> is:</p> <pre><code>attrs = {\n    \"class\": classes,\n    \"data-id\": my_id,\n}\n</code></pre> <p>This feature is inspired by <code>merge_attrs</code> tag of django-web-components and \"fallthrough attributes\" feature of Vue.</p>"},{"location":"#removing-atttributes","title":"Removing atttributes","text":"<p>Attributes that are set to <code>None</code> or <code>False</code> are NOT rendered.</p> <p>So given this input:</p> <pre><code>attrs = {\n    \"class\": \"text-green\",\n    \"required\": False,\n    \"data-id\": None,\n}\n</code></pre> <p>And template:</p> <pre><code>&lt;div {% html_attrs attrs %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Then this renders:</p> <pre><code>&lt;div class=\"text-green\"&gt;&lt;/div&gt;\n</code></pre>"},{"location":"#boolean-attributes","title":"Boolean attributes","text":"<p>In HTML, boolean attributes are usually rendered with no value. Consider the example below where the first button is disabled and the second is not:</p> <pre><code>&lt;button disabled&gt;Click me!&lt;/button&gt; &lt;button&gt;Click me!&lt;/button&gt;\n</code></pre> <p>HTML rendering with <code>html_attrs</code> tag or <code>attributes_to_string</code> works the same way, where <code>key=True</code> is rendered simply as <code>key</code>, and <code>key=False</code> is not render at all.</p> <p>So given this input:</p> <pre><code>attrs = {\n    \"disabled\": True,\n    \"autofocus\": False,\n}\n</code></pre> <p>And template:</p> <pre><code>&lt;div {% html_attrs attrs %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Then this renders:</p> <pre><code>&lt;div disabled&gt;&lt;/div&gt;\n</code></pre>"},{"location":"#default-attributes","title":"Default attributes","text":"<p>Sometimes you may want to specify default values for attributes. You can pass a second argument (or kwarg <code>defaults</code>) to set the defaults.</p> <pre><code>&lt;div {% html_attrs attrs defaults %}&gt;\n    ...\n&lt;/div&gt;\n</code></pre> <p>In the example above, if <code>attrs</code> contains e.g. the <code>class</code> key, <code>html_attrs</code> will render:</p> <p><code>class=\"{{ attrs.class }}\"</code></p> <p>Otherwise, <code>html_attrs</code> will render:</p> <p><code>class=\"{{ defaults.class }}\"</code></p>"},{"location":"#appending-attributes","title":"Appending attributes","text":"<p>For the <code>class</code> HTML attribute, it's common that we want to join multiple values, instead of overriding them. For example, if you're authoring a component, you may want to ensure that the component will ALWAYS have a specific class. Yet, you may want to allow users of your component to supply their own classes.</p> <p>We can achieve this by adding extra kwargs. These values will be appended, instead of overwriting the previous value.</p> <p>So if we have a variable <code>attrs</code>:</p> <pre><code>attrs = {\n    \"class\": \"my-class pa-4\",\n}\n</code></pre> <p>And on <code>html_attrs</code> tag, we set the key <code>class</code>:</p> <pre><code>&lt;div {% html_attrs attrs class=\"some-class\" %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Then these will be merged and rendered as:</p> <pre><code>&lt;div data-value=\"my-class pa-4 some-class\"&gt;&lt;/div&gt;\n</code></pre> <p>To simplify merging of variables, you can supply the same key multiple times, and these will be all joined together:</p> <pre><code>{# my_var = \"class-from-var text-red\" #}\n&lt;div {% html_attrs attrs class=\"some-class another-class\" class=my_var %}&gt;\n&lt;/div&gt;\n</code></pre> <p>Renders:</p> <pre><code>&lt;div\n  data-value=\"my-class pa-4 some-class another-class class-from-var text-red\"\n&gt;&lt;/div&gt;\n</code></pre>"},{"location":"#rules-for-html_attrs","title":"Rules for <code>html_attrs</code>","text":"<ol> <li>Both <code>attrs</code> and <code>defaults</code> can be passed as positional args</li> </ol> <p><code>{% html_attrs attrs defaults key=val %}</code></p> <p>or as kwargs</p> <p><code>{% html_attrs key=val defaults=defaults attrs=attrs %}</code></p> <ol> <li> <p>Both <code>attrs</code> and <code>defaults</code> are optional (can be omitted)</p> </li> <li> <p>Both <code>attrs</code> and <code>defaults</code> are dictionaries, and we can define them the same way we define dictionaries for the <code>component</code> tag. So either as <code>attrs=attrs</code> or <code>attrs:key=value</code>.</p> </li> <li> <p>All other kwargs are appended and can be repeated.</p> </li> </ol>"},{"location":"#examples-for-html_attrs","title":"Examples for <code>html_attrs</code>","text":"<p>Assuming that:</p> <pre><code>class_from_var = \"from-var\"\n\nattrs = {\n    \"class\": \"from-attrs\",\n    \"type\": \"submit\",\n}\n\ndefaults = {\n    \"class\": \"from-defaults\",\n    \"role\": \"button\",\n}\n</code></pre> <p>Then:</p> <ul> <li>Empty tag  <code>{% html_attr %}</code></li> </ul> <p>renders (empty string):  <code></code></p> <ul> <li>Only kwargs  <code>{% html_attr class=\"some-class\" class=class_from_var data-id=\"123\" %}</code></li> </ul> <p>renders:  <code>class=\"some-class from-var\" data-id=\"123\"</code></p> <ul> <li>Only attrs  <code>{% html_attr attrs %}</code></li> </ul> <p>renders:  <code>class=\"from-attrs\" type=\"submit\"</code></p> <ul> <li>Attrs as kwarg  <code>{% html_attr attrs=attrs %}</code></li> </ul> <p>renders:  <code>class=\"from-attrs\" type=\"submit\"</code></p> <ul> <li>Only defaults (as kwarg)  <code>{% html_attr defaults=defaults %}</code></li> </ul> <p>renders:  <code>class=\"from-defaults\" role=\"button\"</code></p> <ul> <li>Attrs using the <code>prefix:key=value</code> construct  <code>{% html_attr attrs:class=\"from-attrs\" attrs:type=\"submit\" %}</code></li> </ul> <p>renders:  <code>class=\"from-attrs\" type=\"submit\"</code></p> <ul> <li>Defaults using the <code>prefix:key=value</code> construct  <code>{% html_attr defaults:class=\"from-defaults\" %}</code></li> </ul> <p>renders:  <code>class=\"from-defaults\" role=\"button\"</code></p> <ul> <li>All together (1) - attrs and defaults as positional args:  <code>{% html_attrs attrs defaults class=\"added_class\" class=class_from_var data-id=123 %}</code></li> </ul> <p>renders:  <code>class=\"from-attrs added_class from-var\" type=\"submit\" role=\"button\" data-id=123</code></p> <ul> <li>All together (2) - attrs and defaults as kwargs args:  <code>{% html_attrs class=\"added_class\" class=class_from_var data-id=123 attrs=attrs defaults=defaults %}</code></li> </ul> <p>renders:  <code>class=\"from-attrs added_class from-var\" type=\"submit\" role=\"button\" data-id=123</code></p> <ul> <li>All together (3) - mixed:  <code>{% html_attrs attrs defaults:class=\"default-class\" class=\"added_class\" class=class_from_var data-id=123 %}</code></li> </ul> <p>renders:  <code>class=\"from-attrs added_class from-var\" type=\"submit\" data-id=123</code></p>"},{"location":"#full-example-for-html_attrs","title":"Full example for <code>html_attrs</code>","text":"<pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template: t.django_html = \"\"\"\n        &lt;div\n            {% html_attrs attrs\n                defaults:class=\"pa-4 text-red\"\n                class=\"my-comp-date\"\n                class=class_from_var\n                data-id=\"123\"\n            %}\n        &gt;\n            Today's date is &lt;span&gt;{{ date }}&lt;/span&gt;\n        &lt;/div&gt;\n    \"\"\"\n\n    def get_context_data(self, date: Date, attrs: dict):\n        return {\n            \"date\": date,\n            \"attrs\": attrs,\n            \"class_from_var\": \"extra-class\"\n        }\n\n@register(\"parent\")\nclass Parent(Component):\n    template: t.django_html = \"\"\"\n        {% component \"my_comp\"\n            date=date\n            attrs:class=\"pa-0 border-solid border-red\"\n            attrs:data-json=json_data\n            attrs:@click=\"(e) =&gt; onClick(e, 'from_parent')\"\n        / %}\n    \"\"\"\n\n    def get_context_data(self, date: Date):\n        return {\n            \"date\": datetime.now(),\n            \"json_data\": json.dumps({\"value\": 456})\n        }\n</code></pre> <p>Note: For readability, we've split the tags across multiple lines.</p> <p>Inside <code>MyComp</code>, we defined a default attribute</p> <p><code>defaults:class=\"pa-4 text-red\"</code></p> <p>So if <code>attrs</code> includes key <code>class</code>, the default above will be ignored.</p> <p><code>MyComp</code> also defines <code>class</code> key twice. It means that whether the <code>class</code> attribute is taken from <code>attrs</code> or <code>defaults</code>, the two <code>class</code> values will be appended to it.</p> <p>So by default, <code>MyComp</code> renders:</p> <pre><code>&lt;div class=\"pa-4 text-red my-comp-date extra-class\" data-id=\"123\"&gt;...&lt;/div&gt;\n</code></pre> <p>Next, let's consider what will be rendered when we call <code>MyComp</code> from <code>Parent</code> component.</p> <p><code>MyComp</code> accepts a <code>attrs</code> dictionary, that is passed to <code>html_attrs</code>, so the contents of that dictionary are rendered as the HTML attributes.</p> <p>In <code>Parent</code>, we make use of passing dictionary key-value pairs as kwargs to define individual attributes as if they were regular kwargs.</p> <p>So all kwargs that start with <code>attrs:</code> will be collected into an <code>attrs</code> dict.</p> <pre><code>    attrs:class=\"pa-0 border-solid border-red\"\n    attrs:data-json=json_data\n    attrs:@click=\"(e) =&gt; onClick(e, 'from_parent')\"\n</code></pre> <p>And <code>get_context_data</code> of <code>MyComp</code> will receive <code>attrs</code> input with following keys:</p> <pre><code>attrs = {\n    \"class\": \"pa-0 border-solid\",\n    \"data-json\": '{\"value\": 456}',\n    \"@click\": \"(e) =&gt; onClick(e, 'from_parent')\",\n}\n</code></pre> <p><code>attrs[\"class\"]</code> overrides the default value for <code>class</code>, whereas other keys will be merged.</p> <p>So in the end <code>MyComp</code> will render:</p> <pre><code>&lt;div\n  class=\"pa-0 border-solid my-comp-date extra-class\"\n  data-id=\"123\"\n  data-json='{\"value\": 456}'\n  @click=\"(e) =&gt; onClick(e, 'from_parent')\"\n&gt;\n  ...\n&lt;/div&gt;\n</code></pre>"},{"location":"#rendering-html-attributes-outside-of-templates","title":"Rendering HTML attributes outside of templates","text":"<p>If you need to use serialize HTML attributes outside of Django template and the <code>html_attrs</code> tag, you can use <code>attributes_to_string</code>:</p> <pre><code>from django_components.attributes import attributes_to_string\n\nattrs = {\n    \"class\": \"my-class text-red pa-4\",\n    \"data-id\": 123,\n    \"required\": True,\n    \"disabled\": False,\n    \"ignored-attr\": None,\n}\n\nattributes_to_string(attrs)\n# 'class=\"my-class text-red pa-4\" data-id=\"123\" required'\n</code></pre>"},{"location":"#template-tag-syntax","title":"Template tag syntax","text":"<p>All template tags in django_component, like <code>{% component %}</code> or <code>{% slot %}</code>, and so on, support extra syntax that makes it possible to write components like in Vue or React (JSX).</p>"},{"location":"#self-closing-tags","title":"Self-closing tags","text":"<p>When you have a tag like <code>{% component %}</code> or <code>{% slot %}</code>, but it has no content, you can simply append a forward slash <code>/</code> at the end, instead of writing out the closing tags like <code>{% endcomponent %}</code> or <code>{% endslot %}</code>:</p> <p>So this:</p> <pre><code>{% component \"button\" %}{% endcomponent %}\n</code></pre> <p>becomes</p> <pre><code>{% component \"button\" / %}\n</code></pre>"},{"location":"#special-characters","title":"Special characters","text":"<p>New in version 0.71:</p> <p>Keyword arguments can contain special characters <code># @ . - _</code>, so keywords like so are still valid:</p> <pre><code>&lt;body&gt;\n    {% component \"calendar\" my-date=\"2015-06-19\" @click.native=do_something #some_id=True / %}\n&lt;/body&gt;\n</code></pre> <p>These can then be accessed inside <code>get_context_data</code> so:</p> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    # Since # . @ - are not valid identifiers, we have to\n    # use `**kwargs` so the method can accept these args.\n    def get_context_data(self, **kwargs):\n        return {\n            \"date\": kwargs[\"my-date\"],\n            \"id\": kwargs[\"#some_id\"],\n            \"on_click\": kwargs[\"@click.native\"]\n        }\n</code></pre>"},{"location":"#spread-operator","title":"Spread operator","text":"<p>New in version 0.93:</p> <p>Instead of passing keyword arguments one-by-one:</p> <pre><code>{% component \"calendar\" title=\"How to abc\" date=\"2015-06-19\" author=\"John Wick\" / %}\n</code></pre> <p>You can use a spread operator <code>...dict</code> to apply key-value pairs from a dictionary:</p> <pre><code>post_data = {\n    \"title\": \"How to...\",\n    \"date\": \"2015-06-19\",\n    \"author\": \"John Wick\",\n}\n</code></pre> <pre><code>{% component \"calendar\" ...post_data / %}\n</code></pre> <p>This behaves similar to JSX's spread operator or Vue's <code>v-bind</code>.</p> <p>Spread operators are treated as keyword arguments, which means that: 1. Spread operators must come after positional arguments. 2. You cannot use spread operators for positional-only arguments.</p> <p>Other than that, you can use spread operators multiple times, and even put keyword arguments in-between or after them:</p> <pre><code>{% component \"calendar\" ...post_data id=post.id ...extra / %}\n</code></pre> <p>In a case of conflicts, the values added later (right-most) overwrite previous values.</p>"},{"location":"#use-template-tags-inside-component-inputs","title":"Use template tags inside component inputs","text":"<p>New in version 0.93</p> <p>When passing data around, sometimes you may need to do light transformations, like negating booleans or filtering lists.</p> <p>Normally, what you would have to do is to define ALL the variables inside <code>get_context_data()</code>. But this can get messy if your components contain a lot of logic.</p> <pre><code>@register(\"calendar\")\nclass Calendar(Component):\n    def get_context_data(self, id: str, editable: bool):\n        return {\n            \"editable\": editable,\n            \"readonly\": not editable,\n            \"input_id\": f\"input-{id}\",\n            \"icon_id\": f\"icon-{id}\",\n            ...\n        }\n</code></pre> <p>Instead, template tags in django_components (<code>{% component %}</code>, <code>{% slot %}</code>, <code>{% provide %}</code>, etc) allow you to treat literal string values as templates:</p> <pre><code>{% component 'blog_post'\n  \"As positional arg {# yay #}\"\n  title=\"{{ person.first_name }} {{ person.last_name }}\"\n  id=\"{% random_int 10 20 %}\"\n  readonly=\"{{ editable|not }}\"\n  author=\"John Wick {# TODO: parametrize #}\"\n/ %}\n</code></pre> <p>In the example above: - Component <code>test</code> receives a positional argument with value <code>\"As positional arg \"</code>. The comment is omitted. - Kwarg <code>title</code> is passed as a string, e.g. <code>John Doe</code> - Kwarg <code>id</code> is passed as <code>int</code>, e.g. <code>15</code> - Kwarg <code>readonly</code> is passed as <code>bool</code>, e.g. <code>False</code> - Kwarg <code>author</code> is passed as a string, e.g. <code>John Wick</code> (Comment omitted)</p> <p>This is inspired by django-cotton.</p>"},{"location":"#passing-data-as-string-vs-original-values","title":"Passing data as string vs original values","text":"<p>Sometimes you may want to use the template tags to transform or generate the data that is then passed to the component.</p> <p>The data doesn't necessarily have to be strings. In the example above, the kwarg <code>id</code> was passed as an integer, NOT a string.</p> <p>Although the string literals for components inputs are treated as regular Django templates, there is one special case:</p> <p>When the string literal contains only a single template tag, with no extra text, then the value is passed as the original type instead of a string.</p> <p>Here, <code>page</code> is an integer:</p> <pre><code>{% component 'blog_post' page=\"{% random_int 10 20 %}\" / %}\n</code></pre> <p>Here, <code>page</code> is a string:</p> <pre><code>{% component 'blog_post' page=\" {% random_int 10 20 %} \" / %}\n</code></pre> <p>And same applies to the <code>{{ }}</code> variable tags:</p> <p>Here, <code>items</code> is a list:</p> <pre><code>{% component 'cat_list' items=\"{{ cats|slice:':2' }}\" / %}\n</code></pre> <p>Here, <code>items</code> is a string:</p> <pre><code>{% component 'cat_list' items=\"{{ cats|slice:':2' }} See more\" / %}\n</code></pre>"},{"location":"#evaluating-python-expressions-in-template","title":"Evaluating Python expressions in template","text":"<p>You can even go a step further and have a similar experience to Vue or React, where you can evaluate arbitrary code expressions:</p> <pre><code>&lt;MyForm\n  value={ isEnabled ? inputValue : null }\n/&gt;\n</code></pre> <p>Similar is possible with <code>django-expr</code>, which adds an <code>expr</code> tag and filter that you can use to evaluate Python expressions from within the template:</p> <pre><code>{% component \"my_form\"\n  value=\"{% expr 'input_value if is_enabled else None' %}\"\n/ %}\n</code></pre> <p>Note: Never use this feature to mix business logic and template logic. Business logic should still be in the view!</p>"},{"location":"#pass-dictonary-by-its-key-value-pairs","title":"Pass dictonary by its key-value pairs","text":"<p>New in version 0.74:</p> <p>Sometimes, a component may expect a dictionary as one of its inputs.</p> <p>Most commonly, this happens when a component accepts a dictionary of HTML attributes (usually called <code>attrs</code>) to pass to the underlying template.</p> <p>In such cases, we may want to define some HTML attributes statically, and other dynamically. But for that, we need to define this dictionary on Python side:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        {% component \"other\" attrs=attrs / %}\n    \"\"\"\n\n    def get_context_data(self, some_id: str):\n        attrs = {\n            \"class\": \"pa-4 flex\",\n            \"data-some-id\": some_id,\n            \"@click.stop\": \"onClickHandler\",\n        }\n        return {\"attrs\": attrs}\n</code></pre> <p>But as you can see in the case above, the event handler <code>@click.stop</code> and styling <code>pa-4 flex</code> are disconnected from the template. If the component grew in size and we moved the HTML to a separate file, we would have hard time reasoning about the component's template.</p> <p>Luckily, there's a better way.</p> <p>When we want to pass a dictionary to a component, we can define individual key-value pairs as component kwargs, so we can keep all the relevant information in the template. For that, we prefix the key with the name of the dict and <code>:</code>. So key <code>class</code> of input <code>attrs</code> becomes <code>attrs:class</code>. And our example becomes:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"\"\"\n        {% component \"other\"\n            attrs:class=\"pa-4 flex\"\n            attrs:data-some-id=some_id\n            attrs:@click.stop=\"onClickHandler\"\n        / %}\n    \"\"\"\n\n    def get_context_data(self, some_id: str):\n        return {\"some_id\": some_id}\n</code></pre> <p>Sweet! Now all the relevant HTML is inside the template, and we can move it to a separate file with confidence:</p> <pre><code>{% component \"other\"\n    attrs:class=\"pa-4 flex\"\n    attrs:data-some-id=some_id\n    attrs:@click.stop=\"onClickHandler\"\n/ %}\n</code></pre> <p>Note: It is NOT possible to define nested dictionaries, so <code>attrs:my_key:two=2</code> would be interpreted as:</p> <pre><code>{\"attrs\": {\"my_key:two\": 2}}\n</code></pre>"},{"location":"#multi-line-tags","title":"Multi-line tags","text":"<p>By default, Django expects a template tag to be defined on a single line.</p> <p>However, this can become unwieldy if you have a component with a lot of inputs:</p> <pre><code>{% component \"card\" title=\"Joanne Arc\" subtitle=\"Head of Kitty Relations\" date_last_active=\"2024-09-03\" ... %}\n</code></pre> <p>Instead, when you install django_components, it automatically configures Django to suport multi-line tags.</p> <p>So we can rewrite the above as:</p> <pre><code>{% component \"card\"\n    title=\"Joanne Arc\"\n    subtitle=\"Head of Kitty Relations\"\n    date_last_active=\"2024-09-03\"\n    ...\n%}\n</code></pre> <p>Much better!</p> <p>To disable this behavior, set <code>COMPONENTS.multiline_tag</code> to <code>False</code></p>"},{"location":"#prop-drilling-and-dependency-injection-provide-inject","title":"Prop drilling and dependency injection (provide / inject)","text":"<p>New in version 0.80:</p> <p>Django components supports dependency injection with the combination of:</p> <ol> <li><code>{% provide %}</code> tag</li> <li><code>inject()</code> method of the <code>Component</code> class</li> </ol>"},{"location":"#what-is-dependency-injection-and-prop-drilling","title":"What is \"dependency injection\" and \"prop drilling\"?","text":"<p>Prop drilling refers to a scenario in UI development where you need to pass data through many layers of a component tree to reach the nested components that actually need the data.</p> <p>Normally, you'd use props to send data from a parent component to its children. However, this straightforward method becomes cumbersome and inefficient if the data has to travel through many levels or if several components scattered at different depths all need the same piece of information.</p> <p>This results in a situation where the intermediate components, which don't need the data for their own functioning, end up having to manage and pass along these props. This clutters the component tree and makes the code verbose and harder to manage.</p> <p>A neat solution to avoid prop drilling is using the \"provide and inject\" technique, AKA dependency injection.</p> <p>With dependency injection, a parent component acts like a data hub for all its descendants. This setup allows any component, no matter how deeply nested it is, to access the required data directly from this centralized provider without having to messily pass props down the chain. This approach significantly cleans up the code and makes it easier to maintain.</p> <p>This feature is inspired by Vue's Provide / Inject and React's Context / useContext.</p>"},{"location":"#how-to-use-provide-inject","title":"How to use provide / inject","text":"<p>As the name suggest, using provide / inject consists of 2 steps</p> <ol> <li>Providing data</li> <li>Injecting provided data</li> </ol> <p>For examples of advanced uses of provide / inject, see this discussion.</p>"},{"location":"#using-provide-tag","title":"Using <code>{% provide %}</code> tag","text":"<p>First we use the <code>{% provide %}</code> tag to define the data we want to \"provide\" (make available).</p> <pre><code>{% provide \"my_data\" key=\"hi\" another=123 %}\n    {% component \"child\" / %}  &lt;--- Can access \"my_data\"\n{% endprovide %}\n\n{% component \"child\" / %}  &lt;--- Cannot access \"my_data\"\n</code></pre> <p>Notice that the <code>provide</code> tag REQUIRES a name as a first argument. This is the key by which we can then access the data passed to this tag.</p> <p><code>provide</code> tag name must resolve to a valid identifier (AKA a valid Python variable name).</p> <p>Once you've set the name, you define the data you want to \"provide\" by passing it as keyword arguments. This is similar to how you pass data to the <code>{% with %}</code> tag.</p> <p>NOTE: Kwargs passed to <code>{% provide %}</code> are NOT added to the context. In the example below, the <code>{{ key }}</code> won't render anything:</p> <pre><code>{% provide \"my_data\" key=\"hi\" another=123 %}\n    {{ key }}\n{% endprovide %}\n</code></pre> <p>Similarly to slots and fills, also provide's name argument can be set dynamically via a variable, a template expression, or a spread operator:</p> <pre><code>{% provide name=name ... %}\n    ...\n{% provide %}\n&lt;/table&gt;\n</code></pre>"},{"location":"#using-inject-method","title":"Using <code>inject()</code> method","text":"<p>To \"inject\" (access) the data defined on the <code>provide</code> tag, you can use the <code>inject()</code> method inside of <code>get_context_data()</code>.</p> <p>For a component to be able to \"inject\" some data, the component (<code>{% component %}</code> tag) must be nested inside the <code>{% provide %}</code> tag.</p> <p>In the example from previous section, we've defined two kwargs: <code>key=\"hi\" another=123</code>. That means that if we now inject <code>\"my_data\"</code>, we get an object with 2 attributes - <code>key</code> and <code>another</code>.</p> <pre><code>class ChildComponent(Component):\n    def get_context_data(self):\n        my_data = self.inject(\"my_data\")\n        print(my_data.key)     # hi\n        print(my_data.another) # 123\n        return {}\n</code></pre> <p>First argument to <code>inject</code> is the key (or name) of the provided data. This must match the string that you used in the <code>provide</code> tag. If no provider with given key is found, <code>inject</code> raises a <code>KeyError</code>.</p> <p>To avoid the error, you can pass a second argument to <code>inject</code> to which will act as a default value, similar to <code>dict.get(key, default)</code>:</p> <pre><code>class ChildComponent(Component):\n    def get_context_data(self):\n        my_data = self.inject(\"invalid_key\", DEFAULT_DATA)\n        assert my_data == DEFAUKT_DATA\n        return {}\n</code></pre> <p>The instance returned from <code>inject()</code> is a subclass of <code>NamedTuple</code>, so the instance is immutable. This ensures that the data returned from <code>inject</code> will always have all the keys that were passed to the <code>provide</code> tag.</p> <p>NOTE: <code>inject()</code> works strictly only in <code>get_context_data</code>. If you try to call it from elsewhere, it will raise an error.</p>"},{"location":"#full-example","title":"Full example","text":"<pre><code>@register(\"child\")\nclass ChildComponent(Component):\n    template = \"\"\"\n        &lt;div&gt; {{ my_data.key }} &lt;/div&gt;\n        &lt;div&gt; {{ my_data.another }} &lt;/div&gt;\n    \"\"\"\n\n    def get_context_data(self):\n        my_data = self.inject(\"my_data\", \"default\")\n        return {\"my_data\": my_data}\n\ntemplate_str = \"\"\"\n    {% load component_tags %}\n    {% provide \"my_data\" key=\"hi\" another=123 %}\n        {% component \"child\" / %}\n    {% endprovide %}\n\"\"\"\n</code></pre> <p>renders:</p> <pre><code>&lt;div&gt;hi&lt;/div&gt;\n&lt;div&gt;123&lt;/div&gt;\n</code></pre>"},{"location":"#component-hooks","title":"Component hooks","text":"<p>New in version 0.96</p> <p>Component hooks are functions that allow you to intercept the rendering process at specific positions.</p>"},{"location":"#available-hooks","title":"Available hooks","text":"<ul> <li><code>on_render_before</code></li> </ul> <pre><code>def on_render_before(\n    self: Component,\n    context: Context,\n    template: Template\n) -&gt; None:\n</code></pre> <pre><code>Hook that runs just before the component's template is rendered.\n\nYou can use this hook to access or modify the context or the template:\n\n```py\ndef on_render_before(self, context, template) -&gt; None:\n    # Insert value into the Context\n    context[\"from_on_before\"] = \":)\"\n\n    # Append text into the Template\n    template.nodelist.append(TextNode(\"FROM_ON_BEFORE\"))\n```\n</code></pre> <ul> <li><code>on_render_after</code></li> </ul> <pre><code>def on_render_after(\n    self: Component,\n    context: Context,\n    template: Template,\n    content: str\n) -&gt; None | str | SafeString:\n</code></pre> <pre><code>Hook that runs just after the component's template was rendered.\nIt receives the rendered output as the last argument.\n\nYou can use this hook to access the context or the template, but modifying\nthem won't have any effect.\n\nTo override the content that gets rendered, you can return a string or SafeString from this hook:\n\n```py\ndef on_render_after(self, context, template, content):\n    # Prepend text to the rendered content\n    return \"Chocolate cookie recipe: \" + content\n```\n</code></pre>"},{"location":"#component-hooks-example","title":"Component hooks example","text":"<p>You can use hooks together with provide / inject to create components that accept a list of items via a slot.</p> <p>In the example below, each <code>tab_item</code> component will be rendered on a separate tab page, but they are all defined in the default slot of the <code>tabs</code> component.</p> <p>See here for how it was done</p> <pre><code>{% component \"tabs\" %}\n  {% component \"tab_item\" header=\"Tab 1\" %}\n    &lt;p&gt;\n      hello from tab 1\n    &lt;/p&gt;\n    {% component \"button\" %}\n      Click me!\n    {% endcomponent %}\n  {% endcomponent %}\n\n  {% component \"tab_item\" header=\"Tab 2\" %}\n    Hello this is tab 2\n  {% endcomponent %}\n{% endcomponent %}\n</code></pre>"},{"location":"#component-context-and-scope","title":"Component context and scope","text":"<p>By default, context variables are passed down the template as in regular Django - deeper scopes can access the variables from the outer scopes. So if you have several nested forloops, then inside the deep-most loop you can access variables defined by all previous loops.</p> <p>With this in mind, the <code>{% component %}</code> tag behaves similarly to <code>{% include %}</code> tag - inside the component tag, you can access all variables that were defined outside of it.</p> <p>And just like with <code>{% include %}</code>, if you don't want a specific component template to have access to the parent context, add <code>only</code> to the <code>{% component %}</code> tag:</p> <pre><code>{% component \"calendar\" date=\"2015-06-19\" only / %}\n</code></pre> <p>NOTE: <code>{% csrf_token %}</code> tags need access to the top-level context, and they will not function properly if they are rendered in a component that is called with the <code>only</code> modifier.</p> <p>If you find yourself using the <code>only</code> modifier often, you can set the context_behavior option to <code>\"isolated\"</code>, which automatically applies the <code>only</code> modifier. This is useful if you want to make sure that components don't accidentally access the outer context.</p> <p>Components can also access the outer context in their context methods like <code>get_context_data</code> by accessing the property <code>self.outer_context</code>.</p>"},{"location":"#example-of-accessing-outer-context","title":"Example of Accessing Outer Context","text":"<pre><code>&lt;div&gt;\n  {% component \"calender\" / %}\n&lt;/div&gt;\n</code></pre> <p>Assuming that the rendering context has variables such as <code>date</code>, you can use <code>self.outer_context</code> to access them from within <code>get_context_data</code>. Here's how you might implement it:</p> <pre><code>class Calender(Component):\n\n    ...\n\n    def get_context_data(self):\n        outer_field = self.outer_context[\"date\"]\n        return {\n            \"date\": outer_fields,\n        }\n</code></pre> <p>However, as a best practice, it\u2019s recommended not to rely on accessing the outer context directly through <code>self.outer_context</code>. Instead, explicitly pass the variables to the component. For instance, continue passing the variables in the component tag as shown in the previous examples.</p>"},{"location":"#pre-defined-template-variables","title":"Pre-defined template variables","text":"<p>Here is a list of all variables that are automatically available from within the component's template and <code>on_render_before</code> / <code>on_render_after</code> hooks.</p> <ul> <li> <p><code>component_vars.is_filled</code></p> <p>New in version 0.70</p> <p>Dictonary describing which slots are filled (<code>True</code>) or are not (<code>False</code>).</p> <p>Example:</p> <pre><code>{% if component_vars.is_filled.my_slot %}\n    {% slot \"my_slot\" / %}\n{% endif %}\n</code></pre> <p>This is equivalent to checking if a given key is among the slot fills:</p> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        return {\n            \"my_slot_filled\": \"my_slot\" in self.input.slots\n        }\n</code></pre> </li> </ul>"},{"location":"#customizing-component-tags-with-tagformatter","title":"Customizing component tags with TagFormatter","text":"<p>New in version 0.89</p> <p>By default, components are rendered using the pair of <code>{% component %}</code> / <code>{% endcomponent %}</code> template tags:</p> <pre><code>{% component \"button\" href=\"...\" disabled %}\nClick me!\n{% endcomponent %}\n\n{# or #}\n\n{% component \"button\" href=\"...\" disabled / %}\n</code></pre> <p>You can change this behaviour in the settings under the <code>COMPONENTS.tag_formatter</code>.</p> <p>For example, if you set the tag formatter to <code>django_components.component_shorthand_formatter</code>, the components will use their name as the template tags:</p> <pre><code>{% button href=\"...\" disabled %}\n  Click me!\n{% endbutton %}\n\n{# or #}\n\n{% button href=\"...\" disabled / %}\n</code></pre>"},{"location":"#available-tagformatters","title":"Available TagFormatters","text":"<p>django_components provides following predefined TagFormatters:</p> <ul> <li> <p><code>ComponentFormatter</code> (<code>django_components.component_formatter</code>)</p> <p>Default</p> <p>Uses the <code>component</code> and <code>endcomponent</code> tags, and the component name is gives as the first positional argument.</p> <p>Example as block: <pre><code>{% component \"button\" href=\"...\" %}\n    {% fill \"content\" %}\n        ...\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% component \"button\" href=\"...\" / %}\n</code></pre></p> </li> <li> <p><code>ShorthandComponentFormatter</code> (<code>django_components.component_shorthand_formatter</code>)</p> <p>Uses the component name as start tag, and <code>end&lt;component_name&gt;</code> as an end tag.</p> <p>Example as block: <pre><code>{% button href=\"...\" %}\n    Click me!\n{% endbutton %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% button href=\"...\" / %}\n</code></pre></p> </li> </ul>"},{"location":"#writing-your-own-tagformatter","title":"Writing your own TagFormatter","text":""},{"location":"#background","title":"Background","text":"<p>First, let's discuss how TagFormatters work, and how components are rendered in django_components.</p> <p>When you render a component with <code>{% component %}</code> (or your own tag), the following happens: 1. <code>component</code> must be registered as a Django's template tag 2. Django triggers django_components's tag handler for tag <code>component</code>. 3. The tag handler passes the tag contents for pre-processing to <code>TagFormatter.parse()</code>.</p> <pre><code>So if you render this:\n```django\n{% component \"button\" href=\"...\" disabled %}\n{% endcomponent %}\n```\n\nThen `TagFormatter.parse()` will receive a following input:\n```py\n[\"component\", '\"button\"', 'href=\"...\"', 'disabled']\n```\n</code></pre> <ol> <li> <p><code>TagFormatter</code> extracts the component name and the remaining input.</p> <p>So, given the above, <code>TagFormatter.parse()</code> returns the following: <pre><code>TagResult(\n    component_name=\"button\",\n    tokens=['href=\"...\"', 'disabled']\n)\n</code></pre> 5. The tag handler resumes, using the tokens returned from <code>TagFormatter</code>.</p> <p>So, continuing the example, at this point the tag handler practically behaves as if you rendered: <pre><code>{% component href=\"...\" disabled %}\n</code></pre> 6. Tag handler looks up the component <code>button</code>, and passes the args, kwargs, and slots to it.</p> </li> </ol>"},{"location":"#tagformatter","title":"TagFormatter","text":"<p><code>TagFormatter</code> handles following parts of the process above: - Generates start/end tags, given a component. This is what you then call from within your template as <code>{% component %}</code>.</p> <ul> <li>When you <code>{% component %}</code>, tag formatter pre-processes the tag contents, so it can link back the custom template tag to the right component.</li> </ul> <p>To do so, subclass from <code>TagFormatterABC</code> and implement following method: - <code>start_tag</code> - <code>end_tag</code> - <code>parse</code></p> <p>For example, this is the implementation of <code>ShorthandComponentFormatter</code></p> <pre><code>class ShorthandComponentFormatter(TagFormatterABC):\n    # Given a component name, generate the start template tag\n    def start_tag(self, name: str) -&gt; str:\n        return name  # e.g. 'button'\n\n    # Given a component name, generate the start template tag\n    def end_tag(self, name: str) -&gt; str:\n        return f\"end{name}\"  # e.g. 'endbutton'\n\n    # Given a tag, e.g.\n    # `{% button href=\"...\" disabled %}`\n    #\n    # The parser receives:\n    # `['button', 'href=\"...\"', 'disabled']`\n    def parse(self, tokens: List[str]) -&gt; TagResult:\n        tokens = [*tokens]\n        name = tokens.pop(0)\n        return TagResult(\n            name,  # e.g. 'button'\n            tokens  # e.g. ['href=\"...\"', 'disabled']\n        )\n</code></pre> <p>That's it! And once your <code>TagFormatter</code> is ready, don't forget to update the settings!</p>"},{"location":"#defining-htmljscss-files","title":"Defining HTML/JS/CSS files","text":"<p>django_component's management of files builds on top of Django's <code>Media</code> class.</p> <p>To be familiar with how Django handles static files, we recommend reading also:</p> <ul> <li>How to manage static files (e.g. images, JavaScript, CSS)</li> </ul>"},{"location":"#defining-file-paths-relative-to-component-or-static-dirs","title":"Defining file paths relative to component or static dirs","text":"<p>As seen in the getting started example, to associate HTML/JS/CSS files with a component, you set them as <code>template_name</code>, <code>Media.js</code> and <code>Media.css</code> respectively:</p> <pre><code># In a file [project root]/components/calendar/calendar.py\nfrom django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_name = \"template.html\"\n\n    class Media:\n        css = \"style.css\"\n        js = \"script.js\"\n</code></pre> <p>In the example above, the files are defined relative to the directory where <code>component.py</code> is.</p> <p>Alternatively, you can specify the file paths relative to the directories set in <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code>.</p> <p>Assuming that <code>COMPONENTS.dirs</code> contains path <code>[project root]/components</code>, we can rewrite the example as:</p> <pre><code># In a file [project root]/components/calendar/calendar.py\nfrom django_components import Component, register\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_name = \"calendar/template.html\"\n\n    class Media:\n        css = \"calendar/style.css\"\n        js = \"calendar/script.js\"\n</code></pre> <p>NOTE: In case of conflict, the preference goes to resolving the files relative to the component's directory.</p>"},{"location":"#defining-multiple-paths","title":"Defining multiple paths","text":"<p>Each component can have only a single template. However, you can define as many JS or CSS files as you want using a list.</p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = [\"path/to/script1.js\", \"path/to/script2.js\"]\n        css = [\"path/to/style1.css\", \"path/to/style2.css\"]\n</code></pre>"},{"location":"#configuring-css-media-types","title":"Configuring CSS Media Types","text":"<p>You can define which stylesheets will be associated with which CSS Media types. You do so by defining CSS files as a dictionary.</p> <p>See the corresponding Django Documentation.</p> <p>Again, you can set either a single file or a list of files per media type:</p> <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": \"path/to/style1.css\",\n            \"print\": \"path/to/style2.css\",\n        }\n</code></pre> <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": [\"path/to/style1.css\", \"path/to/style2.css\"],\n            \"print\": [\"path/to/style3.css\", \"path/to/style4.css\"],\n        }\n</code></pre> <p>NOTE: When you define CSS as a string or a list, the <code>all</code> media type is implied.</p>"},{"location":"#supported-types-for-file-paths","title":"Supported types for file paths","text":"<p>File paths can be any of:</p> <ul> <li><code>str</code></li> <li><code>bytes</code></li> <li><code>PathLike</code> (<code>__fspath__</code> method)</li> <li><code>SafeData</code> (<code>__html__</code> method)</li> <li><code>Callable</code> that returns any of the above, evaluated at class creation (<code>__new__</code>)</li> </ul> <pre><code>from pathlib import Path\n\nfrom django.utils.safestring import mark_safe\n\nclass SimpleComponent(Component):\n    class Media:\n        css = [\n            mark_safe('&lt;link href=\"/static/calendar/style.css\" rel=\"stylesheet\" /&gt;'),\n            Path(\"calendar/style1.css\"),\n            \"calendar/style2.css\",\n            b\"calendar/style3.css\",\n            lambda: \"calendar/style4.css\",\n        ]\n        js = [\n            mark_safe('&lt;script src=\"/static/calendar/script.js\"&gt;&lt;/script&gt;'),\n            Path(\"calendar/script1.js\"),\n            \"calendar/script2.js\",\n            b\"calendar/script3.js\",\n            lambda: \"calendar/script4.js\",\n        ]\n</code></pre>"},{"location":"#path-as-objects","title":"Path as objects","text":"<p>In the example above, you could see that when we used <code>mark_safe</code> to mark a string as a <code>SafeString</code>, we had to define the full <code>&lt;script&gt;</code>/<code>&lt;link&gt;</code> tag.</p> <p>This is an extension of Django's Paths as objects feature, where \"safe\" strings are taken as is, and accessed only at render time.</p> <p>Because of that, the paths defined as \"safe\" strings are NEVER resolved, neither relative to component's directory, nor relative to <code>COMPONENTS.dirs</code>.</p> <p>\"Safe\" strings can be used to lazily resolve a path, or to customize the <code>&lt;script&gt;</code> or <code>&lt;link&gt;</code> tag for individual paths:</p> <pre><code>class LazyJsPath:\n    def __init__(self, static_path: str) -&gt; None:\n        self.static_path = static_path\n\n    def __html__(self):\n        full_path = static(self.static_path)\n        return format_html(\n            f'&lt;script type=\"module\" src=\"{full_path}\"&gt;&lt;/script&gt;'\n        )\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_name = \"calendar/template.html\"\n\n    def get_context_data(self, date):\n        return {\n            \"date\": date,\n        }\n\n    class Media:\n        css = \"calendar/style.css\"\n        js = [\n            # &lt;script&gt; tag constructed by Media class\n            \"calendar/script1.js\",\n            # Custom &lt;script&gt; tag\n            LazyJsPath(\"calendar/script2.js\"),\n        ]\n</code></pre>"},{"location":"#customize-how-paths-are-rendered-into-html-tags-with-media_class","title":"Customize how paths are rendered into HTML tags with <code>media_class</code>","text":"<p>Sometimes you may need to change how all CSS <code>&lt;link&gt;</code> or JS <code>&lt;script&gt;</code> tags are rendered for a given component. You can achieve this by providing your own subclass of Django's <code>Media</code> class to component's <code>media_class</code> attribute.</p> <p>Normally, the JS and CSS paths are passed to <code>Media</code> class, which decides how the paths are resolved and how the <code>&lt;link&gt;</code> and <code>&lt;script&gt;</code> tags are constructed.</p> <p>To change how the tags are constructed, you can override the <code>Media.render_js</code> and <code>Media.render_css</code> methods:</p> <pre><code>from django.forms.widgets import Media\nfrom django_components import Component, register\n\nclass MyMedia(Media):\n    # Same as original Media.render_js, except\n    # the `&lt;script&gt;` tag has also `type=\"module\"`\n    def render_js(self):\n        tags = []\n        for path in self._js:\n            if hasattr(path, \"__html__\"):\n                tag = path.__html__()\n            else:\n                tag = format_html(\n                    '&lt;script type=\"module\" src=\"{}\"&gt;&lt;/script&gt;',\n                    self.absolute_path(path)\n                )\n        return tags\n\n@register(\"calendar\")\nclass Calendar(Component):\n    template_name = \"calendar/template.html\"\n\n    class Media:\n        css = \"calendar/style.css\"\n        js = \"calendar/script.js\"\n\n    # Override the behavior of Media class\n    media_class = MyMedia\n</code></pre> <p>NOTE: The instance of the <code>Media</code> class (or it's subclass) is available under <code>Component.media</code> after the class creation (<code>__new__</code>).</p>"},{"location":"#rendering-jscss-dependencies","title":"Rendering JS/CSS dependencies","text":"<p>If: 1. Your components use JS and CSS, whether inlined via <code>Component.js/css</code> or via <code>Component.Media.js/css</code>, 2. And you use the <code>ComponentDependencyMiddleware</code> middleware</p> <p>Then, by default, the components' JS and CSS will be automatically inserted into the HTML: - CSS styles will be inserted at the end of the <code>&lt;head&gt;</code> - JS scripts will be inserted at the end of the <code>&lt;body&gt;</code></p> <p>If you want to place the dependencies elsewhere, you can override that with following Django template tags:</p> <ul> <li><code>{% component_js_dependencies %}</code> - Renders only JS</li> <li><code>{% component_css_dependencies %}</code> - Renders only CSS</li> </ul> <p>So if you have a component with JS and CSS:</p> <pre><code>from django_components import Component, types\n\nclass MyButton(Component):\n    template: types.django_html = \"\"\"\n        &lt;button class=\"my-button\"&gt;\n            Click me!\n        &lt;/button&gt;\n    \"\"\"\n    js: types.js = \"\"\"\n        for (const btnEl of document.querySelectorAll(\".my-button\")) {\n            btnEl.addEventListener(\"click\", () =&gt; {\n                console.log(\"BUTTON CLICKED!\");\n            });\n        }\n    \"\"\"\n    css: types.css \"\"\"\n        .my-button {\n            background: green;\n        }\n    \"\"\"\n\n    class Media:\n        js = [\"/extra/script.js\"]\n        css = [\"/extra/style.css\"]\n</code></pre> <p>Then the inlined JS and the scripts in <code>Media.js</code> will be rendered at the default place, or in <code>{% component_js_dependencies %}</code>.</p> <p>And the inlined CSS and the styles in <code>Media.css</code> will be rendered at the default place, or in <code>{% component_css_dependencies %}</code>.</p> <p>And if you don't specify <code>{% component_dependencies %}</code> tags, it is the equivalent of:</p> <pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;MyPage&lt;/title&gt;\n    ...\n    {% component_css_dependencies %}\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;main&gt;\n      ...\n    &lt;/main&gt;\n    {% component_js_dependencies %}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"#setting-up-componentdependencymiddleware","title":"Setting Up <code>ComponentDependencyMiddleware</code>","text":"<p><code>ComponentDependencyMiddleware</code> is a Django middleware designed to manage and inject CSS/JS dependencies for rendered components dynamically. It ensures that only the necessary stylesheets and scripts are loaded in your HTML responses, based on the components used in your Django templates.</p> <p>To set it up, add the middleware to your <code>MIDDLEWARE</code> in settings.py:</p> <pre><code>MIDDLEWARE = [\n    # ... other middleware classes ...\n    'django_components.middleware.ComponentDependencyMiddleware'\n    # ... other middleware classes ...\n]\n</code></pre>"},{"location":"#render_dependencies-and-deep-dive-into-rendering-js-css-without-the-middleware","title":"<code>render_dependencies</code> and deep-dive into rendering JS / CSS without the middleware","text":"<p>For most scenarios, using the <code>ComponentDependencyMiddleware</code> middleware will be just fine.</p> <p>However, this section is for you if you want to: - Render HTML that will NOT be sent as a server response - Insert pre-rendered HTML into another component - Render HTML fragments (partials)</p> <p>Every time there is an HTML string that has parts which were rendered using components, and any of those components has JS / CSS, then this HTML string MUST be processed with <code>render_dependencies</code>.</p> <p>It is actually <code>render_dependencies</code> that finds all used components in the HTML string, and inserts the component's JS and CSS into <code>{% component_dependencies %}</code> tags, or at the default locations.</p>"},{"location":"#render-js-css-without-the-middleware","title":"Render JS / CSS without the middleware","text":"<p>The <code>ComponentDependencyMiddleware</code> middleware just calls <code>render_dependencies</code>, passing in the HTML content. So if you rendered a template that contained <code>{% components %}</code> tags, instead of the middleware, you MUST pass the result through <code>render_dependencies</code>:</p> <pre><code>from django.template.base import Template\nfrom django.template.context import Context\nfrom django_component import render_dependencies\n\ntemplate = Template(\"\"\"\n    {% load component_tags %}\n    &lt;!doctype html&gt;\n    &lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;MyPage&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;main&gt;\n            {% component \"my_button\" %}\n                Click me!\n            {% endcomponent %}\n        &lt;/main&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n\"\"\")\n\nrendered = template.render(Context({}))\nrendered = render_dependencies(rendered)\n</code></pre> <p>Same applies if you render a template using Django's <code>django.shortcuts.render</code>:</p> <pre><code>from django.shortcuts import render\n\ndef my_view(request):\n    rendered = render(request, \"pages/home.html\")\n    rendered = render_dependencies(rendered)\n    return rendered\n</code></pre> <p>Alternatively, when you render HTML with <code>Component.render()</code> or <code>Component.render_to_response()</code>, these automatically call <code>render_dependencies()</code> for you, so you don't have to:</p> <pre><code>from django_components import Component\n\nclass MyButton(Component):\n    ...\n\n# No need to call `render_dependencies()`\nrendered = MyButton.render()\n</code></pre>"},{"location":"#inserting-pre-rendered-html-into-another-component","title":"Inserting pre-rendered HTML into another component","text":"<p>In previous section we've shown that <code>render_dependencies()</code> does NOT need to be called when you render a component via <code>Component.render()</code>.</p> <p>API of django-components makes it possible to compose components in a \"React-like\" way, where we pre-render a piece of HTML and then insert it into a larger structure.</p> <p>To do this, you must add <code>render_dependencies=False</code> to the nested components:</p> <pre><code>card_actions = CardActions.render(\n    kwargs={\"editable\": editable},\n    render_dependencies=False,\n)\n\ncard = Card.render(\n    slots={\"actions\": card_actions},\n    render_dependencies=False,\n)\n\npage = MyPage.render(\n    slots={\"card\": card},\n)\n</code></pre> <p>Why is <code>render_dependencies=False</code> required?</p> <p>As mentioned earlier, each time we call <code>Component.render()</code>, we also call <code>render_dependencies()</code>.</p> <p>However, there is a problem here - When we call <code>render_dependencies()</code> inside <code>CardActions.render()</code>, we extract the info on components' JS and CSS from the HTML. But the template of <code>CardActions</code> contains no <code>{% component_depedencies %}</code> tags, and nor <code>&lt;head&gt;</code> nor <code>&lt;body&gt;</code> HTML tags. So the component's JS and CSS will NOT be inserted, and will be lost.</p> <p>To work around this, you must set <code>render_dependencies=False</code> when rendering pieces of HTML with <code>Component.render()</code> and inserting them into larger structures.</p>"},{"location":"#available-settings","title":"Available settings","text":"<p>All library settings are handled from a global <code>COMPONENTS</code> variable that is read from <code>settings.py</code>. By default you don't need it set, there are resonable defaults.</p> <p>Here's overview of all available settings and their defaults:</p> <pre><code>COMPONENTS = {\n    \"autodiscover\": True,\n    \"context_behavior\": \"django\",  # \"django\" | \"isolated\"\n    \"dirs\": [BASE_DIR / \"components\"],  # Root-level \"components\" dirs, e.g. `/path/to/proj/components/`\n    \"app_dirs\": [\"components\"],  # App-level \"components\" dirs, e.g. `[app]/components/`\n    \"dynamic_component_name\": \"dynamic\",\n    \"libraries\": [],  # [\"mysite.components.forms\", ...]\n    \"multiline_tags\": True,\n    \"reload_on_template_change\": False,\n    \"static_files_allowed\": [\n        \".css\",\n        \".js\",\n        # Images\n        \".apng\", \".png\", \".avif\", \".gif\", \".jpg\",\n        \".jpeg\",  \".jfif\", \".pjpeg\", \".pjp\", \".svg\",\n        \".webp\", \".bmp\", \".ico\", \".cur\", \".tif\", \".tiff\",\n        # Fonts\n        \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n    \"static_files_forbidden\": [\n        \".html\", \".django\", \".dj\", \".tpl\",\n        # Python files\n        \".py\", \".pyc\",\n    ],\n    \"tag_formatter\": \"django_components.component_formatter\",\n    \"template_cache_size\": 128,\n}\n</code></pre>"},{"location":"#libraries-load-component-modules","title":"<code>libraries</code> - Load component modules","text":"<p>Configure the locations where components are loaded. To do this, add a <code>COMPONENTS</code> variable to you <code>settings.py</code> with a list of python paths to load. This allows you to build a structure of components that are independent from your apps.</p> <pre><code>COMPONENTS = {\n    \"libraries\": [\n        \"mysite.components.forms\",\n        \"mysite.components.buttons\",\n        \"mysite.components.cards\",\n    ],\n}\n</code></pre> <p>Where <code>mysite/components/forms.py</code> may look like this:</p> <pre><code>@register(\"form_simple\")\nclass FormSimple(Component):\n    template = \"\"\"\n        &lt;form&gt;\n            ...\n        &lt;/form&gt;\n    \"\"\"\n\n@register(\"form_other\")\nclass FormOther(Component):\n    template = \"\"\"\n        &lt;form&gt;\n            ...\n        &lt;/form&gt;\n    \"\"\"\n</code></pre> <p>In the rare cases when you need to manually trigger the import of libraries, you can use the <code>import_libraries</code> function:</p> <pre><code>from django_components import import_libraries\n\nimport_libraries()\n</code></pre>"},{"location":"#autodiscover-toggle-autodiscovery","title":"<code>autodiscover</code> - Toggle autodiscovery","text":"<p>If you specify all the component locations with the setting above and have a lot of apps, you can (very) slightly speed things up by disabling autodiscovery.</p> <pre><code>COMPONENTS = {\n    \"autodiscover\": False,\n}\n</code></pre>"},{"location":"#dirs","title":"<code>dirs</code>","text":"<p>Specify the directories that contain your components.</p> <p>Directories must be full paths, same as with STATICFILES_DIRS.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as a separate file.</p> <pre><code>COMPONENTS = {\n    \"dirs\": [BASE_DIR / \"components\"],\n}\n</code></pre>"},{"location":"#app_dirs","title":"<code>app_dirs</code>","text":"<p>Specify the app-level directories that contain your components.</p> <p>Directories must be relative to app, e.g.:</p> <pre><code>COMPONENTS = {\n    \"app_dirs\": [\"my_comps\"],  # To search for [app]/my_comps\n}\n</code></pre> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as a separate file.</p> <p>Each app will be searched for these directories.</p> <p>Set to empty list to disable app-level components:</p> <pre><code>COMPONENTS = {\n    \"app_dirs\": [],\n}\n</code></pre>"},{"location":"#dynamic_component_name","title":"<code>dynamic_component_name</code>","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, use this setting to change the name used for the dynamic components.</p> <pre><code>COMPONENTS = {\n    \"dynamic_component_name\": \"new_dynamic\",\n}\n</code></pre>"},{"location":"#multiline_tags-enabledisable-multiline-support","title":"<code>multiline_tags</code> - Enable/Disable multiline support","text":"<p>If <code>True</code>, template tags can span multiple lines. Default: <code>True</code></p> <pre><code>COMPONENTS = {\n    \"multiline_tags\": True,\n}\n</code></pre>"},{"location":"#static_files_allowed","title":"<code>static_files_allowed</code>","text":"<p>A list of regex patterns (as strings) that define which files within <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code> are treated as static files.</p> <p>If a file is matched against any of the patterns, it's considered a static file. Such files are collected when running <code>collectstatic</code>, and can be accessed under the static file endpoint.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, JS, CSS, and common image and font file formats are considered static files:</p> <pre><code>COMPONENTS = {\n    \"static_files_allowed\": [\n            \"css\",\n            \"js\",\n            # Images\n            \".apng\", \".png\",\n            \".avif\",\n            \".gif\",\n            \".jpg\", \".jpeg\", \".jfif\", \".pjpeg\", \".pjp\",  # JPEG\n            \".svg\",\n            \".webp\", \".bmp\",\n            \".ico\", \".cur\",  # ICO\n            \".tif\", \".tiff\",\n            # Fonts\n            \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n}\n</code></pre>"},{"location":"#static_files_forbidden","title":"<code>static_files_forbidden</code>","text":"<p>A list of suffixes that define which files within <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code> will NEVER be treated as static files.</p> <p>If a file is matched against any of the patterns, it will never be considered a static file, even if the file matches a pattern in <code>COMPONENTS.static_files_allowed</code>.</p> <p>Use this setting together with <code>COMPONENTS.static_files_allowed</code> for a fine control over what files will be exposed.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, any HTML and Python are considered NOT static files:</p> <pre><code>COMPONENTS = {\n    \"static_files_forbidden\": [\n        \".html\", \".django\", \".dj\", \".tpl\", \".py\", \".pyc\",\n    ],\n}\n</code></pre>"},{"location":"#template_cache_size-tune-the-template-cache","title":"<code>template_cache_size</code> - Tune the template cache","text":"<p>Each time a template is rendered it is cached to a global in-memory cache (using Python's <code>lru_cache</code> decorator). This speeds up the next render of the component. As the same component is often used many times on the same page, these savings add up.</p> <p>By default the cache holds 128 component templates in memory, which should be enough for most sites. But if you have a lot of components, or if you are using the <code>template</code> method of a component to render lots of dynamic templates, you can increase this number. To remove the cache limit altogether and cache everything, set template_cache_size to <code>None</code>.</p> <pre><code>COMPONENTS = {\n    \"template_cache_size\": 256,\n}\n</code></pre> <p>If you want add templates to the cache yourself, you can use <code>cached_template()</code>:</p> <pre><code>from django_components import cached_template\n\ncached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ncached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre>"},{"location":"#context_behavior-make-components-isolated-or-not","title":"<code>context_behavior</code> - Make components isolated (or not)","text":"<p>NOTE: <code>context_behavior</code> and <code>slot_context_behavior</code> options were merged in v0.70.</p> <p>If you are migrating from BEFORE v0.67, set <code>context_behavior</code> to <code>\"django\"</code>. From v0.67 to v0.78 (incl) the default value was <code>\"isolated\"</code>.</p> <p>For v0.79 and later, the default is again <code>\"django\"</code>. See the rationale for change here.</p> <p>You can configure what variables are available inside the <code>{% fill %}</code> tags. See Component context and scope.</p> <p>This has two modes:</p> <ul> <li><code>\"django\"</code> - Default - The default Django template behavior.</li> </ul> <p>Inside the <code>{% fill %}</code> tag, the context variables you can access are a union of:</p> <ul> <li>All the variables that were OUTSIDE the fill tag, including any loops or with tag</li> <li> <p>Data returned from <code>get_context_data()</code> of the component that wraps the fill tag.</p> </li> <li> <p><code>\"isolated\"</code> - Similar behavior to Vue or React, this is useful if you want to make sure that components don't accidentally access variables defined outside of the component.</p> </li> </ul> <p>Inside the <code>{% fill %}</code> tag, you can ONLY access variables from 2 places:</p> <ul> <li><code>get_context_data()</code> of the component which defined the template (AKA the \"root\" component)</li> <li>Any loops (<code>{% for ... %}</code>) that the <code>{% fill %}</code> tag is part of.</li> </ul> <pre><code>COMPONENTS = {\n    \"context_behavior\": \"isolated\",\n}\n</code></pre>"},{"location":"#example-django","title":"Example \"django\"","text":"<p>Given this template:</p> <pre><code>class RootComp(Component):\n    template = \"\"\"\n        {% with cheese=\"feta\" %}\n            {% component 'my_comp' %}\n                {{ my_var }}  # my_var\n                {{ cheese }}  # cheese\n            {% endcomponent %}\n        {% endwith %}\n    \"\"\"\n    def get_context_data(self):\n        return { \"my_var\": 123 }\n</code></pre> <p>Then if <code>get_context_data()</code> of the component <code>\"my_comp\"</code> returns following data:</p> <pre><code>{ \"my_var\": 456 }\n</code></pre> <p>Then the template will be rendered as:</p> <pre><code>456   # my_var\nfeta  # cheese\n</code></pre> <p>Because <code>\"my_comp\"</code> overshadows the variable <code>\"my_var\"</code>, so <code>{{ my_var }}</code> equals <code>456</code>.</p> <p>And variable <code>\"cheese\"</code> equals <code>feta</code>, because the fill CAN access all the data defined in the outer layers, like the <code>{% with %}</code> tag.</p>"},{"location":"#example-isolated","title":"Example \"isolated\"","text":"<p>Given this template:</p> <pre><code>class RootComp(Component):\n    template = \"\"\"\n        {% with cheese=\"feta\" %}\n            {% component 'my_comp' %}\n                {{ my_var }}  # my_var\n                {{ cheese }}  # cheese\n            {% endcomponent %}\n        {% endwith %}\n    \"\"\"\n    def get_context_data(self):\n        return { \"my_var\": 123 }\n</code></pre> <p>Then if <code>get_context_data()</code> of the component <code>\"my_comp\"</code> returns following data:</p> <pre><code>{ \"my_var\": 456 }\n</code></pre> <p>Then the template will be rendered as:</p> <pre><code>123   # my_var\n      # cheese\n</code></pre> <p>Because variables <code>\"my_var\"</code> and <code>\"cheese\"</code> are searched only inside <code>RootComponent.get_context_data()</code>. But since <code>\"cheese\"</code> is not defined there, it's empty.</p> <p>Notice that the variables defined with the <code>{% with %}</code> tag are ignored inside the <code>{% fill %}</code> tag with the <code>\"isolated\"</code> mode.</p>"},{"location":"#reload_on_template_change-reload-dev-server-on-component-file-changes","title":"<code>reload_on_template_change</code> - Reload dev server on component file changes","text":"<p>If <code>True</code>, configures Django to reload on component files. See Reload dev server on component file changes.</p> <p>NOTE: This setting should be enabled only for the dev environment!</p>"},{"location":"#tag_formatter-change-how-components-are-used-in-templates","title":"<code>tag_formatter</code> - Change how components are used in templates","text":"<p>Sets the <code>TagFormatter</code> instance. See the section Customizing component tags with TagFormatter.</p> <p>Can be set either as direct reference, or as an import string;</p> <pre><code>COMPONENTS = {\n    \"tag_formatter\": \"django_components.component_formatter\"\n}\n</code></pre> <p>Or</p> <pre><code>from django_components import component_formatter\n\nCOMPONENTS = {\n    \"tag_formatter\": component_formatter\n}\n</code></pre>"},{"location":"#running-with-development-server","title":"Running with development server","text":""},{"location":"#reload-dev-server-on-component-file-changes","title":"Reload dev server on component file changes","text":"<p>This is relevant if you are using the project structure as shown in our examples, where HTML, JS, CSS and Python are separate and nested in a directory.</p> <p>In this case you may notice that when you are running a development server, the server sometimes does not reload when you change comoponent files.</p> <p>From relevant StackOverflow thread:</p> <p>TL;DR is that the server won't reload if it thinks the changed file is in a templates directory, or in a nested sub directory of a templates directory. This is by design.</p> <p>To make the dev server reload on all component files, set <code>reload_on_template_change</code> to <code>True</code>. This configures Django to watch for component files too.</p> <p>NOTE: This setting should be enabled only for the dev environment!</p>"},{"location":"#logging-and-debugging","title":"Logging and debugging","text":"<p>Django components supports logging with Django. This can help with troubleshooting.</p> <p>To configure logging for Django components, set the <code>django_components</code> logger in <code>LOGGING</code> in <code>settings.py</code> (below).</p> <p>Also see the <code>settings.py</code> file in sampleproject for a real-life example.</p> <pre><code>import logging\nimport sys\n\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    \"handlers\": {\n        \"console\": {\n            'class': 'logging.StreamHandler',\n            'stream': sys.stdout,\n        },\n    },\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": logging.DEBUG,\n            \"handlers\": [\"console\"],\n        },\n    },\n}\n</code></pre>"},{"location":"#management-command","title":"Management Command","text":"<p>You can use the built-in management command <code>startcomponent</code> to create a django component. The command accepts the following arguments and options:</p> <ul> <li> <p><code>name</code>: The name of the component to create. This is a required argument.</p> </li> <li> <p><code>--path</code>: The path to the components directory. This is an optional argument. If not provided, the command will use the <code>BASE_DIR</code> setting from your Django settings.</p> </li> <li> <p><code>--js</code>: The name of the JavaScript file. This is an optional argument. The default value is <code>script.js</code>.</p> </li> <li> <p><code>--css</code>: The name of the CSS file. This is an optional argument. The default value is <code>style.css</code>.</p> </li> <li> <p><code>--template</code>: The name of the template file. This is an optional argument. The default value is <code>template.html</code>.</p> </li> <li> <p><code>--force</code>: This option allows you to overwrite existing files if they exist. This is an optional argument.</p> </li> <li> <p><code>--verbose</code>: This option allows the command to print additional information during component creation. This is an optional argument.</p> </li> <li> <p><code>--dry-run</code>: This option allows you to simulate component creation without actually creating any files. This is an optional argument. The default value is <code>False</code>.</p> </li> </ul>"},{"location":"#management-command-usage","title":"Management Command Usage","text":"<p>To use the command, run the following command in your terminal:</p> <pre><code>python manage.py startcomponent &lt;name&gt; --path &lt;path&gt; --js &lt;js_filename&gt; --css &lt;css_filename&gt; --template &lt;template_filename&gt; --force --verbose --dry-run\n</code></pre> <p>Replace <code>&lt;name&gt;</code>, <code>&lt;path&gt;</code>, <code>&lt;js_filename&gt;</code>, <code>&lt;css_filename&gt;</code>, and <code>&lt;template_filename&gt;</code> with your desired values.</p>"},{"location":"#management-command-examples","title":"Management Command Examples","text":"<p>Here are some examples of how you can use the command:</p>"},{"location":"#creating-a-component-with-default-settings","title":"Creating a Component with Default Settings","text":"<p>To create a component with the default settings, you only need to provide the name of the component:</p> <pre><code>python manage.py startcomponent my_component\n</code></pre> <p>This will create a new component named <code>my_component</code> in the <code>components</code> directory of your Django project. The JavaScript, CSS, and template files will be named <code>script.js</code>, <code>style.css</code>, and <code>template.html</code>, respectively.</p>"},{"location":"#creating-a-component-with-custom-settings","title":"Creating a Component with Custom Settings","text":"<p>You can also create a component with custom settings by providing additional arguments:</p> <pre><code>python manage.py startcomponent new_component --path my_components --js my_script.js --css my_style.css --template my_template.html\n</code></pre> <p>This will create a new component named <code>new_component</code> in the <code>my_components</code> directory. The JavaScript, CSS, and template files will be named <code>my_script.js</code>, <code>my_style.css</code>, and <code>my_template.html</code>, respectively.</p>"},{"location":"#overwriting-an-existing-component","title":"Overwriting an Existing Component","text":"<p>If you want to overwrite an existing component, you can use the <code>--force</code> option:</p> <pre><code>python manage.py startcomponent my_component --force\n</code></pre> <p>This will overwrite the existing <code>my_component</code> if it exists.</p>"},{"location":"#simulating-component-creation","title":"Simulating Component Creation","text":"<p>If you want to simulate the creation of a component without actually creating any files, you can use the <code>--dry-run</code> option:</p> <pre><code>python manage.py startcomponent my_component --dry-run\n</code></pre> <p>This will simulate the creation of <code>my_component</code> without creating any files.</p>"},{"location":"#writing-and-sharing-component-libraries","title":"Writing and sharing component libraries","text":"<p>You can publish and share your components for others to use. Here are the steps to do so:</p>"},{"location":"#writing-component-libraries","title":"Writing component libraries","text":"<ol> <li> <p>Create a Django project with the following structure:</p> <pre><code>project/\n  |--  myapp/\n    |--  __init__.py\n    |--  apps.py\n    |--  templates/\n      |--  table/\n        |--  table.py\n        |--  table.js\n        |--  table.css\n        |--  table.html\n    |--  menu.py   &lt;--- single-file component\n  |--  templatetags/\n    |--  __init__.py\n    |--  mytags.py\n</code></pre> </li> <li> <p>Create custom <code>Library</code> and <code>ComponentRegistry</code> instances in <code>mytags.py</code></p> <p>This will be the entrypoint for using the components inside Django templates.</p> <p>Remember that Django requires the <code>Library</code> instance to be accessible under the <code>register</code> variable (See Django docs):</p> <pre><code>from django.template import Library\nfrom django_components import ComponentRegistry, RegistrySettings\n\nregister = library = django.template.Library()\ncomp_registry = ComponentRegistry(\n    library=library,\n    settings=RegistrySettings(\n        context_behavior=\"isolated\",\n        tag_formatter=\"django_components.component_formatter\",\n    ),\n)\n</code></pre> <p>As you can see above, this is also the place where we configure how our components should behave, using the <code>settings</code> argument. If omitted, default settings are used.</p> <p>For library authors, we recommend setting <code>context_behavior</code> to <code>\"isolated\"</code>, so that the state cannot leak into the components, and so the components' behavior is configured solely through the inputs. This means that the components will be more predictable and easier to debug.</p> <p>Next, you can decide how will others use your components by settingt the <code>tag_formatter</code> options.</p> <p>If omitted or set to <code>\"django_components.component_formatter\"</code>, your components will be used like this:</p> <pre><code>{% component \"table\" items=items headers=headers %}\n{% endcomponent %}\n</code></pre> <p>Or you can use <code>\"django_components.component_shorthand_formatter\"</code> to use components like so:</p> <pre><code>{% table items=items headers=headers %}\n{% endtable %}\n</code></pre> <p>Or you can define a custom TagFormatter.</p> <p>Either way, these settings will be scoped only to your components. So, in the user code, there may be components side-by-side that use different formatters:</p> <pre><code>{% load mytags %}\n\n{# Component from your library \"mytags\", using the \"shorthand\" formatter #}\n{% table items=items headers=header %}\n{% endtable %}\n\n{# User-created components using the default settings #}\n{% component \"my_comp\" title=\"Abc...\" %}\n{% endcomponent %}\n</code></pre> </li> <li> <p>Write your components and register them with your instance of <code>ComponentRegistry</code></p> <p>There's one difference when you are writing components that are to be shared, and that's that the components must be explicitly registered with your instance of <code>ComponentRegistry</code> from the previous step.</p> <p>For better user experience, you can also define the types for the args, kwargs, slots and data.</p> <p>It's also a good idea to have a common prefix for your components, so they can be easily distinguished from users' components. In the example below, we use the prefix <code>my_</code> / <code>My</code>.</p> <pre><code>from typing import Dict, NotRequired, Optional, Tuple, TypedDict\n\nfrom django_components import Component, SlotFunc, register, types\n\nfrom myapp.templatetags.mytags import comp_registry\n\n# Define the types\nclass EmptyDict(TypedDict):\n    pass\n\ntype MyMenuArgs = Tuple[int, str]\n\nclass MyMenuSlots(TypedDict):\n    default: NotRequired[Optional[SlotFunc[EmptyDict]]]\n\nclass MyMenuProps(TypedDict):\n    vertical: NotRequired[bool]\n    klass: NotRequired[str]\n    style: NotRequired[str]\n\n# Define the component\n# NOTE: Don't forget to set the `registry`!\n@register(\"my_menu\", registry=comp_registry)\nclass MyMenu(Component[MyMenuArgs, MyMenuProps, MyMenuSlots, Any, Any, Any]):\n    def get_context_data(\n        self,\n        *args,\n        attrs: Optional[Dict] = None,\n    ):\n        return {\n            \"attrs\": attrs,\n        }\n\n    template: types.django_html = \"\"\"\n        {# Load django_components template tags #}\n        {% load component_tags %}\n\n        &lt;div {% html_attrs attrs class=\"my-menu\" %}&gt;\n            &lt;div class=\"my-menu__content\"&gt;\n                {% slot \"default\" default / %}\n            &lt;/div&gt;\n        &lt;/div&gt;\n    \"\"\"\n</code></pre> </li> <li> <p>Import the components in <code>apps.py</code></p> <p>Normally, users rely on autodiscovery and <code>COMPONENTS.dirs</code> to load the component files.</p> <p>Since you, as the library author, are not in control of the file system, it is recommended to load the components manually.</p> <p>We recommend doing this in the <code>AppConfig.ready()</code> hook of your <code>apps.py</code>:</p> <pre><code>from django.apps import AppConfig\n\nclass MyAppConfig(AppConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"myapp\"\n\n    # This is the code that gets run when user adds myapp\n    # to Django's INSTALLED_APPS\n    def ready(self) -&gt; None:\n        # Import the components that you want to make available\n        # inside the templates.\n        from myapp.templates import (\n            menu,\n            table,\n        )\n</code></pre> <p>Note that you can also include any other startup logic within <code>AppConfig.ready()</code>.</p> </li> </ol> <p>And that's it! The next step is to publish it.</p>"},{"location":"#publishing-component-libraries","title":"Publishing component libraries","text":"<p>Once you are ready to share your library, you need to build a distribution and then publish it to PyPI.</p> <p>django_components uses the <code>build</code> utility to build a distribution:</p> <pre><code>python -m build --sdist --wheel --outdir dist/ .\n</code></pre> <p>And to publish to PyPI, you can use <code>twine</code> (See Python user guide)</p> <pre><code>twine upload --repository pypi dist/* -u __token__ -p &lt;PyPI_TOKEN&gt;\n</code></pre> <p>Notes on publishing: - The user of the package NEEDS to have installed and configured <code>django_components</code>. - If you use components where the HTML / CSS / JS files are separate, you may need to define <code>MANIFEST.in</code> to include those files with the distribution (see user guide).</p>"},{"location":"#installing-and-using-component-libraries","title":"Installing and using component libraries","text":"<p>After the package has been published, all that remains is to install it in other django projects:</p> <ol> <li> <p>Install the package:</p> <pre><code>pip install myapp\n</code></pre> </li> <li> <p>Add the package to <code>INSTALLED_APPS</code></p> <pre><code>INSTALLED_APPS = [\n    ...\n    \"myapp\",\n]\n</code></pre> </li> <li> <p>Optionally add the template tags to the <code>builtins</code>, so you don't have to call <code>{% load mytags %}</code> in every template:</p> <pre><code>TEMPLATES = [\n    {\n        ...,\n        'OPTIONS': {\n            'context_processors': [\n                ...\n            ],\n            'builtins': [\n                'myapp.templatetags.mytags',\n            ]\n        },\n    },\n]\n</code></pre> </li> <li> <p>And, at last, you can use the components in your own project!</p> <pre><code>{% my_menu title=\"Abc...\" %}\n    Hello World!\n{% endmy_menu %}\n</code></pre> </li> </ol>"},{"location":"#community-examples","title":"Community examples","text":"<p>One of our goals with <code>django-components</code> is to make it easy to share components between projects. If you have a set of components that you think would be useful to others, please open a pull request to add them to the list below.</p> <ul> <li>django-htmx-components: A set of components for use with htmx. Try out the live demo.</li> </ul>"},{"location":"#contributing-and-development","title":"Contributing and development","text":""},{"location":"#install-locally-and-run-the-tests","title":"Install locally and run the tests","text":"<p>Start by forking the project by clicking the Fork button up in the right corner in the GitHub . This makes a copy of the repository in your own name. Now you can clone this repository locally and start adding features:</p> <pre><code>git clone https://github.com/&lt;your GitHub username&gt;/django-components.git\n</code></pre> <p>To quickly run the tests install the local dependencies by running:</p> <pre><code>pip install -r requirements-dev.txt\n</code></pre> <p>Now you can run the tests to make sure everything works as expected:</p> <pre><code>pytest\n</code></pre> <p>The library is also tested across many versions of Python and Django. To run tests that way:</p> <pre><code>pyenv install -s 3.8\npyenv install -s 3.9\npyenv install -s 3.10\npyenv install -s 3.11\npyenv install -s 3.12\npyenv local 3.8 3.9 3.10 3.11 3.12\ntox -p\n</code></pre>"},{"location":"#running-playwright-tests","title":"Running Playwright tests","text":"<p>We use Playwright for end-to-end tests. You will therefore need to install Playwright to be able to run these tests.</p> <p>Luckily, Playwright makes it very easy:</p> <pre><code>pip install -r requirements-dev.txt\nplaywright install chromium --with-deps\n</code></pre> <p>After Playwright is ready, simply run the tests with <code>tox</code>: <pre><code>tox\n</code></pre></p>"},{"location":"#developing-against-live-django-app","title":"Developing against live Django app","text":"<p>How do you check that your changes to django-components project will work in an actual Django project?</p> <p>Use the sampleproject demo project to validate the changes:</p> <ol> <li>Navigate to sampleproject directory:</li> </ol> <pre><code>cd sampleproject\n</code></pre> <ol> <li>Install dependencies from the requirements.txt file:</li> </ol> <pre><code>pip install -r requirements.txt\n</code></pre> <ol> <li>Link to your local version of django-components:</li> </ol> <pre><code>pip install -e ..\n</code></pre> <p>NOTE: The path (in this case <code>..</code>) must point to the directory that has the <code>setup.py</code> file.</p> <ol> <li>Start Django server    <pre><code>python manage.py runserver\n</code></pre></li> </ol> <p>Once the server is up, it should be available at http://127.0.0.1:8000.</p> <p>To display individual components, add them to the <code>urls.py</code>, like in the case of http://127.0.0.1:8000/greeting</p>"},{"location":"#building-js-code","title":"Building JS code","text":"<p>django_components uses a bit of JS code to: - Manage the loading of JS and CSS files used by the components - Allow to pass data from Python to JS</p> <p>When you make changes to this JS code, you also need to compile it:</p> <ol> <li>Make sure you are inside <code>src/django_components_js</code>:</li> </ol> <pre><code>cd src/django_components_js\n</code></pre> <ol> <li>Install the JS dependencies</li> </ol> <pre><code>npm install\n</code></pre> <ol> <li>Compile the JS/TS code:</li> </ol> <pre><code>python build.py\n</code></pre> <p>The script will combine all JS/TS code into a single <code>.js</code> file, minify it, and copy it to <code>django_components/static/django_components/django_components.min.js</code>.</p>"},{"location":"#packaging-and-publishing","title":"Packaging and publishing","text":"<p>To package the library into a distribution that can be published to PyPI, run:</p> <pre><code># Install pypa/build\npython -m pip install build --user\n# Build a binary wheel and a source tarball\npython -m build --sdist --wheel --outdir dist/ .\n</code></pre> <p>To publish the package to PyPI, use <code>twine</code> (See Python user guide): <pre><code>twine upload --repository pypi dist/* -u __token__ -p &lt;PyPI_TOKEN&gt;\n</code></pre></p> <p>See the full workflow here.</p>"},{"location":"#development-guides","title":"Development guides","text":"<p>Deep dive into how django_components' features are implemented.</p> <ul> <li>Slot rendering</li> <li>Slots and blocks</li> <li>JS and CSS dependency management</li> </ul>"},{"location":"CHANGELOG/","title":"Release notes","text":""},{"location":"CHANGELOG/#v0114","title":"v0.114","text":""},{"location":"CHANGELOG/#fix","title":"Fix","text":"<ul> <li>Prevent rendering Slot tags during fill discovery stage to fix a case when a component inside a slot   fill tried to access provided data too early.</li> </ul>"},{"location":"CHANGELOG/#v0113","title":"v0.113","text":""},{"location":"CHANGELOG/#fix_1","title":"Fix","text":"<ul> <li>Ensure consistent order of scripts in <code>Component.Media.js</code></li> </ul>"},{"location":"CHANGELOG/#v0112","title":"v0.112","text":""},{"location":"CHANGELOG/#fix_2","title":"Fix","text":"<ul> <li>Allow components to accept default fill even if no default slot was encountered during rendering</li> </ul>"},{"location":"CHANGELOG/#v0111","title":"v0.111","text":""},{"location":"CHANGELOG/#fix_3","title":"Fix","text":"<ul> <li>Prevent rendering Component tags during fill discovery stage to fix a case when a component inside the default slot   tried to access provided data too early.</li> </ul>"},{"location":"CHANGELOG/#v0110","title":"\ud83d\udea8\ud83d\udce2 v0.110","text":""},{"location":"CHANGELOG/#general","title":"General","text":""},{"location":"CHANGELOG/#breaking-changes","title":"\ud83d\udea8\ud83d\udce2 BREAKING CHANGES","text":"<ul> <li> <p>Installation changes:</p> <ul> <li>If your components include JS or CSS, you now must use the middleware and add django-components' URLs to your <code>urlpatterns</code> (See \"Adding support for JS and CSS\")</li> </ul> </li> <li> <p>Component typing signature changed from</p> <pre><code>Component[Args, Kwargs, Data, Slots]\n</code></pre> <p>to</p> <pre><code>Component[Args, Kwargs, Slots, Data, JsData, CssData]\n</code></pre> </li> <li> <p>If you rendered a component A with <code>Component.render()</code> and then inserted that into another component B, now you must pass <code>render_dependencies=False</code> to component A:</p> <pre><code>prerendered_a = CompA.render(\n    args=[...],\n    kwargs={...},\n    render_dependencies=False,\n)\n\nhtml = CompB.render(\n    kwargs={\n        content=prerendered_a,\n    },\n)\n</code></pre> </li> </ul>"},{"location":"CHANGELOG/#feat","title":"Feat","text":"<ul> <li>Intellisense and mypy validation for settings:</li> </ul> <p>Instead of defining the <code>COMPONENTS</code> settings as a plain dict, you can use <code>ComponentsSettings</code>:</p> <pre><code># settings.py\nfrom django_components import ComponentsSettings\n\nCOMPONENTS = ComponentsSettings(\n    autodiscover=True,\n    ...\n)\n</code></pre> <ul> <li>Use <code>get_component_dirs()</code> and <code>get_component_files()</code> to get the same list of dirs / files that would be imported by <code>autodiscover()</code>, but without actually importing them.</li> </ul>"},{"location":"CHANGELOG/#refactor","title":"Refactor","text":"<ul> <li> <p>For advanced use cases, use can omit the middleware and instead manage component JS and CSS dependencies yourself with <code>render_dependencies</code></p> </li> <li> <p>The <code>ComponentRegistry</code> settings <code>RegistrySettings</code>   were lowercased to align with the global settings:</p> </li> <li><code>RegistrySettings.CONTEXT_BEHAVIOR</code> -&gt; <code>RegistrySettings.context_behavior</code></li> <li><code>RegistrySettings.TAG_FORMATTER</code> -&gt; <code>RegistrySettings.tag_formatter</code></li> </ul> <p>The old uppercase settings <code>CONTEXT_BEHAVIOR</code> and <code>TAG_FORMATTER</code> are deprecated and will be removed in v1.</p> <ul> <li> <p>The setting <code>reload_on_template_change</code> was renamed to   <code>reload_on_file_change</code>.   And now it properly triggers server reload when any file in the component dirs change. The old name <code>reload_on_template_change</code>   is deprecated and will be removed in v1.</p> </li> <li> <p>The setting <code>forbidden_static_files</code> was renamed to   <code>static_files_forbidden</code>   to align with <code>static_files_allowed</code>   The old name <code>forbidden_static_files</code> is deprecated and will be removed in v1.</p> </li> </ul>"},{"location":"CHANGELOG/#tags","title":"Tags","text":""},{"location":"CHANGELOG/#breaking-changes_1","title":"\ud83d\udea8\ud83d\udce2 BREAKING CHANGES","text":"<ul> <li> <p><code>{% component_dependencies %}</code> tag was removed. Instead, use <code>{% component_js_dependencies %}</code> and <code>{% component_css_dependencies %}</code></p> <ul> <li> <p>The combined tag was removed to encourage the best practice of putting JS scripts at the end of <code>&lt;body&gt;</code>, and CSS styles inside <code>&lt;head&gt;</code>.</p> <p>On the other hand, co-locating JS script and CSS styles can lead to a flash of unstyled content, as either JS scripts will block the rendering, or CSS will load too late.</p> </li> </ul> </li> <li> <p>The undocumented keyword arg <code>preload</code> of <code>{% component_js_dependencies %}</code> and <code>{% component_css_dependencies %}</code> tags was removed.   This will be replaced with HTML fragment support.</p> </li> </ul>"},{"location":"CHANGELOG/#fix_4","title":"Fix","text":"<ul> <li>Allow using forward slash (<code>/</code>) when defining custom TagFormatter,   e.g. <code>{% MyComp %}..{% /MyComp %}</code>.</li> </ul>"},{"location":"CHANGELOG/#refactor_1","title":"Refactor","text":"<ul> <li><code>{% component_dependencies %}</code> tags are now OPTIONAL - If your components use JS and CSS, but you don't use <code>{% component_dependencies %}</code> tags, the JS and CSS will now be, by default, inserted at the end of <code>&lt;body&gt;</code> and at the end of <code>&lt;head&gt;</code> respectively.</li> </ul>"},{"location":"CHANGELOG/#slots","title":"Slots","text":""},{"location":"CHANGELOG/#feat_1","title":"Feat","text":"<ul> <li>Fills can now be defined within loops (<code>{% for %}</code>) or other tags (like <code>{% with %}</code>),   or even other templates using <code>{% include %}</code>.</li> </ul> <p>Following is now possible</p> <pre><code>{% component \"table\" %}\n  {% for slot_name in slots %}\n    {% fill name=slot_name %}\n    {% endfill %}\n  {% endfor %}\n{% endcomponent %}\n</code></pre> <ul> <li>If you need to access the data or the default content of a default fill, you can   set the <code>name</code> kwarg to <code>\"default\"</code>.</li> </ul> <p>Previously, a default fill would be defined simply by omitting the <code>{% fill %}</code> tags:</p> <pre><code>{% component \"child\" %}\n  Hello world\n{% endcomponent %}\n</code></pre> <p>But in that case you could not access the slot data or the default content, like it's possible   for named fills:</p> <pre><code>{% component \"child\" %}\n  {% fill name=\"header\" data=\"data\" %}\n    Hello {{ data.user.name }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <p>Now, you can specify default tag by using <code>name=\"default\"</code>:</p> <pre><code>{% component \"child\" %}\n  {% fill name=\"default\" data=\"data\" %}\n    Hello {{ data.user.name }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre> <ul> <li>When inside <code>get_context_data()</code> or other component methods, the default fill   can now be accessed as <code>Component.input.slots[\"default\"]</code>, e.g.:</li> </ul> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        default_slot = self.input.slots[\"default\"]\n        ...\n</code></pre> <ul> <li>You can now dynamically pass all slots to a child component. This is similar to   passing all slots in Vue:</li> </ul> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        return {\n            \"slots\": self.input.slots,\n        }\n\n    template: \"\"\"\n      &lt;div&gt;\n        {% component \"child\" %}\n          {% for slot_name in slots %}\n            {% fill name=slot_name data=\"data\" %}\n              {% slot name=slot_name ...data / %}\n            {% endfill %}\n          {% endfor %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"CHANGELOG/#fix_5","title":"Fix","text":"<ul> <li> <p>Slots defined with <code>{% fill %}</code> tags are now properly accessible via <code>self.input.slots</code> in <code>get_context_data()</code></p> </li> <li> <p>Do not raise error if multiple slots with same name are flagged as default</p> </li> <li> <p>Slots can now be defined within loops (<code>{% for %}</code>) or other tags (like <code>{% with %}</code>),   or even other templates using <code>{% include %}</code>.</p> </li> </ul> <p>Previously, following would cause the kwarg <code>name</code> to be an empty string:</p> <pre><code>{% for slot_name in slots %}\n  {% slot name=slot_name %}\n{% endfor %}\n</code></pre>"},{"location":"CHANGELOG/#refactor_2","title":"Refactor","text":"<ul> <li>When you define multiple slots with the same name inside a template,   you now have to set the <code>default</code> and <code>required</code> flags individually.</li> </ul> <pre><code>&lt;div class=\"calendar-component\"&gt;\n    &lt;div class=\"header\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n    &lt;div class=\"body\"&gt;\n        {% slot \"image\" default required %}Image here{% endslot %}\n    &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>This means you can also have multiple slots with the same name but   different conditions.</p> <p>E.g. in this example, we have a component that renders a user avatar   - a small circular image with a profile picture of name initials.</p> <p>If the component is given <code>image_src</code> or <code>name_initials</code> variables,   the <code>image</code> slot is optional. But if neither of those are provided,   you MUST fill the <code>image</code> slot.</p> <pre><code>&lt;div class=\"avatar\"&gt;\n    {% if image_src %}\n        {% slot \"image\" default %}\n            &lt;img src=\"{{ image_src }}\" /&gt;\n        {% endslot %}\n    {% elif name_initials %}\n        {% slot \"image\" default required %}\n            &lt;div style=\"\n                border-radius: 25px;\n                width: 50px;\n                height: 50px;\n                background: blue;\n            \"&gt;\n                {{ name_initials }}\n            &lt;/div&gt;\n        {% endslot %}\n    {% else %}\n        {% slot \"image\" default required / %}\n    {% endif %}\n&lt;/div&gt;\n</code></pre> <ul> <li>The slot fills that were passed to a component and which can be accessed as <code>Component.input.slots</code>   can now be passed through the Django template, e.g. as inputs to other tags.</li> </ul> <p>Internally, django-components handles slot fills as functions.</p> <p>Previously, if you tried to pass a slot fill within a template, Django would try to call it as a function.</p> <p>Now, something like this is possible:</p> <pre><code>class MyTable(Component):\n    def get_context_data(self, *args, **kwargs):\n        return {\n            \"child_slot\": self.input.slots[\"child_slot\"],\n        }\n\n    template: \"\"\"\n      &lt;div&gt;\n        {% component \"child\" content=child_slot / %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <p>NOTE: Using <code>{% slot %}</code> and <code>{% fill %}</code> tags is still the preferred method, but the approach above   may be necessary in some complex or edge cases.</p> <ul> <li>The <code>is_filled</code> variable (and the <code>{{ component_vars.is_filled }}</code> context variable) now returns   <code>False</code> when you try to access a slot name which has not been defined:</li> </ul> <p>Before:</p> <pre><code>{{ component_vars.is_filled.header }} -&gt; True\n{{ component_vars.is_filled.footer }} -&gt; False\n{{ component_vars.is_filled.nonexist }} -&gt; \"\" (empty string)\n</code></pre> <p>After:   <pre><code>{{ component_vars.is_filled.header }} -&gt; True\n{{ component_vars.is_filled.footer }} -&gt; False\n{{ component_vars.is_filled.nonexist }} -&gt; False\n</code></pre></p> <ul> <li> <p>Components no longer raise an error if there are extra slot fills</p> </li> <li> <p>Components will raise error when a slot is doubly-filled. </p> </li> </ul> <p>E.g. if we have a component with a default slot:</p> <pre><code>{% slot name=\"content\" default / %}\n</code></pre> <p>Now there is two ways how we can target this slot: Either using <code>name=\"default\"</code>   or <code>name=\"content\"</code>.</p> <p>In case you specify BOTH, the component will raise an error:</p> <pre><code>{% component \"child\" %}\n  {% fill slot=\"default\" %}\n    Hello from default slot\n  {% endfill %}\n  {% fill slot=\"content\" data=\"data\" %}\n    Hello from content slot\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"CHANGELOG/#v0100","title":"\ud83d\udea8\ud83d\udce2 v0.100","text":""},{"location":"CHANGELOG/#breaking-changes_2","title":"BREAKING CHANGES","text":"<ul> <li> <p><code>django_components.safer_staticfiles</code> app was removed. It is no longer needed.</p> </li> <li> <p>Installation changes:</p> <ul> <li>Instead of defining component directories in <code>STATICFILES_DIRS</code>, set them to <code>COMPONENTS.dirs</code>.</li> <li> <p>You now must define <code>STATICFILES_FINDERS</code></p> </li> <li> <p>See here how to migrate your settings.py</p> </li> </ul> </li> </ul>"},{"location":"CHANGELOG/#feat_2","title":"Feat","text":"<ul> <li>Beside the top-level <code>/components</code> directory, you can now define also app-level components dirs, e.g. <code>[app]/components</code>   (See <code>COMPONENTS.app_dirs</code>).</li> </ul>"},{"location":"CHANGELOG/#refactor_3","title":"Refactor","text":"<ul> <li>When you call <code>as_view()</code> on a component instance, that instance will be passed to <code>View.as_view()</code></li> </ul>"},{"location":"CHANGELOG/#v097","title":"v0.97","text":""},{"location":"CHANGELOG/#fix_6","title":"Fix","text":"<ul> <li>Fixed template caching. You can now also manually create cached templates with <code>cached_template()</code></li> </ul>"},{"location":"CHANGELOG/#refactor_4","title":"Refactor","text":"<ul> <li> <p>The previously undocumented <code>get_template</code> was made private.</p> </li> <li> <p>In it's place, there's a new <code>get_template</code>, which supersedes <code>get_template_string</code> (will be removed in v1). The new <code>get_template</code> is the same as <code>get_template_string</code>, except   it allows to return either a string or a Template instance.</p> </li> <li> <p>You now must use only one of <code>template</code>, <code>get_template</code>, <code>template_name</code>, or <code>get_template_name</code>.</p> </li> </ul>"},{"location":"CHANGELOG/#v096","title":"v0.96","text":""},{"location":"CHANGELOG/#feat_3","title":"Feat","text":"<ul> <li> <p>Run-time type validation for Python 3.11+ - If the <code>Component</code> class is typed, e.g. <code>Component[Args, Kwargs, ...]</code>, the args, kwargs, slots, and data are validated against the given types. (See Runtime input validation with types)</p> </li> <li> <p>Render hooks - Set <code>on_render_before</code> and <code>on_render_after</code> methods on <code>Component</code> to intercept or modify the template or context before rendering, or the rendered result afterwards. (See Component hooks)</p> </li> <li> <p><code>component_vars.is_filled</code> context variable can be accessed from within <code>on_render_before</code> and <code>on_render_after</code> hooks as <code>self.is_filled.my_slot</code></p> </li> </ul>"},{"location":"CHANGELOG/#095","title":"0.95","text":""},{"location":"CHANGELOG/#feat_4","title":"Feat","text":"<ul> <li>Added support for dynamic components, where the component name is passed as a variable. (See Dynamic components)</li> </ul>"},{"location":"CHANGELOG/#refactor_5","title":"Refactor","text":"<ul> <li>Changed <code>Component.input</code> to raise <code>RuntimeError</code> if accessed outside of render context. Previously it returned <code>None</code> if unset.</li> </ul>"},{"location":"CHANGELOG/#v094","title":"v0.94","text":""},{"location":"CHANGELOG/#feat_5","title":"Feat","text":"<ul> <li> <p>django_components now automatically configures Django to support multi-line tags. (See Multi-line tags)</p> </li> <li> <p>New setting <code>reload_on_template_change</code>. Set this to <code>True</code> to reload the dev server on changes to component template files. (See Reload dev server on component file changes)</p> </li> </ul>"},{"location":"CHANGELOG/#v093","title":"v0.93","text":""},{"location":"CHANGELOG/#feat_6","title":"Feat","text":"<ul> <li> <p>Spread operator <code>...dict</code> inside template tags. (See Spread operator)</p> </li> <li> <p>Use template tags inside string literals in component inputs. (See Use template tags inside component inputs)</p> </li> <li> <p>Dynamic slots, fills and provides - The <code>name</code> argument for these can now be a variable, a template expression, or via spread operator</p> </li> <li> <p>Component library authors can now configure <code>CONTEXT_BEHAVIOR</code> and <code>TAG_FORMATTER</code> settings independently from user settings.</p> </li> </ul>"},{"location":"CHANGELOG/#v092","title":"\ud83d\udea8\ud83d\udce2 v0.92","text":""},{"location":"CHANGELOG/#breaking-changes_3","title":"BREAKING CHANGES","text":"<ul> <li><code>Component</code> class is no longer a subclass of <code>View</code>. To configure the <code>View</code> class, set the <code>Component.View</code> nested class. HTTP methods like <code>get</code> or <code>post</code> can still be defined directly on <code>Component</code> class, and <code>Component.as_view()</code> internally calls <code>Component.View.as_view()</code>. (See Modifying the View class)</li> </ul>"},{"location":"CHANGELOG/#feat_7","title":"Feat","text":"<ul> <li> <p>The inputs (args, kwargs, slots, context, ...) that you pass to <code>Component.render()</code> can be accessed from within <code>get_context_data</code>, <code>get_template</code> and <code>get_template_name</code> via <code>self.input</code>. (See Accessing data passed to the component)</p> </li> <li> <p>Typing: <code>Component</code> class supports generics that specify types for <code>Component.render</code> (See Adding type hints with Generics)</p> </li> </ul>"},{"location":"CHANGELOG/#v090","title":"v0.90","text":""},{"location":"CHANGELOG/#feat_8","title":"Feat","text":"<ul> <li> <p>All tags (<code>component</code>, <code>slot</code>, <code>fill</code>, ...) now support \"self-closing\" or \"inline\" form, where you can omit the closing tag:</p> <pre><code>{# Before #}\n{% component \"button\" %}{% endcomponent %}\n{# After #}\n{% component \"button\" / %}\n</code></pre> </li> <li> <p>All tags now support the \"dictionary key\" or \"aggregate\" syntax (<code>kwarg:key=val</code>):</p> <pre><code>{% component \"button\" attrs:class=\"hidden\" %}\n</code></pre> </li> <li> <p>You can change how the components are written in the template with TagFormatter.</p> <p>The default is <code>django_components.component_formatter</code>:</p> <pre><code>{% component \"button\" href=\"...\" disabled %}\n    Click me!\n{% endcomponent %}\n</code></pre> <p>While <code>django_components.shorthand_component_formatter</code> allows you to write components like so:</p> <pre><code>{% button href=\"...\" disabled %}\n    Click me!\n{% endbutton %}\n</code></pre> </li> </ul>"},{"location":"CHANGELOG/#v085","title":"\ud83d\udea8\ud83d\udce2 v0.85","text":""},{"location":"CHANGELOG/#breaking-changes_4","title":"BREAKING CHANGES","text":"<ul> <li> <p>Autodiscovery module resolution changed. Following undocumented behavior was removed:</p> <ul> <li> <p>Previously, autodiscovery also imported any <code>[app]/components.py</code> files, and used <code>SETTINGS_MODULE</code> to search for component dirs.</p> <p>To migrate from:</p> <ul> <li> <p><code>[app]/components.py</code> - Define each module in <code>COMPONENTS.libraries</code> setting,     or import each module inside the <code>AppConfig.ready()</code> hook in respective <code>apps.py</code> files.</p> </li> <li> <p><code>SETTINGS_MODULE</code> - Define component dirs using <code>STATICFILES_DIRS</code></p> </li> </ul> </li> <li> <p>Previously, autodiscovery handled relative files in <code>STATICFILES_DIRS</code>. To align with Django, <code>STATICFILES_DIRS</code> now must be full paths (Django docs).</p> </li> </ul> </li> </ul>"},{"location":"CHANGELOG/#v081","title":"\ud83d\udea8\ud83d\udce2 v0.81","text":""},{"location":"CHANGELOG/#breaking-changes_5","title":"BREAKING CHANGES","text":"<ul> <li>The order of arguments to <code>render_to_response</code> has changed, to align with the (now public) <code>render</code> method of <code>Component</code> class.</li> </ul>"},{"location":"CHANGELOG/#feat_9","title":"Feat","text":"<ul> <li> <p><code>Component.render()</code> is public and documented</p> </li> <li> <p>Slots passed <code>render_to_response</code> and <code>render</code> can now be rendered also as functions.</p> </li> </ul>"},{"location":"CHANGELOG/#v080","title":"v0.80","text":""},{"location":"CHANGELOG/#feat_10","title":"Feat","text":"<ul> <li>Vue-like provide/inject with the <code>{% provide %}</code> tag and <code>inject()</code> method.</li> </ul>"},{"location":"CHANGELOG/#v079","title":"\ud83d\udea8\ud83d\udce2 v0.79","text":""},{"location":"CHANGELOG/#breaking-changes_6","title":"BREAKING CHANGES","text":"<ul> <li>Default value for the <code>COMPONENTS.context_behavior</code> setting was changes from <code>\"isolated\"</code> to <code>\"django\"</code>. If you did not set this value explicitly before, this may be a breaking change. See the rationale for change here.</li> </ul>"},{"location":"CHANGELOG/#v077","title":"\ud83d\udea8\ud83d\udce2 v0.77","text":""},{"location":"CHANGELOG/#breaking","title":"BREAKING","text":"<ul> <li> <p>The syntax for accessing default slot content has changed from</p> <pre><code>{% fill \"my_slot\" as \"alias\" %}\n    {{ alias.default }}\n{% endfill %}\n</code></pre> <p>to</p> <pre><code>{% fill \"my_slot\" default=\"alias\" %}\n    {{ alias }}\n{% endfill %}\n</code></pre> </li> </ul>"},{"location":"CHANGELOG/#v074","title":"v0.74","text":""},{"location":"CHANGELOG/#feat_11","title":"Feat","text":"<ul> <li> <p><code>{% html_attrs %}</code> tag for formatting data as HTML attributes</p> </li> <li> <p><code>prefix:key=val</code> construct for passing dicts to components</p> </li> </ul>"},{"location":"CHANGELOG/#v070","title":"\ud83d\udea8\ud83d\udce2 v0.70","text":""},{"location":"CHANGELOG/#breaking-changes_7","title":"BREAKING CHANGES","text":"<ul> <li> <p><code>{% if_filled \"my_slot\" %}</code> tags were replaced with <code>{{ component_vars.is_filled.my_slot }}</code> variables.</p> </li> <li> <p>Simplified settings - <code>slot_context_behavior</code> and <code>context_behavior</code> were merged. See the documentation for more details.</p> </li> </ul>"},{"location":"CHANGELOG/#v067","title":"v0.67","text":""},{"location":"CHANGELOG/#refactor_6","title":"Refactor","text":"<ul> <li>Changed the default way how context variables are resolved in slots. See the documentation for more details.</li> </ul>"},{"location":"CHANGELOG/#v050","title":"\ud83d\udea8\ud83d\udce2 v0.50","text":""},{"location":"CHANGELOG/#breaking-changes_8","title":"BREAKING CHANGES","text":"<ul> <li> <p><code>{% component_block %}</code> is now <code>{% component %}</code>, and <code>{% component %}</code> blocks need an ending <code>{% endcomponent %}</code> tag.</p> <p>The new <code>python manage.py upgradecomponent</code> command can be used to upgrade a directory (use <code>--path</code> argument to point to each dir) of templates that use components to the new syntax automatically.</p> <p>This change is done to simplify the API in anticipation of a 1.0 release of django_components. After 1.0 we intend to be stricter with big changes like this in point releases.</p> </li> </ul>"},{"location":"CHANGELOG/#v034","title":"v0.34","text":""},{"location":"CHANGELOG/#feat_12","title":"Feat","text":"<ul> <li>Components as views, which allows you to handle requests and render responses from within a component. See the documentation for more details.</li> </ul>"},{"location":"CHANGELOG/#v028","title":"v0.28","text":""},{"location":"CHANGELOG/#feat_13","title":"Feat","text":"<ul> <li>'implicit' slot filling and the <code>default</code> option for <code>slot</code> tags.</li> </ul>"},{"location":"CHANGELOG/#v027","title":"v0.27","text":""},{"location":"CHANGELOG/#feat_14","title":"Feat","text":"<ul> <li>A second installable app <code>django_components.safer_staticfiles</code>. It provides the same behavior as <code>django.contrib.staticfiles</code> but with extra security guarantees (more info below in Security Notes).</li> </ul>"},{"location":"CHANGELOG/#v026","title":"\ud83d\udea8\ud83d\udce2 v0.26","text":""},{"location":"CHANGELOG/#breaking-changes_9","title":"BREAKING CHANGES","text":"<ul> <li> <p>Changed the syntax for <code>{% slot %}</code> tags. From now on, we separate defining a slot (<code>{% slot %}</code>) from filling a slot with content (<code>{% fill %}</code>). This means you will likely need to change a lot of slot tags to fill.</p> <p>We understand this is annoying, but it's the only way we can get support for nested slots that fill in other slots, which is a very nice feature to have access to. Hoping that this will feel worth it!</p> </li> </ul>"},{"location":"CHANGELOG/#v022","title":"v0.22","text":""},{"location":"CHANGELOG/#feat_15","title":"Feat","text":"<ul> <li> <p>All files inside components subdirectores are autoimported to simplify setup.</p> <p>An existing project might start to get <code>AlreadyRegistered</code> errors because of this. To solve this, either remove your custom loading of components, or set <code>\"autodiscover\": False</code> in <code>settings.COMPONENTS</code>.</p> </li> </ul>"},{"location":"CHANGELOG/#v017","title":"v0.17","text":""},{"location":"CHANGELOG/#breaking-changes_10","title":"BREAKING CHANGES","text":"<ul> <li> <p>Renamed <code>Component.context</code> and <code>Component.template</code> to <code>get_context_data</code> and <code>get_template_name</code>. The old methods still work, but emit a deprecation warning.</p> <p>This change was done to sync naming with Django's class based views, and make using django-components more familiar to Django users. <code>Component.context</code> and <code>Component.template</code> will be removed when version 1.0 is released.</p> </li> </ul>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or  advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic  address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a  professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at emil@emilstenstrom.se. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html</p> <p>For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>README</li> <li>Changelog</li> <li>Code of Conduct</li> <li>License</li> <li>Reference</li> <li>API Reference</li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2019 Emil Stenstr\u00f6m</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"migrating_from_safer_staticfiles/","title":"Migrating from safer_staticfiles","text":"<p>This guide is for you if you're upgrating django_components to v0.100 or later from older versions.</p> <p>In version 0.100, we changed how components' static JS and CSS files are handled. See more in the \"Static files\" section.</p> <p>Migration steps:</p> <ol> <li>Remove <code>django_components.safer_staticfiles</code> from <code>INSTALLED_APPS</code> in your <code>settings.py</code>,    and replace it with <code>django.contrib.staticfiles</code>.</li> </ol> <p>Before:</p> <pre><code>INSTALLED_APPS = [\n   \"django.contrib.admin\",\n   ...\n   # \"django.contrib.staticfiles\",  # &lt;-- ADD\n   \"django_components\",\n   \"django_components.safer_staticfiles\",  # &lt;-- REMOVE\n]\n</code></pre> <p>After:</p> <pre><code>INSTALLED_APPS = [\n   \"django.contrib.admin\",\n   ...\n   \"django.contrib.staticfiles\",\n   \"django_components\",\n]\n</code></pre> <ol> <li>Add <code>STATICFILES_FINDERS</code> to <code>settings.py</code>, and add <code>django_components.finders.ComponentsFileSystemFinder</code>:</li> </ol> <pre><code>STATICFILES_FINDERS = [\n   # Default finders\n   \"django.contrib.staticfiles.finders.FileSystemFinder\",\n   \"django.contrib.staticfiles.finders.AppDirectoriesFinder\",\n   # Django components\n   \"django_components.finders.ComponentsFileSystemFinder\",  # &lt;-- ADDED\n]\n</code></pre> <ol> <li>Add <code>COMPONENTS.dirs</code> to <code>settings.py</code>.</li> </ol> <p>If you previously defined <code>STATICFILES_DIRS</code>, move    only those directories from <code>STATICFILES_DIRS</code> that point to components directories, and keep the rest.</p> <p>E.g. if you have <code>STATICFILES_DIRS</code> like this:</p> <pre><code>STATICFILES_DIRS = [\n   BASE_DIR / \"components\",  # &lt;-- MOVE\n   BASE_DIR / \"myapp\" / \"components\",  # &lt;-- MOVE\n   BASE_DIR / \"assets\",\n]\n</code></pre> <p>Then first two entries point to components dirs, whereas <code>/assets</code> points to non-component static files.    In this case move only the first two paths:</p> <pre><code>COMPONENTS = {\n   \"dirs\": [\n      BASE_DIR / \"components\",  # &lt;-- MOVED\n      BASE_DIR / \"myapp\" / \"components\",  # &lt;-- MOVED\n   ],\n}\n\nSTATICFILES_DIRS = [\n   BASE_DIR / \"assets\",\n]\n</code></pre> <p>Moreover, if you defined app-level component directories in <code>STATICFILES_DIRS</code> before,    you can now define as a RELATIVE path in <code>app_dirs</code>:</p> <pre><code>COMPONENTS = {\n   \"dirs\": [\n      # Search top-level \"/components/\" dir\n      BASE_DIR / \"components\",\n   ],\n   \"app_dirs\": [\n      # Search \"/[app]/components/\" dirs\n      \"components\",\n   ],\n}\n\nSTATICFILES_DIRS = [\n   BASE_DIR / \"assets\",\n]\n</code></pre>"},{"location":"devguides/dependency_mgmt/","title":"JS and CSS rendering","text":"<p>Aim of this doc is to share the intuition on how we manage the JS and CSS (\"dependencies\") associated with components, and how we render them.</p>"},{"location":"devguides/dependency_mgmt/#starting-conditions","title":"Starting conditions","text":"<ol> <li>First of all, when we consider a component, it has two kind of dependencies - the \"inlined\" JS and CSS, and additional linked JS and CSS via <code>Media.js/css</code>:</li> </ol> <pre><code>from django_components import Component, types\n\nclass MyTable(Component):\n    # Inlined JS\n    js: types.js = \"\"\"\n      console.log(123);\n    \"\"\"\n\n    # Inlined CSS\n    css: types.css = \"\"\"\n      .my-table {\n        color: red;\n      }\n    \"\"\"\n\n    # Linked JS / CSS\n    class Media:\n        js = [\n            \"script-one.js\",  # STATIC file relative to component file\n            \"/script-two.js\", # URL path\n            \"https://example.com/script-three.js\", # URL\n        ]\n\n        css = [\n            \"style-one.css\",  # STATIC file relative to component file\n            \"/style-two.css\", # URL path\n            \"https://example.com/style-three.css\", # URL\n        ]\n</code></pre> <ol> <li>Second thing to keep in mind is that all component's are eventually rendered into a string. And so, if we want to associate extra info with a rendered component, it has to be serialized to a string.</li> </ol> <p>This is because a component may be embedded in a Django Template with the <code>{% component %}</code> tag, which, when rendered, is turned into a string:</p> <pre><code>template = Template(\"\"\"\n  {% load component_tags %}\n  &lt;div&gt;\n    {% component \"my_table\" / %}\n  &lt;/div&gt;\n\"\"\")\n\nhtml_str = template.render(Context({}))\n</code></pre> <p>And for this reason, we take the same approach also when we render a component with <code>Component.render()</code> - It returns a string.</p> <ol> <li>Thirdly, we also want to add support for JS / CSS variables. That is, that a variable defined on the component would be somehow accessible from within the JS script / CSS style.</li> </ol> <p>A simple approach to this would be to modify the inlined JS / CSS directly, and insert them for each component. But if you had extremely large JS / CSS, and e.g. only a single JS / CSS variable that you want to insert, it would be extremely wasteful to copy-paste the JS / CSS for each component instance.</p> <p>So instead, a preferred approach here is to defined and insert the inlined JS / CSS only once, and have some kind of mechanism on how we make correct the JS / CSS variables available only to the correct components.</p> <ol> <li>Last important thing is that we want the JS / CSS dependencies to work also with HTML fragments.</li> </ol> <p>So normally, e.g. when a user hits URL of a web page, the server renders full HTML document, with <code>&lt;!doctype&gt;</code>, <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, and <code>&lt;body&gt;</code>. In such case, we know about ALL JS and CSS dependencies at render time, so we can e.g. insert them into <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> ourselves.</p> <p>However this renders only the initial state. HTML fragments is a common pattern where interactivity is added to the web page by fetching and replacing bits of HTML on the main HTML document after some user action.</p> <p>In the case of HTML fragments, the HTML is NOT a proper document, but only the HTML that will be inserted somewhere into the DOM.</p> <p>The challenge here is that Django template for the HTML fragment MAY contain components, and these components MAY have inlined or linked JS and CSS.</p> <pre><code>def fragment_view(request):\n    template = Template(\"\"\"\n      {% load component_tags %}\n      &lt;div&gt;\n        {% component \"my_table\" / %}\n      &lt;/div&gt;\n    \"\"\")\n\n    fragment_str = template.render(Context({}))\n    return HttpResponse(fragment_str, status=200)\n</code></pre> <p>User may use different libraries to fetch and insert the HTML fragments (e.g. HTMX, AlpineJS, ...). From our perspective, the only thing that we can reliably say is that we expect that the HTML fragment WILL be eventually inserted into the DOM.</p> <p>So to include the corresponding JS and CSS, a simple approach could be to append them to the HTML as <code>&lt;style&gt;</code> and <code>&lt;script&gt;</code>, e.g.:</p> <pre><code>&lt;!-- Original content --&gt;\n&lt;div&gt;...&lt;/div&gt;\n&lt;!-- Associated CSS files --&gt;\n&lt;link href=\"http://...\" /&gt;\n&lt;style&gt;\n  .my-class {\n    color: red;\n  }\n&lt;/style&gt;\n&lt;!-- Associated JS files --&gt;\n&lt;script src=\"http://...\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  console.log(123);\n&lt;/script&gt;\n</code></pre> <p>But this has a number of issues:</p> <ul> <li>The JS scripts would run for each instance of the component.</li> <li>Bloating of the HTML file, as each inlined JS or CSS would be included fully for each component.<ul> <li>While this sound OK, this could really bloat the HTML files if we used a UI component library for the basic building blocks like buttons, lists, cards, etc.</li> </ul> </li> </ul>"},{"location":"devguides/dependency_mgmt/#flow","title":"Flow","text":"<p>So the solution should address all the points above. To achieve that, we manage the JS / CSS dependencies ourselves in the browser. So when a full HTML document is loaded, we keep track of which JS and CSS have been loaded. And when an HTML fragment is inserted, we check which JS / CSS dependencies it has, and load only those that have NOT been loaded yet.</p> <p>This is how we achieve that:</p> <ol> <li>When a component is rendered, it inserts an HTML comment containing metadata about the rendered component.</li> </ol> <p>So a template like this</p> <pre><code>{% load component_tags %}\n&lt;div&gt;\n  {% component \"my_table\" / %}\n&lt;/div&gt;\n{% component \"button\" %}\n  Click me!\n{% endcomponent %}\n</code></pre> <p>May actually render:</p> <pre><code>&lt;div&gt;\n  &lt;!-- _RENDERED \"my_table_10bc2c,c020ad\" --&gt;\n  &lt;table&gt;\n    ...\n  &lt;/table&gt;\n&lt;/div&gt;\n&lt;!-- _RENDERED \"button_309dcf,31c0da\" --&gt;\n&lt;button&gt;Click me!&lt;/button&gt;\n</code></pre> <p>Each <code>&lt;!-- _RENDERED --&gt;</code> comment includes comma-separated data - a unique hash for the component class, e.g. <code>my_table_10bc2c</code>, and the component ID, e.g. <code>c020ad</code>.</p> <p>This way, we or the user can freely pass the rendered around or transform it, treating it as a string to add / remove / replace bits. As long as the <code>&lt;!-- _RENDERED --&gt;</code> comments remain in the rendered string, we will be able to deduce which JS and CSS dependencies the component needs.</p> <ol> <li>Post-process the rendered HTML, extracting the <code>&lt;!-- _RENDERED --&gt;</code> comments, and instead inserting the corresponding JS and CSS dependencies.</li> </ol> <p>If we dealt only with JS, then we could get away with processing the <code>&lt;!-- _RENDERED --&gt;</code> comments on the client (browser). However, the CSS needs to be processed still on the server, so the browser receives CSS styles already inserted as <code>&lt;style&gt;</code> or <code>&lt;link&gt;</code> HTML tags. Because if we do not do that, we get a flash of unstyled content, as there will be a delay between when the HTML page loaded and when the CSS was fetched and loaded.</p> <p>So, assuming that a user has already rendered their template, which still contains <code>&lt;!-- _RENDERED --&gt;</code> comments, we need to extract and process these comments.</p> <p>There's multiple ways to achieve this:</p> <ul> <li> <p>The approach recommended to the users is to use the <code>ComponentDependencyMiddleware</code> middleware, which scans all outgoing HTML, and post-processes the <code>&lt;!-- _RENDERED --&gt;</code> comments.</p> </li> <li> <p>If users are using <code>Component.render()</code> or <code>Component.render_to_response()</code>, these post-process the <code>&lt;!-- _RENDERED --&gt;</code> comments by default.</p> <ul> <li>NOTE: Users are able to opt out of the post-processing by setting <code>render_dependencies=False</code>.</li> </ul> </li> <li> <p>For advanced use cases, users may use <code>render_dependencies()</code> directly. This is the function that both <code>ComponentDependencyMiddleware</code> and <code>Component.render()</code> call internally.</p> </li> </ul> <p><code>render_dependencies()</code>, whether called directly, via middleware or other way, does the following:</p> <ol> <li> <p>Find all <code>&lt;!-- _RENDERED --&gt;</code> comments, and for each comment:</p> </li> <li> <p>Look up the corresponding component class.</p> </li> <li> <p>Get the component's inlined JS / CSS from <code>Component.js/css</code>, and linked JS / CSS from <code>Component.Media.js/css</code>.</p> </li> <li> <p>Generate JS script that loads the JS / CSS dependencies.</p> </li> <li> <p>Insert the JS scripts either at the end of <code>&lt;body&gt;</code>, or in place of <code>{% component_dependencies %}</code> / <code>{% component_js_dependencies %}</code> tags.</p> </li> <li> <p>To avoid the flash of unstyled content, we need place the styles into the HTML instead of dynamically loading them from within a JS script. The CSS is placed either at the end of <code>&lt;head&gt;</code>, or in place of <code>{% component_dependencies %}</code> / <code>{% component_css_dependencies %}</code></p> </li> <li> <p>We cache the component's inlined JS and CSS, so they can be fetched via an URL, so the inlined JS / CSS an be treated the same way as the JS / CSS dependencies set in <code>Component.Media.js/css</code>.</p> <ul> <li>NOTE: While this is currently not entirely necessary, it opens up the doors for allowing plugins to post-process the inlined JS and CSS. Because after it has been post-processed, we need to store it somewhere.</li> </ul> </li> <li> <p>Server returns the post-processed HTML.</p> </li> <li> <p>In the browser, the generated JS script from step 2.4 is executed. It goes through all JS and CSS dependencies it was given. If some JS / CSS was already loaded, it is NOT fetched again. Otherwise it generates the corresponding <code>&lt;script&gt;</code> or <code>&lt;link&gt;</code> HTML tags to load the JS / CSS dependencies.</p> </li> </ol> <p>In the browser, the \"dependency manager JS\" may look like this:</p> <pre><code>// Load JS or CSS script if not loaded already\nComponents.loadScript(\"js\", '&lt;script src=\"/abc/xyz/script.js\"&gt;');\nComponents.loadScript(\"css\", '&lt;link href=\"/abc/xyz/style.css\"&gt;');\n\n// Or mark one as already-loaded, so it is ignored when\n// we call `loadScript`\nComponents.markScriptLoaded(\"js\", \"/abc/def\");\n</code></pre> <p>Note that <code>loadScript()</code> receives a whole <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags, not just the URL.    This is because when Django's <code>Media</code> class renders JS and CSS, it formats it as <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags.    And we allow users to modify how the JS and CSS should be rendered into the <code>&lt;script&gt;</code> and <code>&lt;link&gt;</code> tags.</p> <p>So, if users decided to add an extra attribute to their <code>&lt;script&gt;</code> tags, e.g. <code>&lt;script defer src=\"http://...\"&gt;&lt;/script&gt;</code>,    then this way we make sure that the <code>defer</code> attribute will be present on the <code>&lt;script&gt;</code> tag when    it is inserted into the DOM at the time of loading the JS script.</p> <ol> <li>To be able to fetch component's inlined JS and CSS, django-components adds a URL path under:</li> </ol> <p><code>/components/cache/&lt;str:comp_cls_hash&gt;.&lt;str:script_type&gt;/</code></p> <p>E.g. <code>/components/cache/my_table_10bc2c.js/</code></p> <p>This endpoint takes the component's unique hash, e.g. <code>my_table_10bc2c</code>, and looks up the component's inlined JS or CSS.</p> <p>Thus, with this approach, we ensure that:</p> <ol> <li>All JS / CSS dependencies are loaded / executed only once.</li> <li>The approach is compatible with HTML fragments</li> <li>The approach is compatible with JS / CSS variables.</li> <li>Inlined JS / CSS may be post-processed by plugins</li> </ol>"},{"location":"devguides/slot_rendering/","title":"Slot rendering","text":"<p>This doc serves as a primer on how component slots and fills are resolved.</p>"},{"location":"devguides/slot_rendering/#flow","title":"Flow","text":"<ol> <li> <p>Imagine you have a template. Some kind of text, maybe HTML:    <pre><code>| ------\n| ---------\n| ----\n| -------\n</code></pre></p> </li> <li> <p>The template may contain some vars, tags, etc    <pre><code>| -- {{ my_var }} --\n| ---------\n| ----\n| -------\n</code></pre></p> </li> <li> <p>The template also contains some slots, etc    <pre><code>| -- {{ my_var }} --\n| ---------\n| -- {% slot \"myslot\" %} ---\n| -- {% endslot %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>Slots may be nested    <pre><code>| -- {{ my_var }} --\n| -- ABC\n| -- {% slot \"myslot\" %} ---\n| ----- DEF {{ my_var }}\n| ----- {% slot \"myslot_inner\" %}\n| -------- GHI {{ my_var }}\n| ----- {% endslot %}\n| -- {% endslot %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| ---- JKL {{ my_var }}\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>Some slots may be inside fills for other components    <pre><code>| -- {{ my_var }} --\n| -- ABC\n| -- {% slot \"myslot\" %}---\n| ----- DEF {{ my_var }}\n| ----- {% slot \"myslot_inner\" %}\n| -------- GHI {{ my_var }}\n| ----- {% endslot %}\n| -- {% endslot %} ---\n| ------\n| -- {% component \"mycomp\" %} ---\n| ---- {% slot \"myslot\" %} ---\n| ------- JKL {{ my_var }}\n| ------- {% slot \"myslot_inner\" %}\n| ---------- MNO {{ my_var }}\n| ------- {% endslot %}\n| ---- {% endslot %} ---\n| -- {% endcomponent %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| ---- PQR {{ my_var }}\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>The names of the slots and fills may be defined using variables    <pre><code>| -- {% slot slot_name %} ---\n| ---- STU {{ my_var }}\n| -- {% endslot %} ---\n| -------\n</code></pre></p> </li> <li> <p>The slot and fill names may be defined using for loops or other variables defined within the template (e.g. <code>{% with %}</code> tag or <code>{% ... as var %}</code> syntax)    <pre><code>| -- {% for slot_name in slots %} ---\n| ---- {% slot slot_name %} ---\n| ------ STU {{ slot_name }}\n| ---- {% endslot %} ---\n| -- {% endfor %} ---\n| -------\n</code></pre></p> </li> <li> <p>Variables for names and for loops allow us implement \"passthrough slots\" - that is, taking all slots that our component received, and passing them to a child component, dynamically.    <pre><code>| -- {% component \"mycomp\" %} ---\n| ---- {% for slot_name in slots %} ---\n| ------ {% fill slot_name %} ---\n| -------- {% slot slot_name %} ---\n| ---------- XYZ {{ slot_name }}\n| --------- {% endslot %}\n| ------- {% endfill %}\n| ---- {% endfor %} ---\n| -- {% endcomponent %} ---\n| ----\n</code></pre></p> </li> <li> <p>Putting that all together, a document may look like this:    <pre><code>| -- {{ my_var }} --\n| -- ABC\n| -- {% slot \"myslot\" %}---\n| ----- DEF {{ my_var }}\n| ----- {% slot \"myslot_inner\" %}\n| -------- GHI {{ my_var }}\n| ----- {% endslot %}\n| -- {% endslot %} ---\n| ------\n| -- {% component \"mycomp\" %} ---\n| ---- {% slot \"myslot\" %} ---\n| ------- JKL {{ my_var }}\n| ------- {% slot \"myslot_inner\" %}\n| ---------- MNO {{ my_var }}\n| ------- {% endslot %}\n| ---- {% endslot %} ---\n| -- {% endcomponent %} ---\n| ----\n| -- {% slot \"myslot2\" %} ---\n| ---- PQR {{ my_var }}\n| -- {% endslot %} ---\n| -------\n| -- {% for slot_name in slots %} ---\n| ---- {% component \"mycomp\" %} ---\n| ------- {% slot slot_name %}\n| ---------- STU {{ slot_name }}\n| ------- {% endslot %}\n| ---- {% endcomponent %} ---\n| -- {% endfor %} ---\n| ----\n| -- {% component \"mycomp\" %} ---\n| ---- {% for slot_name in slots %} ---\n| ------ {% fill slot_name %} ---\n| -------- {% slot slot_name %} ---\n| ---------- XYZ {{ slot_name }}\n| --------- {% endslot %}\n| ------- {% endfill %}\n| ---- {% endfor %} ---\n| -- {% endcomponent %} ---\n| -------\n</code></pre></p> </li> <li> <p>Given the above, we want to render the slots with <code>{% fill %}</code> tag that were defined OUTSIDE of this template. How do I do that?</p> <p>NOTE: Before v0.110, slots were resolved statically, by walking down the Django Template and Nodes. However, this did not allow for using for loops or other variables defined in the template.</p> <p>Currently, this consists of 2 steps:</p> <ol> <li> <p>If a component is rendered within a template using <code>{% component %}</code> tag, determine the given <code>{% fill %}</code> tags in the component's body (the content in between <code>{% component %}</code> and <code>{% endcomponent %}</code>).</p> <p>After this step, we know about all the fills that were passed to the component.</p> </li> <li> <p>Then we simply render the template as usual. And then we reach the <code>{% slot %}</code> tag, we search the context for the available fills.</p> <ul> <li>If there IS a fill with the same name as the slot, we render the fill.</li> <li>If the slot is marked <code>default</code>, and there is a fill named <code>default</code>, then we render that.</li> <li>Otherwise, we render the slot's default content.</li> </ul> </li> </ol> </li> <li> <p>Obtaining the fills from <code>{% fill %}</code>.</p> <p>When a component is rendered with <code>{% component %}</code> tag, and it has some content in between <code>{% component %}</code> and <code>{% endcomponent %}</code>, we want to figure out if that content is a default slot (no <code>{% fill %}</code> used), or if there is a collection of named <code>{% fill %}</code> tags:</p> <p>Default slot:</p> <pre><code>| -- {% component \"mycomp\" %} ---\n| ---- STU {{ slot_name }}\n| -- {% endcomponent %} ---\n</code></pre> <p>Named slots:</p> <pre><code>| -- {% component \"mycomp\" %} ---\n| ---- {% fill \"slot_a\" %}\n| ------ STU\n| ---- {% endslot %}\n| ---- {% fill \"slot_b\" %}\n| ------ XYZ\n| ---- {% endslot %}\n| -- {% endcomponent %} ---\n</code></pre> <p>To respect any forloops or other variables defined within the template to which the fills may have access, we:</p> <ol> <li>Render the content between <code>{% component %}</code> and <code>{% endcomponent %}</code> using the context    outside of the component.</li> <li>When we reach a <code>{% fill %}</code> tag, we capture any variables that were created between    the <code>{% component %}</code> and <code>{% fill %}</code> tags.</li> <li>When we reach <code>{% fill %}</code> tag, we do not continue rendering deeper. Instead we    make a record that we found the fill tag with given name, kwargs, etc.</li> <li>After the rendering is done, we check if we've encountered any fills.    If yes, we expect only named fills. If no, we assume that the the component's body    is a default slot.</li> <li>Lastly we process the found fills, and make them available to the context, so any    slots inside the component may access these fills.</li> </ol> </li> <li> <p>Rendering slots</p> <p>Slot rendering works similarly to collecting fills, in a sense that we do not search for the slots ahead of the time, but instead let Django handle the rendering of the template, and we step in only when Django come across as <code>{% slot %}</code> tag.</p> <p>When we reach a slot tag, we search the context for the available fills.</p> <ul> <li>If there IS a fill with the same name as the slot, we render the fill.</li> <li>If the slot is marked <code>default</code>, and there is a fill named <code>default</code>, then we render that.</li> <li>Otherwise, we render the slot's default content.</li> </ul> </li> </ol>"},{"location":"devguides/slot_rendering/#using-the-correct-context-in-slotfill-tags","title":"Using the correct context in {% slot/fill %} tags","text":"<p>In previous section, we said that the <code>{% fill %}</code> tags should be already rendered by the time they are inserted into the <code>{% slot %}</code> tags.</p> <p>This is not quite true. To help you understand, consider this complex case:</p> <pre><code>| -- {% for var in [1, 2, 3] %} ---\n| ---- {% component \"mycomp2\" %} ---\n| ------ {% fill \"first\" %}\n| ------- STU {{ my_var }}\n| -------     {{ var }}\n| ------ {% endfill %}\n| ------ {% fill \"second\" %}\n| -------- {% component var=var my_var=my_var %}\n| ---------- VWX {{ my_var }}\n| -------- {% endcomponent %}\n| ------ {% endfill %}\n| ---- {% endcomponent %} ---\n| -- {% endfor %} ---\n| -------\n</code></pre> <p>We want the forloop variables to be available inside the <code>{% fill %}</code> tags. Because of that, however, we CANNOT render the fills/slots in advance.</p> <p>Instead, our solution is closer to how Vue handles slots. In Vue, slots are effectively functions that accept a context variables and render some content.</p> <p>While we do not wrap the logic in a function, we do PREPARE IN ADVANCE: 1. The content that should be rendered for each slot 2. The context variables from <code>get_context_data()</code></p> <p>Thus, once we reach the <code>{% slot %}</code> node, in it's <code>render()</code> method, we access the data above, and, depending on the <code>context_behavior</code> setting, include the current context or not. For more info, see <code>SlotNode.render()</code>.</p>"},{"location":"devguides/slots_and_blocks/","title":"Using <code>slot</code> and <code>block</code> tags","text":"<ol> <li> <p>First let's clarify how <code>include</code> and <code>extends</code> tags work inside components.     So when component template includes <code>include</code> or <code>extends</code> tags, it's as if the \"included\"     template was inlined. So if the \"included\" template contains <code>slot</code> tags, then the component     uses those slots.</p> <pre><code>So if you have a template `abc.html`:\n```django\n&lt;div&gt;\n  hello\n  {% slot \"body\" %}{% endslot %}\n&lt;/div&gt;\n```\n\nAnd components that make use of `abc.html` via `include` or `extends`:\n```py\nfrom django_components import Component, register\n\n@register(\"my_comp_extends\")\nclass MyCompWithExtends(Component):\n    template = \"\"\"{% extends \"abc.html\" %}\"\"\"\n\n@register(\"my_comp_include\")\nclass MyCompWithInclude(Component):\n    template = \"\"\"{% include \"abc.html\" %}\"\"\"\n```\n\nThen you can set slot fill for the slot imported via `include/extends`:\n\n```django\n{% component \"my_comp_extends\" %}\n    {% fill \"body\" %}\n        123\n    {% endfill %}\n{% endcomponent %}\n```\n\nAnd it will render:\n```html\n&lt;div&gt;\n  hello\n  123\n&lt;/div&gt;\n```\n</code></pre> </li> <li> <p>Slot and block</p> <p>So if you have a template <code>abc.html</code> like so:</p> <pre><code>&lt;div&gt;\n  hello\n  {% block inner %}\n    1\n    {% slot \"body\" %}\n      2\n    {% endslot %}\n  {% endblock %}\n&lt;/div&gt;\n</code></pre> <p>and component <code>my_comp</code>:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template_name = \"abc.html\"\n</code></pre> <p>Then:</p> <ol> <li> <p>Since the <code>block</code> wasn't overriden, you can use the <code>body</code> slot:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"body\" %}\n        XYZ\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>And we get:</p> <pre><code>&lt;div&gt;hello 1 XYZ&lt;/div&gt;\n</code></pre> </li> <li> <p><code>blocks</code> CANNOT be overriden through the <code>component</code> tag, so something like this:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"body\" %}\n        XYZ\n    {% endfill %}\n{% endcomponent %}\n{% block \"inner\" %}\n    456\n{% endblock %}\n</code></pre> <p>Will still render the component content just the same:</p> <pre><code>&lt;div&gt;hello 1 XYZ&lt;/div&gt;\n</code></pre> </li> <li> <p>You CAN override the <code>block</code> tags of <code>abc.html</code> if my component template     uses <code>extends</code>. In that case, just as you would expect, the <code>block inner</code> inside     <code>abc.html</code> will render <code>OVERRIDEN</code>:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\ntemplate_name = \"\"\"\n{% extends \"abc.html\" %}\n\n            {% block inner %}\n                OVERRIDEN\n            {% endblock %}\n        \"\"\"\n    ```\n</code></pre> </li> <li> <p>This is where it gets interesting (but still intuitive). You can insert even     new <code>slots</code> inside these \"overriding\" blocks:</p> <pre><code>@register(\"my_comp\")\nclass MyComp(Component):\n    template_name = \"\"\"\n        {% extends \"abc.html\" %}\n\n        {% load component_tags %}\n        {% block \"inner\" %}\n            OVERRIDEN\n            {% slot \"new_slot\" %}\n                hello\n            {% endslot %}\n        {% endblock %}\n    \"\"\"\n</code></pre> <p>And you can then pass fill for this <code>new_slot</code> when rendering the component:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"new_slot\" %}\n        XYZ\n    {% endfill %}\n{% endcomponent %}\n</code></pre> <p>NOTE: Currently you can supply fills for both <code>new_slot</code> and <code>body</code> slots, and you will not get an error for an invalid/unknown slot name. But since <code>body</code> slot is not rendered, it just won't do anything. So this renders the same as above:</p> <pre><code>{% component \"my_comp\" %}\n    {% fill \"new_slot\" %}\n        XYZ\n    {% endfill %}\n    {% fill \"body\" %}\n        www\n    {% endfill %}\n{% endcomponent %}\n</code></pre> </li> </ol> </li> </ol>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> django_components</li> <li> app_settings</li> <li> apps</li> <li> attributes</li> <li> autodiscovery</li> <li> component</li> <li> component_media</li> <li> component_registry</li> <li> components<ul> <li> dynamic</li> </ul> </li> <li> context</li> <li> dependencies</li> <li> expression</li> <li> finders</li> <li> library</li> <li> management<ul> <li> commands</li> <li> startcomponent</li> <li> upgradecomponent</li> </ul> </li> <li> middleware</li> <li> node</li> <li> provide</li> <li> slots</li> <li> tag_formatter</li> <li> template</li> <li> template_loader</li> <li> template_parser</li> <li> templatetags<ul> <li> component_tags</li> </ul> </li> <li> types</li> <li> urls</li> <li> util<ul> <li> cache</li> <li> html</li> <li> loader</li> <li> logger</li> <li> misc</li> <li> nanoid</li> <li> tag_parser</li> <li> types</li> <li> validation</li> </ul> </li> <li> django_components_js</li> <li> build</li> <li> docs</li> <li> scripts<ul> <li> reference</li> </ul> </li> </ul>"},{"location":"reference/django_components/","title":"Index","text":""},{"location":"reference/django_components/#django_components","title":"django_components","text":"<p>Main package for Django Components.</p> <p>Modules:</p> <ul> <li> <code>app_settings</code>           \u2013            </li> <li> <code>attributes</code>           \u2013            </li> <li> <code>autodiscovery</code>           \u2013            </li> <li> <code>component</code>           \u2013            </li> <li> <code>component_media</code>           \u2013            </li> <li> <code>component_registry</code>           \u2013            </li> <li> <code>components</code>           \u2013            </li> <li> <code>context</code>           \u2013            <p>This file centralizes various ways we use Django's Context class</p> </li> <li> <code>dependencies</code>           \u2013            <p>All code related to management of component dependencies (JS and CSS scripts)</p> </li> <li> <code>expression</code>           \u2013            </li> <li> <code>finders</code>           \u2013            </li> <li> <code>library</code>           \u2013            <p>Module for interfacing with Django's Library (<code>django.template.library</code>)</p> </li> <li> <code>management</code>           \u2013            </li> <li> <code>middleware</code>           \u2013            </li> <li> <code>node</code>           \u2013            </li> <li> <code>provide</code>           \u2013            </li> <li> <code>slots</code>           \u2013            </li> <li> <code>tag_formatter</code>           \u2013            </li> <li> <code>template</code>           \u2013            </li> <li> <code>template_loader</code>           \u2013            <p>Template loader that loads templates from each Django app's \"components\" directory.</p> </li> <li> <code>template_parser</code>           \u2013            <p>Overrides for the Django Template system to allow finer control over template parsing.</p> </li> <li> <code>templatetags</code>           \u2013            </li> <li> <code>types</code>           \u2013            <p>Helper types for IDEs.</p> </li> <li> <code>util</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>AlreadyRegistered</code>           \u2013            <p>Raised when you try to register a Component,</p> </li> <li> <code>Component</code>           \u2013            </li> <li> <code>ComponentFileEntry</code>           \u2013            <p>Result returned by <code>get_component_files()</code>.</p> </li> <li> <code>ComponentFormatter</code>           \u2013            <p>The original django_component's component tag formatter, it uses the <code>{% component %}</code></p> </li> <li> <code>ComponentRegistry</code>           \u2013            <p>Manages components and makes them available</p> </li> <li> <code>ComponentVars</code>           \u2013            <p>Type for the variables available inside the component templates.</p> </li> <li> <code>ComponentView</code>           \u2013            <p>Subclass of <code>django.views.View</code> where the <code>Component</code> instance is available</p> </li> <li> <code>ComponentsSettings</code>           \u2013            <p>Settings available for django_components.</p> </li> <li> <code>ContextBehavior</code>           \u2013            <p>Configure how (and whether) the context is passed to the component fills</p> </li> <li> <code>DynamicComponent</code>           \u2013            <p>This component is given a registered name or a reference to another component,</p> </li> <li> <code>EmptyDict</code>           \u2013            <p>TypedDict with no members.</p> </li> <li> <code>NotRegistered</code>           \u2013            <p>Raised when you try to access a Component,</p> </li> <li> <code>RegistrySettings</code>           \u2013            <p>Configuration for a <code>ComponentRegistry</code>.</p> </li> <li> <code>ShorthandComponentFormatter</code>           \u2013            <p>The component tag formatter that uses <code>{% &lt;name&gt; %}</code> / <code>{% end&lt;name&gt; %}</code> tags.</p> </li> <li> <code>Slot</code>           \u2013            <p>This class holds the slot content function along with related metadata.</p> </li> <li> <code>SlotRef</code>           \u2013            <p>SlotRef allows to treat a slot as a variable. The slot is rendered only once</p> </li> <li> <code>TagFormatterABC</code>           \u2013            <p>Abstract base class for defining custom tag formatters.</p> </li> <li> <code>TagProtectedError</code>           \u2013            <p>The way the <code>TagFormatter</code> works is that,</p> </li> <li> <code>TagResult</code>           \u2013            <p>The return value from <code>TagFormatter.parse()</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>autodiscover</code>             \u2013              <p>Search for all python files in</p> </li> <li> <code>cached_template</code>             \u2013              <p>Create a Template instance that will be cached as per the</p> </li> <li> <code>get_component_dirs</code>             \u2013              <p>Get directories that may contain component files.</p> </li> <li> <code>get_component_files</code>             \u2013              <p>Search for files within the component directories (as defined in</p> </li> <li> <code>import_libraries</code>             \u2013              <p>Import modules set in</p> </li> <li> <code>register</code>             \u2013              <p>Class decorator for registering a component</p> </li> <li> <code>render_dependencies</code>             \u2013              <p>Given a string that contains parts that were rendered by components,</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>EmptyTuple</code>           \u2013            <p>Tuple with no members.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            <p>The default and global component registry.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.EmptyTuple","title":"EmptyTuple  <code>module-attribute</code>","text":"<pre><code>EmptyTuple = Tuple[]\n</code></pre> <p>Tuple with no members.</p> <p>You can use this to define a Component that accepts NO positional arguments:</p> <pre><code>from django_components import Component, EmptyTuple\n\nclass Table(Component(EmptyTuple, Any, Any, Any, Any, Any))\n    ...\n</code></pre> <p>After that, when you call <code>Component.render()</code> or <code>Component.render_to_response()</code>, the <code>args</code> parameter will raise type error if <code>args</code> is anything else than an empty tuple.</p> <pre><code>Table.render(\n    args: (),\n)\n</code></pre> <p>Omitting <code>args</code> is also fine:</p> <pre><code>Table.render()\n</code></pre> <p>Other values are not allowed. This will raise an error with MyPy:</p> <pre><code>Table.render(\n    args: (\"one\", 2, \"three\"),\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry: ComponentRegistry = ComponentRegistry()\n</code></pre> <p>The default and global component registry. Use this instance to directly register or remove components:</p> <p>See Registering components.</p> <pre><code># Register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n\n# Get single\nregistry.get(\"button\")\n\n# Get all\nregistry.all()\n\n# Unregister single\nregistry.unregister(\"button\")\n\n# Unregister all\nregistry.clear()\n</code></pre>"},{"location":"reference/django_components/#django_components.AlreadyRegistered","title":"AlreadyRegistered","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when you try to register a Component, but it's already registered with given ComponentRegistry.</p>"},{"location":"reference/django_components/#django_components.Component","title":"Component","text":"<pre><code>Component(\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,\n)\n</code></pre> <p>               Bases: <code>Generic[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]</code></p> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> </li> <li> <code>get_template</code>             \u2013              <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>get_template_name</code>             \u2013              <p>Filepath to the Django template associated with this component.</p> </li> <li> <code>inject</code>             \u2013              <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag</p> </li> <li> <code>on_render_after</code>             \u2013              <p>Hook that runs just after the component's template was rendered.</p> </li> <li> <code>on_render_before</code>             \u2013              <p>Hook that runs just before the component's template is rendered.</p> </li> <li> <code>render</code>             \u2013              <p>Render the component into a string.</p> </li> <li> <code>render_to_response</code>             \u2013              <p>Render the component and wrap the content in the response class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Media</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined CSS associated with this component.</p> </li> <li> <code>input</code>               (<code>RenderInput[ArgsType, KwargsType, SlotsType]</code>)           \u2013            <p>Input holds the data (like arg, kwargs, slots) that were passsed to</p> </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            <p>Dictionary describing which slots have or have not been filled.</p> </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined JS associated with this component.</p> </li> <li> <code>media</code>               (<code>Media</code>)           \u2013            <p>Normalized definition of JS and CSS media files associated with this component.</p> </li> <li> <code>response_class</code>           \u2013            <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p> </li> <li> <code>template</code>               (<code>Optional[Union[str, Template]]</code>)           \u2013            <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Filepath to the Django template associated with this component.</p> </li> </ul> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,  # noqa F811\n):\n    # When user first instantiates the component class before calling\n    # `render` or `render_to_response`, then we want to allow the render\n    # function to make use of the instantiated object.\n    #\n    # So while `MyComp.render()` creates a new instance of MyComp internally,\n    # if we do `MyComp(registered_name=\"abc\").render()`, then we use the\n    # already-instantiated object.\n    #\n    # To achieve that, we want to re-assign the class methods as instance methods.\n    # For that we have to \"unwrap\" the class methods via __func__.\n    # See https://stackoverflow.com/a/76706399/9788634\n    self.render_to_response = types.MethodType(self.__class__.render_to_response.__func__, self)  # type: ignore\n    self.render = types.MethodType(self.__class__.render.__func__, self)  # type: ignore\n    self.as_view = types.MethodType(self.__class__.as_view.__func__, self)  # type: ignore\n\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.component_id = component_id or gen_id()\n    self.registry = registry or registry_\n    self._render_stack: Deque[RenderStackItem[ArgsType, KwargsType, SlotsType]] = deque()\n    # None == uninitialized, False == No types, Tuple == types\n    self._types: Optional[Union[Tuple[Any, Any, Any, Any, Any, Any], Literal[False]]] = None\n</code></pre>"},{"location":"reference/django_components/#django_components.Component.Media","title":"Media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Media = ComponentMediaInput\n</code></pre> <p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/#django_components.Component.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>Inlined CSS associated with this component.</p>"},{"location":"reference/django_components/#django_components.Component.input","title":"input  <code>property</code>","text":"<pre><code>input: RenderInput[ArgsType, KwargsType, SlotsType]\n</code></pre> <p>Input holds the data (like arg, kwargs, slots) that were passsed to the current execution of the <code>render</code> method.</p>"},{"location":"reference/django_components/#django_components.Component.is_filled","title":"is_filled  <code>property</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within the template as <code>{{ component_vars.is_filled.slot_name }}</code>, and within <code>on_render_before</code> and <code>on_render_after</code> hooks.</p>"},{"location":"reference/django_components/#django_components.Component.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>Inlined JS associated with this component.</p>"},{"location":"reference/django_components/#django_components.Component.media","title":"media  <code>instance-attribute</code>","text":"<pre><code>media: Media\n</code></pre> <p>Normalized definition of JS and CSS media files associated with this component.</p> <p>NOTE: This field is generated from Component.Media class.</p>"},{"location":"reference/django_components/#django_components.Component.response_class","title":"response_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>response_class = HttpResponse\n</code></pre> <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p>"},{"location":"reference/django_components/#django_components.Component.template","title":"template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template: Optional[Union[str, Template]] = None\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/#django_components.Component.template_name","title":"template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = None\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/#django_components.Component.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef as_view(cls, **initkwargs: Any) -&gt; ViewFn:\n    \"\"\"\n    Shortcut for calling `Component.View.as_view` and passing component instance to it.\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    # Allow the View class to access this component via `self.component`\n    return comp.View.as_view(**initkwargs, component=comp)\n</code></pre>"},{"location":"reference/django_components/#django_components.Component.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template(self, context: Context) -&gt; Optional[Union[str, Template]]:\n    \"\"\"\n    Inlined Django template associated with this component. Can be a plain string or a Template instance.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.Component.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template_name(self, context: Context) -&gt; Optional[str]:\n    \"\"\"\n    Filepath to the Django template associated with this component.\n\n    The filepath must be relative to either the file where the component class was defined,\n    or one of the roots of `STATIFILES_DIRS`.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.Component.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>provide</code> tag with given key was NOT found.</p> <p>This method mut be used inside the <code>get_context_data()</code> method and raises an error if called elsewhere.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"provider\" hello=\"world\" %}\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ data.hello }}!\"\n    def get_context_data(self):\n        data = self.inject(\"provider\")\n        return {\"data\": data}\n</code></pre></p> <p>This renders into: <pre><code>hi world!\n</code></pre></p> <p>As the <code>{{ data.hello }}</code> is taken from the \"provider\".</p> Source code in <code>src/django_components/component.py</code> <pre><code>def inject(self, key: str, default: Optional[Any] = None) -&gt; Any:\n    \"\"\"\n    Use this method to retrieve the data that was passed to a `{% provide %}` tag\n    with the corresponding key.\n\n    To retrieve the data, `inject()` must be called inside a component that's\n    inside the `{% provide %}` tag.\n\n    You may also pass a default that will be used if the `provide` tag with given\n    key was NOT found.\n\n    This method mut be used inside the `get_context_data()` method and raises\n    an error if called elsewhere.\n\n    Example:\n\n    Given this template:\n    ```django\n    {% provide \"provider\" hello=\"world\" %}\n        {% component \"my_comp\" %}\n        {% endcomponent %}\n    {% endprovide %}\n    ```\n\n    And given this definition of \"my_comp\" component:\n    ```py\n    from django_components import Component, register\n\n    @register(\"my_comp\")\n    class MyComp(Component):\n        template = \"hi {{ data.hello }}!\"\n        def get_context_data(self):\n            data = self.inject(\"provider\")\n            return {\"data\": data}\n    ```\n\n    This renders into:\n    ```\n    hi world!\n    ```\n\n    As the `{{ data.hello }}` is taken from the \"provider\".\n    \"\"\"\n    if self.input is None:\n        raise RuntimeError(\n            f\"Method 'inject()' of component '{self.name}' was called outside of 'get_context_data()'\"\n        )\n\n    return get_injected_context_var(self.name, self.input.context, key, default)\n</code></pre>"},{"location":"reference/django_components/#django_components.Component.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Template, content: str) -&gt; Optional[SlotResult]\n</code></pre> <p>Hook that runs just after the component's template was rendered. It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_after(self, context: Context, template: Template, content: str) -&gt; Optional[SlotResult]:\n    \"\"\"\n    Hook that runs just after the component's template was rendered.\n    It receives the rendered output as the last argument.\n\n    You can use this hook to access the context or the template, but modifying\n    them won't have any effect.\n\n    To override the content that gets rendered, you can return a string or SafeString\n    from this hook.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/#django_components.Component.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Template) -&gt; None\n</code></pre> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_before(self, context: Context, template: Template) -&gt; None:\n    \"\"\"\n    Hook that runs just before the component's template is rendered.\n\n    You can use this hook to access or modify the context or the template.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/#django_components.Component.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str\n</code></pre> <p>Render the component into a string.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag. - <code>render_dependencies</code> - Set this to <code>False</code> if you want to insert the resulting HTML into another component.</p> <p>Example: <pre><code>MyComponent.render(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str:\n    \"\"\"\n    Render the component into a string.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n    - `render_dependencies` - Set this to `False` if you want to insert the resulting HTML into another component.\n\n    Example:\n    ```py\n    MyComponent.render(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n    )\n    ```\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    return comp._render(context, args, kwargs, slots, escape_slots_content, type, render_dependencies)\n</code></pre>"},{"location":"reference/django_components/#django_components.Component.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and wrap the content in the response class.</p> <p>The response class is taken from <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <p>This is the interface for the <code>django.views.View</code> class which allows us to use components as Django views with <code>component.as_view()</code>.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag.</p> <p>Any additional args and kwargs are passed to the <code>response_class</code>.</p> <p>Example: <pre><code>MyComponent.render_to_response(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n    # HttpResponse input\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render_to_response(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"\n    Render the component and wrap the content in the response class.\n\n    The response class is taken from `Component.response_class`. Defaults to `django.http.HttpResponse`.\n\n    This is the interface for the `django.views.View` class which allows us to\n    use components as Django views with `component.as_view()`.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n\n    Any additional args and kwargs are passed to the `response_class`.\n\n    Example:\n    ```py\n    MyComponent.render_to_response(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n        # HttpResponse input\n        status=201,\n        headers={...},\n    )\n    # HttpResponse(content=..., status=201, headers=...)\n    ```\n    \"\"\"\n    content = cls.render(\n        args=args,\n        kwargs=kwargs,\n        context=context,\n        slots=slots,\n        escape_slots_content=escape_slots_content,\n        type=type,\n        render_dependencies=True,\n    )\n    return cls.response_class(content, *response_args, **response_kwargs)\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentFileEntry","title":"ComponentFileEntry","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Result returned by <code>get_component_files()</code>.</p> <p>Attributes:</p> <ul> <li> <code>dot_path</code>               (<code>str</code>)           \u2013            <p>The python import path for the module. E.g. <code>app.components.mycomp</code></p> </li> <li> <code>filepath</code>               (<code>Path</code>)           \u2013            <p>The filesystem path to the module. E.g. <code>/path/to/project/app/components/mycomp.py</code></p> </li> </ul>"},{"location":"reference/django_components/#django_components.ComponentFileEntry.dot_path","title":"dot_path  <code>instance-attribute</code>","text":"<pre><code>dot_path: str\n</code></pre> <p>The python import path for the module. E.g. <code>app.components.mycomp</code></p>"},{"location":"reference/django_components/#django_components.ComponentFileEntry.filepath","title":"filepath  <code>instance-attribute</code>","text":"<pre><code>filepath: Path\n</code></pre> <p>The filesystem path to the module. E.g. <code>/path/to/project/app/components/mycomp.py</code></p>"},{"location":"reference/django_components/#django_components.ComponentFormatter","title":"ComponentFormatter","text":"<pre><code>ComponentFormatter(tag: str)\n</code></pre> <p>               Bases: <code>TagFormatterABC</code></p> <p>The original django_component's component tag formatter, it uses the <code>{% component %}</code> and <code>{% endcomponent %}</code> tags, and the component name is given as the first positional arg.</p> <p>Example as block: <pre><code>{% component \"mycomp\" abc=123 %}\n    {% fill \"myfill\" %}\n        ...\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% component \"mycomp\" abc=123 / %}\n</code></pre></p> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>def __init__(self, tag: str):\n    self.tag = tag\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentRegistry","title":"ComponentRegistry","text":"<pre><code>ComponentRegistry(\n    library: Optional[Library] = None, settings: Optional[Union[RegistrySettings, Callable[[ComponentRegistry], RegistrySettings]]] = None\n)\n</code></pre> <p>Manages components and makes them available in the template, by default as <code>{% component %}</code> tags.</p> <pre><code>{% component \"my_comp\" key=value %}\n{% endcomponent %}\n</code></pre> <p>To enable a component to be used in a template, the component must be registered with a component registry.</p> <p>When you register a component to a registry, behind the scenes the registry automatically adds the component's template tag (e.g. <code>{% component %}</code> to the <code>Library</code>. And the opposite happens when you unregister a component - the tag is removed.</p> <p>See Registering components.</p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>, default:                   <code>None</code> )           \u2013            <p>Django            <code>Library</code>            associated with this registry. If omitted, the default Library instance from django_components is used.</p> </li> <li> <code>settings</code>               (<code>Union[RegistrySettings, Callable[[ComponentRegistry], RegistrySettings]]</code>, default:                   <code>None</code> )           \u2013            <p>Configure            how the components registered with this registry will behave when rendered.            See <code>RegistrySettings</code>. Can be either            a static value or a callable that returns the settings. If omitted, the settings from            <code>COMPONENTS</code> are used.</p> </li> </ul> <p>Notes:</p> <ul> <li>The default registry is available as <code>django_components.registry</code>.</li> <li>The default registry is used when registering components with <code>@register</code> decorator.</li> </ul> <p>Example:</p> <pre><code># Use with default Library\nregistry = ComponentRegistry()\n\n# Or a custom one\nmy_lib = Library()\nregistry = ComponentRegistry(library=my_lib)\n\n# Usage\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\nregistry.all()\nregistry.clear()\nregistry.get()\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentRegistry--using-registry-to-share-components","title":"Using registry to share components","text":"<p>You can use component registry for isolating or \"packaging\" components:</p> <ol> <li> <p>Create new instance of <code>ComponentRegistry</code> and Library:     <pre><code>my_comps = Library()\nmy_comps_reg = ComponentRegistry(library=my_comps)\n</code></pre></p> </li> <li> <p>Register components to the registry:     <pre><code>my_comps_reg.register(\"my_button\", ButtonComponent)\nmy_comps_reg.register(\"my_card\", CardComponent)\n</code></pre></p> </li> <li> <p>In your target project, load the Library associated with the registry:     <pre><code>{% load my_comps %}\n</code></pre></p> </li> <li> <p>Use the registered components in your templates:     <pre><code>{% component \"button\" %}\n{% endcomponent %}\n</code></pre></p> </li> </ol> <p>Methods:</p> <ul> <li> <code>all</code>             \u2013              <p>Retrieve all registered <code>Component</code> classes.</p> </li> <li> <code>clear</code>             \u2013              <p>Clears the registry, unregistering all components.</p> </li> <li> <code>get</code>             \u2013              <p>Retrieve a <code>Component</code></p> </li> <li> <code>register</code>             \u2013              <p>Register a <code>Component</code> class</p> </li> <li> <code>unregister</code>             \u2013              <p>Unregister the <code>Component</code> class</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            <p>The template tag <code>Library</code></p> </li> <li> <code>settings</code>               (<code>InternalRegistrySettings</code>)           \u2013            <p>Registry settings configured for this registry.</p> </li> </ul> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def __init__(\n    self,\n    library: Optional[Library] = None,\n    settings: Optional[Union[RegistrySettings, Callable[[\"ComponentRegistry\"], RegistrySettings]]] = None,\n) -&gt; None:\n    self._registry: Dict[str, ComponentRegistryEntry] = {}  # component name -&gt; component_entry mapping\n    self._tags: Dict[str, Set[str]] = {}  # tag -&gt; list[component names]\n    self._library = library\n    self._settings_input = settings\n    self._settings: Optional[Callable[[], InternalRegistrySettings]] = None\n\n    all_registries.append(self)\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentRegistry.library","title":"library  <code>property</code>","text":"<pre><code>library: Library\n</code></pre> <p>The template tag <code>Library</code> that is associated with the registry.</p>"},{"location":"reference/django_components/#django_components.ComponentRegistry.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: InternalRegistrySettings\n</code></pre> <p>Registry settings configured for this registry.</p>"},{"location":"reference/django_components/#django_components.ComponentRegistry.all","title":"all","text":"<pre><code>all() -&gt; Dict[str, Type[Component]]\n</code></pre> <p>Retrieve all registered <code>Component</code> classes.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Type[Component]]</code>           \u2013            <p>Dict[str, Type[Component]]: A dictionary of component names to component classes</p> </li> </ul> <p>Example:</p> <pre><code># First register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n# Then get all\nregistry.all()\n# &gt; {\n# &gt;   \"button\": ButtonComponent,\n# &gt;   \"card\": CardComponent,\n# &gt; }\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def all(self) -&gt; Dict[str, Type[\"Component\"]]:\n    \"\"\"\n    Retrieve all registered [`Component`](../api#django_components.Component) classes.\n\n    Returns:\n        Dict[str, Type[Component]]: A dictionary of component names to component classes\n\n    **Example:**\n\n    ```python\n    # First register components\n    registry.register(\"button\", ButtonComponent)\n    registry.register(\"card\", CardComponent)\n    # Then get all\n    registry.all()\n    # &gt; {\n    # &gt;   \"button\": ButtonComponent,\n    # &gt;   \"card\": CardComponent,\n    # &gt; }\n    ```\n    \"\"\"\n    comps = {key: entry.cls for key, entry in self._registry.items()}\n    return comps\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentRegistry.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clears the registry, unregistering all components.</p> <p>Example:</p> <pre><code># First register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n# Then clear\nregistry.clear()\n# Then get all\nregistry.all()\n# &gt; {}\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Clears the registry, unregistering all components.\n\n    Example:\n\n    ```python\n    # First register components\n    registry.register(\"button\", ButtonComponent)\n    registry.register(\"card\", CardComponent)\n    # Then clear\n    registry.clear()\n    # Then get all\n    registry.all()\n    # &gt; {}\n    ```\n    \"\"\"\n    all_comp_names = list(self._registry.keys())\n    for comp_name in all_comp_names:\n        self.unregister(comp_name)\n\n    self._registry = {}\n    self._tags = {}\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentRegistry.get","title":"get","text":"<pre><code>get(name: str) -&gt; Type[Component]\n</code></pre> <p>Retrieve a <code>Component</code> class registered under the given name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component was registered. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Type[Component]</code>           \u2013            <p>Type[Component]: The component class registered under the given name.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>NotRegistered</code>   if the given name is not registered.</li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then get\nregistry.get(\"button\")\n# &gt; ButtonComponent\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def get(self, name: str) -&gt; Type[\"Component\"]:\n    \"\"\"\n    Retrieve a [`Component`](../api#django_components.Component)\n    class registered under the given name.\n\n    Args:\n        name (str): The name under which the component was registered. Required.\n\n    Returns:\n        Type[Component]: The component class registered under the given name.\n\n    **Raises:**\n\n    - [`NotRegistered`](../exceptions#django_components.NotRegistered)\n      if the given name is not registered.\n\n    **Example:**\n\n    ```python\n    # First register component\n    registry.register(\"button\", ButtonComponent)\n    # Then get\n    registry.get(\"button\")\n    # &gt; ButtonComponent\n    ```\n    \"\"\"\n    if name not in self._registry:\n        raise NotRegistered('The component \"%s\" is not registered' % name)\n\n    return self._registry[name].cls\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentRegistry.register","title":"register","text":"<pre><code>register(name: str, component: Type[Component]) -&gt; None\n</code></pre> <p>Register a <code>Component</code> class with this registry under the given name.</p> <p>A component MUST be registered before it can be used in a template such as: <pre><code>{% component \"my_comp\" %}\n{% endcomponent %}\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component will be registered. Required.</p> </li> <li> <code>component</code>               (<code>Type[Component]</code>)           \u2013            <p>The component class to register. Required.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>AlreadyRegistered</code> if a different component was already registered under the same name.</li> </ul> <p>Example:</p> <pre><code>registry.register(\"button\", ButtonComponent)\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def register(self, name: str, component: Type[\"Component\"]) -&gt; None:\n    \"\"\"\n    Register a [`Component`](../api#django_components.Component) class\n    with this registry under the given name.\n\n    A component MUST be registered before it can be used in a template such as:\n    ```django\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n    ```\n\n    Args:\n        name (str): The name under which the component will be registered. Required.\n        component (Type[Component]): The component class to register. Required.\n\n    **Raises:**\n\n    - [`AlreadyRegistered`](../exceptions#django_components.AlreadyRegistered)\n    if a different component was already registered under the same name.\n\n    **Example:**\n\n    ```python\n    registry.register(\"button\", ButtonComponent)\n    ```\n    \"\"\"\n    existing_component = self._registry.get(name)\n    if existing_component and existing_component.cls._class_hash != component._class_hash:\n        raise AlreadyRegistered('The component \"%s\" has already been registered' % name)\n\n    entry = self._register_to_library(name, component)\n\n    # Keep track of which components use which tags, because multiple components may\n    # use the same tag.\n    tag = entry.tag\n    if tag not in self._tags:\n        self._tags[tag] = set()\n    self._tags[tag].add(name)\n\n    self._registry[name] = entry\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentRegistry.unregister","title":"unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Unregister the <code>Component</code> class that was registered under the given name.</p> <p>Once a component is unregistered, it is no longer available in the templates.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component is registered. Required.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>NotRegistered</code> if the given name is not registered.</li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then unregister\nregistry.unregister(\"button\")\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def unregister(self, name: str) -&gt; None:\n    \"\"\"\n    Unregister the [`Component`](../api#django_components.Component) class\n    that was registered under the given name.\n\n    Once a component is unregistered, it is no longer available in the templates.\n\n    Args:\n        name (str): The name under which the component is registered. Required.\n\n    **Raises:**\n\n    - [`NotRegistered`](../exceptions#django_components.NotRegistered)\n    if the given name is not registered.\n\n    **Example:**\n\n    ```python\n    # First register component\n    registry.register(\"button\", ButtonComponent)\n    # Then unregister\n    registry.unregister(\"button\")\n    ```\n    \"\"\"\n    # Validate\n    self.get(name)\n\n    entry = self._registry[name]\n    tag = entry.tag\n\n    # Unregister the tag from library if this was the last component using this tag\n    # Unlink component from tag\n    self._tags[tag].remove(name)\n\n    # Cleanup\n    is_tag_empty = not len(self._tags[tag])\n    if is_tag_empty:\n        del self._tags[tag]\n\n    # Only unregister a tag if it's NOT protected\n    is_protected = is_tag_protected(self.library, tag)\n    if not is_protected:\n        # Unregister the tag from library if this was the last component using this tag\n        if is_tag_empty and tag in self.library.tags:\n            del self.library.tags[tag]\n\n    del self._registry[name]\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentVars","title":"ComponentVars","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Type for the variables available inside the component templates.</p> <p>All variables here are scoped under <code>component_vars.</code>, so e.g. attribute <code>is_filled</code> on this class is accessible inside the template as:</p> <pre><code>{{ component_vars.is_filled }}\n</code></pre> <p>Attributes:</p> <ul> <li> <code>is_filled</code>               (<code>Dict[str, bool]</code>)           \u2013            <p>Dictonary describing which component slots are filled (<code>True</code>) or are not (<code>False</code>).</p> </li> </ul>"},{"location":"reference/django_components/#django_components.ComponentVars.is_filled","title":"is_filled  <code>instance-attribute</code>","text":"<pre><code>is_filled: Dict[str, bool]\n</code></pre> <p>Dictonary describing which component slots are filled (<code>True</code>) or are not (<code>False</code>).</p> <p>New in version 0.70</p> <p>Use as <code>{{ component_vars.is_filled }}</code></p> <p>Example:</p> <pre><code>{# Render wrapping HTML only if the slot is defined #}\n{% if component_vars.is_filled.my_slot %}\n    &lt;div class=\"slot-wrapper\"&gt;\n        {% slot \"my_slot\" / %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentView","title":"ComponentView","text":"<pre><code>ComponentView(component: Component, **kwargs: Any)\n</code></pre> <p>               Bases: <code>View</code></p> <p>Subclass of <code>django.views.View</code> where the <code>Component</code> instance is available via <code>self.component</code>.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(self, component: \"Component\", **kwargs: Any) -&gt; None:\n    super().__init__(**kwargs)\n    self.component = component\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentsSettings","title":"ComponentsSettings","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Settings available for django_components.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n    dirs = [BASE_DIR / \"components\"],\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>app_dirs</code>               (<code>Optional[Sequence[str]]</code>)           \u2013            <p>Specify the app-level directories that contain your components.</p> </li> <li> <code>autodiscover</code>               (<code>Optional[bool]</code>)           \u2013            <p>Toggle whether to run autodiscovery at the Django server startup.</p> </li> <li> <code>context_behavior</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            <p>Configure whether, inside a component template, you can use variables from the outside</p> </li> <li> <code>dirs</code>               (<code>Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]]</code>)           \u2013            <p>Specify the directories that contain your components.</p> </li> <li> <code>dynamic_component_name</code>               (<code>Optional[str]</code>)           \u2013            <p>By default, the dynamic component</p> </li> <li> <code>forbidden_static_files</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            <p>Deprecated. Use</p> </li> <li> <code>libraries</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Configure extra python modules that should be loaded.</p> </li> <li> <code>multiline_tags</code>               (<code>Optional[bool]</code>)           \u2013            <p>Enable / disable</p> </li> <li> <code>reload_on_file_change</code>               (<code>Optional[bool]</code>)           \u2013            <p>This is relevant if you are using the project structure where</p> </li> <li> <code>reload_on_template_change</code>               (<code>Optional[bool]</code>)           \u2013            <p>Deprecated. Use</p> </li> <li> <code>static_files_allowed</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            <p>A list of file extensions (including the leading dot) that define which files within</p> </li> <li> <code>static_files_forbidden</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            <p>A list of file extensions (including the leading dot) that define which files within</p> </li> <li> <code>tag_formatter</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            <p>Configure what syntax is used inside Django templates to render components.</p> </li> <li> <code>template_cache_size</code>               (<code>Optional[int]</code>)           \u2013            <p>Configure the maximum amount of Django templates to be cached.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.ComponentsSettings.app_dirs","title":"app_dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>app_dirs: Optional[Sequence[str]] = None\n</code></pre> <p>Specify the app-level directories that contain your components.</p> <p>Defaults to <code>[\"components\"]</code>. That is, for each Django app, we search <code>&lt;app&gt;/components/</code> for components.</p> <p>The paths must be relative to app, e.g.:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[\"my_comps\"],\n)\n</code></pre> <p>To search for <code>&lt;app&gt;/my_comps/</code>.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <p>Set to empty list to disable app-level components:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[],\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentsSettings.autodiscover","title":"autodiscover  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>autodiscover: Optional[bool] = None\n</code></pre> <p>Toggle whether to run autodiscovery at the Django server startup.</p> <p>Defaults to <code>True</code></p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentsSettings.context_behavior","title":"context_behavior  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>Configure whether, inside a component template, you can use variables from the outside (<code>\"django\"</code>) or not (<code>\"isolated\"</code>). This also affects what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Defaults to <code>\"django\"</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    context_behavior=\"isolated\",\n)\n</code></pre> <p>NOTE: <code>context_behavior</code> and <code>slot_context_behavior</code> options were merged in v0.70.</p> <p>If you are migrating from BEFORE v0.67, set <code>context_behavior</code> to <code>\"django\"</code>. From v0.67 to v0.78 (incl) the default value was <code>\"isolated\"</code>.</p> <p>For v0.79 and later, the default is again <code>\"django\"</code>. See the rationale for change here.</p>"},{"location":"reference/django_components/#django_components.ComponentsSettings.dirs","title":"dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirs: Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]] = None\n</code></pre> <p>Specify the directories that contain your components.</p> <p>Defaults to <code>[Path(settings.BASE_DIR) / \"components\"]</code>. That is, the root <code>components/</code> app.</p> <p>Directories must be full paths, same as with STATICFILES_DIRS.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[BASE_DIR / \"components\"],\n)\n</code></pre> <p>Set to empty list to disable global components directories:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[],\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentsSettings.dynamic_component_name","title":"dynamic_component_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dynamic_component_name: Optional[str] = None\n</code></pre> <p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>.</p> <p>In case of a conflict, you can use this setting to change the component name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name:</p> <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentsSettings.forbidden_static_files","title":"forbidden_static_files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>forbidden_static_files: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>Deprecated. Use <code>COMPONENTS.static_files_forbidden</code> instead.</p>"},{"location":"reference/django_components/#django_components.ComponentsSettings.libraries","title":"libraries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>libraries: Optional[List[str]] = None\n</code></pre> <p>Configure extra python modules that should be loaded.</p> <p>This may be useful if you are not using the autodiscovery feature, or you need to load components from non-standard locations. Thus you can have a structure of components that is independent from your apps.</p> <p>Expects a list of python module paths. Defaults to empty list.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    libraries=[\n        \"mysite.components.forms\",\n        \"mysite.components.buttons\",\n        \"mysite.components.cards\",\n    ],\n)\n</code></pre> <p>This would be the equivalent of importing these modules from within Django's <code>AppConfig.ready()</code>:</p> <pre><code>class MyAppConfig(AppConfig):\n    def ready(self):\n        import \"mysite.components.forms\"\n        import \"mysite.components.buttons\"\n        import \"mysite.components.cards\"\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentsSettings.libraries--manually-loading-libraries","title":"Manually loading libraries","text":"<p>In the rare case that you need to manually trigger the import of libraries, you can use the <code>import_libraries()</code> function:</p> <pre><code>from django_components import import_libraries\n\nimport_libraries()\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentsSettings.multiline_tags","title":"multiline_tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>multiline_tags: Optional[bool] = None\n</code></pre> <p>Enable / disable multiline support for template tags. If <code>True</code>, template tags like <code>{% component %}</code> or <code>{{ my_var }}</code> can span multiple lines.</p> <p>Defaults to <code>True</code>.</p> <p>Disable this setting if you are making custom modifications to Django's regular expression for parsing templates at <code>django.template.base.tag_re</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    multiline_tags=False,\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.ComponentsSettings.reload_on_file_change","title":"reload_on_file_change  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reload_on_file_change: Optional[bool] = None\n</code></pre> <p>This is relevant if you are using the project structure where HTML, JS, CSS and Python are in separate files and nested in a directory.</p> <p>In this case you may notice that when you are running a development server, the server sometimes does not reload when you change component files.</p> <p>Django's native live reload logic handles only Python files and HTML template files. It does NOT reload when other file types change or when template files are nested more than one level deep.</p> <p>The setting <code>reload_on_file_change</code> fixes this, reloading the dev server even when your component's HTML, JS, or CSS changes.</p> <p>If <code>True</code>, django_components configures Django to reload when files inside <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> change.</p> <p>See Reload dev server on component file changes.</p> <p>Defaults to <code>False</code>.</p> <p>Warning</p> <p>This setting should be enabled only for the dev environment!</p>"},{"location":"reference/django_components/#django_components.ComponentsSettings.reload_on_template_change","title":"reload_on_template_change  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reload_on_template_change: Optional[bool] = None\n</code></pre> <p>Deprecated. Use <code>COMPONENTS.reload_on_file_change</code> instead.</p>"},{"location":"reference/django_components/#django_components.ComponentsSettings.static_files_allowed","title":"static_files_allowed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>static_files_allowed: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> are treated as static files.</p> <p>If a file is matched against any of the patterns, it's considered a static file. Such files are collected when running <code>collectstatic</code>, and can be accessed under the static file endpoint.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, JS, CSS, and common image and font file formats are considered static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_allowed=[\n        \".css\",\n        \".js\", \".jsx\", \".ts\", \".tsx\",\n        # Images\n        \".apng\", \".png\", \".avif\", \".gif\", \".jpg\",\n        \".jpeg\",  \".jfif\", \".pjpeg\", \".pjp\", \".svg\",\n        \".webp\", \".bmp\", \".ico\", \".cur\", \".tif\", \".tiff\",\n        # Fonts\n        \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/django_components/#django_components.ComponentsSettings.static_files_forbidden","title":"static_files_forbidden  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>static_files_forbidden: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> will NEVER be treated as static files.</p> <p>If a file is matched against any of the patterns, it will never be considered a static file, even if the file matches a pattern in <code>static_files_allowed</code>.</p> <p>Use this setting together with <code>static_files_allowed</code> for a fine control over what file types will be exposed.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, any HTML and Python are considered NOT static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_forbidden=[\n        \".html\", \".django\", \".dj\", \".tpl\",\n        # Python files\n        \".py\", \".pyc\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/django_components/#django_components.ComponentsSettings.tag_formatter","title":"tag_formatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>Configure what syntax is used inside Django templates to render components. See the available tag formatters.</p> <p>Defaults to <code>\"django_components.component_formatter\"</code>.</p> <p>Learn more about Customizing component tags with TagFormatter.</p> <p>Can be set either as direct reference:</p> <pre><code>from django_components import component_formatter\n\nCOMPONENTS = ComponentsSettings(\n    \"tag_formatter\": component_formatter\n)\n</code></pre> <p>Or as an import string;</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>Examples:</p> <ul> <li> <p><code>\"django_components.component_formatter\"</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% component \"button\" href=\"...\" %}\n    Click me!\n{% endcomponent %}\n</code></pre> </li> <li> <p><code>django_components.component_shorthand_formatter</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% button href=\"...\" %}\n    Click me!\n{% endbutton %}\n</code></pre> </li> </ul>"},{"location":"reference/django_components/#django_components.ComponentsSettings.template_cache_size","title":"template_cache_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_cache_size: Optional[int] = None\n</code></pre> <p>Configure the maximum amount of Django templates to be cached.</p> <p>Defaults to <code>128</code>.</p> <p>Each time a Django template is rendered, it is cached to a global in-memory cache (using Python's <code>lru_cache</code> decorator). This speeds up the next render of the component. As the same component is often used many times on the same page, these savings add up.</p> <p>By default the cache holds 128 component templates in memory, which should be enough for most sites. But if you have a lot of components, or if you are overriding <code>Component.get_template()</code> to render many dynamic templates, you can increase this number.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=256,\n)\n</code></pre> <p>To remove the cache limit altogether and cache everything, set <code>template_cache_size</code> to <code>None</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=None,\n)\n</code></pre> <p>If you want to add templates to the cache yourself, you can use <code>cached_template()</code>:</p> <pre><code>from django_components import cached_template\n\ncached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ncached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.ContextBehavior","title":"ContextBehavior","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Configure how (and whether) the context is passed to the component fills and what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Options:</p> <ul> <li><code>django</code>: With this setting, component fills behave as usual Django tags.</li> <li><code>isolated</code>: This setting makes the component fills behave similar to Vue or React.</li> </ul> <p>Attributes:</p> <ul> <li> <code>DJANGO</code>           \u2013            <p>With this setting, component fills behave as usual Django tags.</p> </li> <li> <code>ISOLATED</code>           \u2013            <p>This setting makes the component fills behave similar to Vue or React, where</p> </li> </ul>"},{"location":"reference/django_components/#django_components.ContextBehavior.DJANGO","title":"DJANGO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DJANGO = 'django'\n</code></pre> <p>With this setting, component fills behave as usual Django tags. That is, they enrich the context, and pass it along.</p> <ol> <li>Component fills use the context of the component they are within.</li> <li>Variables from <code>Component.get_context_data()</code> are available to the component fill.</li> </ol> <p>Example:</p> <p>Given this template <pre><code>{% with cheese=\"feta\" %}\n  {% component 'my_comp' %}\n    {{ my_var }}  # my_var\n    {{ cheese }}  # cheese\n  {% endcomponent %}\n{% endwith %}\n</code></pre></p> <p>and this context returned from the <code>Component.get_context_data()</code> method <pre><code>{ \"my_var\": 123 }\n</code></pre></p> <p>Then if component \"my_comp\" defines context <pre><code>{ \"my_var\": 456 }\n</code></pre></p> <p>Then this will render: <pre><code>456   # my_var\nfeta  # cheese\n</code></pre></p> <p>Because \"my_comp\" overrides the variable \"my_var\", so <code>{{ my_var }}</code> equals <code>456</code>.</p> <p>And variable \"cheese\" will equal <code>feta</code>, because the fill CAN access the current context.</p>"},{"location":"reference/django_components/#django_components.ContextBehavior.ISOLATED","title":"ISOLATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ISOLATED = 'isolated'\n</code></pre> <p>This setting makes the component fills behave similar to Vue or React, where the fills use EXCLUSIVELY the context variables defined in <code>Component.get_context_data()</code>.</p> <p>Example:</p> <p>Given this template <pre><code>{% with cheese=\"feta\" %}\n  {% component 'my_comp' %}\n    {{ my_var }}  # my_var\n    {{ cheese }}  # cheese\n  {% endcomponent %}\n{% endwith %}\n</code></pre></p> <p>and this context returned from the <code>get_context_data()</code> method <pre><code>{ \"my_var\": 123 }\n</code></pre></p> <p>Then if component \"my_comp\" defines context <pre><code>{ \"my_var\": 456 }\n</code></pre></p> <p>Then this will render: <pre><code>123   # my_var\n      # cheese\n</code></pre></p> <p>Because both variables \"my_var\" and \"cheese\" are taken from the root context. Since \"cheese\" is not defined in root context, it's empty.</p>"},{"location":"reference/django_components/#django_components.DynamicComponent","title":"DynamicComponent","text":"<pre><code>DynamicComponent(\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>This component is given a registered name or a reference to another component, and behaves as if the other component was in its place.</p> <p>The args, kwargs, and slot fills are all passed down to the underlying component.</p> <p>Parameters:</p> <ul> <li> <code>is</code>               (<code>str | Type[Component]</code>)           \u2013            <p>Component that should be rendered. Either a registered name of a component, or a Component class directly. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to search for the registered name. If omitted, all registries are searched until the first match.</p> </li> <li> <code>*args</code>           \u2013            <p>Additional data passed to the component.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional data passed to the component.</p> </li> </ul> <p>Slots:</p> <ul> <li>Any slots, depending on the actual component.</li> </ul> <p>Examples:</p> <p>Django <pre><code>{% component \"dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Python <pre><code>from django_components import DynamicComponent\n\nDynamicComponent.render(\n    kwargs={\n        \"is\": table_comp,\n        \"data\": table_data,\n        \"headers\": table_headers,\n    },\n    slots={\n        \"pagination\": PaginationComponent.render(\n            render_dependencies=False,\n        ),\n    },\n)\n</code></pre></p>"},{"location":"reference/django_components/#django_components.DynamicComponent--use-cases","title":"Use cases","text":"<p>Dynamic components are suitable if you are writing something like a form component. You may design it such that users give you a list of input types, and you render components depending on the input types.</p> <p>While you could handle this with a series of if / else statements, that's not an extensible approach. Instead, you can use the dynamic component in place of normal components.</p>"},{"location":"reference/django_components/#django_components.DynamicComponent--component-name","title":"Component name","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can set the <code>COMPONENTS.dynamic_component_name</code> setting to change the name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name: <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> </li> <li> <code>get_template</code>             \u2013              <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>get_template_name</code>             \u2013              <p>Filepath to the Django template associated with this component.</p> </li> <li> <code>inject</code>             \u2013              <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag</p> </li> <li> <code>on_render_after</code>             \u2013              <p>Hook that runs just after the component's template was rendered.</p> </li> <li> <code>on_render_before</code>             \u2013              <p>Hook that runs just before the component's template is rendered.</p> </li> <li> <code>render</code>             \u2013              <p>Render the component into a string.</p> </li> <li> <code>render_to_response</code>             \u2013              <p>Render the component and wrap the content in the response class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Media</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined CSS associated with this component.</p> </li> <li> <code>input</code>               (<code>RenderInput[ArgsType, KwargsType, SlotsType]</code>)           \u2013            <p>Input holds the data (like arg, kwargs, slots) that were passsed to</p> </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            <p>Dictionary describing which slots have or have not been filled.</p> </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined JS associated with this component.</p> </li> <li> <code>media</code>               (<code>Media</code>)           \u2013            <p>Normalized definition of JS and CSS media files associated with this component.</p> </li> <li> <code>response_class</code>           \u2013            <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p> </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Filepath to the Django template associated with this component.</p> </li> </ul> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,  # noqa F811\n):\n    # When user first instantiates the component class before calling\n    # `render` or `render_to_response`, then we want to allow the render\n    # function to make use of the instantiated object.\n    #\n    # So while `MyComp.render()` creates a new instance of MyComp internally,\n    # if we do `MyComp(registered_name=\"abc\").render()`, then we use the\n    # already-instantiated object.\n    #\n    # To achieve that, we want to re-assign the class methods as instance methods.\n    # For that we have to \"unwrap\" the class methods via __func__.\n    # See https://stackoverflow.com/a/76706399/9788634\n    self.render_to_response = types.MethodType(self.__class__.render_to_response.__func__, self)  # type: ignore\n    self.render = types.MethodType(self.__class__.render.__func__, self)  # type: ignore\n    self.as_view = types.MethodType(self.__class__.as_view.__func__, self)  # type: ignore\n\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.component_id = component_id or gen_id()\n    self.registry = registry or registry_\n    self._render_stack: Deque[RenderStackItem[ArgsType, KwargsType, SlotsType]] = deque()\n    # None == uninitialized, False == No types, Tuple == types\n    self._types: Optional[Union[Tuple[Any, Any, Any, Any, Any, Any], Literal[False]]] = None\n</code></pre>"},{"location":"reference/django_components/#django_components.DynamicComponent.Media","title":"Media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Media = ComponentMediaInput\n</code></pre> <p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/#django_components.DynamicComponent.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>Inlined CSS associated with this component.</p>"},{"location":"reference/django_components/#django_components.DynamicComponent.input","title":"input  <code>property</code>","text":"<pre><code>input: RenderInput[ArgsType, KwargsType, SlotsType]\n</code></pre> <p>Input holds the data (like arg, kwargs, slots) that were passsed to the current execution of the <code>render</code> method.</p>"},{"location":"reference/django_components/#django_components.DynamicComponent.is_filled","title":"is_filled  <code>property</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within the template as <code>{{ component_vars.is_filled.slot_name }}</code>, and within <code>on_render_before</code> and <code>on_render_after</code> hooks.</p>"},{"location":"reference/django_components/#django_components.DynamicComponent.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>Inlined JS associated with this component.</p>"},{"location":"reference/django_components/#django_components.DynamicComponent.media","title":"media  <code>instance-attribute</code>","text":"<pre><code>media: Media\n</code></pre> <p>Normalized definition of JS and CSS media files associated with this component.</p> <p>NOTE: This field is generated from Component.Media class.</p>"},{"location":"reference/django_components/#django_components.DynamicComponent.response_class","title":"response_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>response_class = HttpResponse\n</code></pre> <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p>"},{"location":"reference/django_components/#django_components.DynamicComponent.template_name","title":"template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = None\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/#django_components.DynamicComponent.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef as_view(cls, **initkwargs: Any) -&gt; ViewFn:\n    \"\"\"\n    Shortcut for calling `Component.View.as_view` and passing component instance to it.\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    # Allow the View class to access this component via `self.component`\n    return comp.View.as_view(**initkwargs, component=comp)\n</code></pre>"},{"location":"reference/django_components/#django_components.DynamicComponent.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template(self, context: Context) -&gt; Optional[Union[str, Template]]:\n    \"\"\"\n    Inlined Django template associated with this component. Can be a plain string or a Template instance.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.DynamicComponent.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template_name(self, context: Context) -&gt; Optional[str]:\n    \"\"\"\n    Filepath to the Django template associated with this component.\n\n    The filepath must be relative to either the file where the component class was defined,\n    or one of the roots of `STATIFILES_DIRS`.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.DynamicComponent.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>provide</code> tag with given key was NOT found.</p> <p>This method mut be used inside the <code>get_context_data()</code> method and raises an error if called elsewhere.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"provider\" hello=\"world\" %}\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ data.hello }}!\"\n    def get_context_data(self):\n        data = self.inject(\"provider\")\n        return {\"data\": data}\n</code></pre></p> <p>This renders into: <pre><code>hi world!\n</code></pre></p> <p>As the <code>{{ data.hello }}</code> is taken from the \"provider\".</p> Source code in <code>src/django_components/component.py</code> <pre><code>def inject(self, key: str, default: Optional[Any] = None) -&gt; Any:\n    \"\"\"\n    Use this method to retrieve the data that was passed to a `{% provide %}` tag\n    with the corresponding key.\n\n    To retrieve the data, `inject()` must be called inside a component that's\n    inside the `{% provide %}` tag.\n\n    You may also pass a default that will be used if the `provide` tag with given\n    key was NOT found.\n\n    This method mut be used inside the `get_context_data()` method and raises\n    an error if called elsewhere.\n\n    Example:\n\n    Given this template:\n    ```django\n    {% provide \"provider\" hello=\"world\" %}\n        {% component \"my_comp\" %}\n        {% endcomponent %}\n    {% endprovide %}\n    ```\n\n    And given this definition of \"my_comp\" component:\n    ```py\n    from django_components import Component, register\n\n    @register(\"my_comp\")\n    class MyComp(Component):\n        template = \"hi {{ data.hello }}!\"\n        def get_context_data(self):\n            data = self.inject(\"provider\")\n            return {\"data\": data}\n    ```\n\n    This renders into:\n    ```\n    hi world!\n    ```\n\n    As the `{{ data.hello }}` is taken from the \"provider\".\n    \"\"\"\n    if self.input is None:\n        raise RuntimeError(\n            f\"Method 'inject()' of component '{self.name}' was called outside of 'get_context_data()'\"\n        )\n\n    return get_injected_context_var(self.name, self.input.context, key, default)\n</code></pre>"},{"location":"reference/django_components/#django_components.DynamicComponent.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Template, content: str) -&gt; Optional[SlotResult]\n</code></pre> <p>Hook that runs just after the component's template was rendered. It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_after(self, context: Context, template: Template, content: str) -&gt; Optional[SlotResult]:\n    \"\"\"\n    Hook that runs just after the component's template was rendered.\n    It receives the rendered output as the last argument.\n\n    You can use this hook to access the context or the template, but modifying\n    them won't have any effect.\n\n    To override the content that gets rendered, you can return a string or SafeString\n    from this hook.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/#django_components.DynamicComponent.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Template) -&gt; None\n</code></pre> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_before(self, context: Context, template: Template) -&gt; None:\n    \"\"\"\n    Hook that runs just before the component's template is rendered.\n\n    You can use this hook to access or modify the context or the template.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/#django_components.DynamicComponent.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str\n</code></pre> <p>Render the component into a string.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag. - <code>render_dependencies</code> - Set this to <code>False</code> if you want to insert the resulting HTML into another component.</p> <p>Example: <pre><code>MyComponent.render(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str:\n    \"\"\"\n    Render the component into a string.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n    - `render_dependencies` - Set this to `False` if you want to insert the resulting HTML into another component.\n\n    Example:\n    ```py\n    MyComponent.render(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n    )\n    ```\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    return comp._render(context, args, kwargs, slots, escape_slots_content, type, render_dependencies)\n</code></pre>"},{"location":"reference/django_components/#django_components.DynamicComponent.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and wrap the content in the response class.</p> <p>The response class is taken from <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <p>This is the interface for the <code>django.views.View</code> class which allows us to use components as Django views with <code>component.as_view()</code>.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag.</p> <p>Any additional args and kwargs are passed to the <code>response_class</code>.</p> <p>Example: <pre><code>MyComponent.render_to_response(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n    # HttpResponse input\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render_to_response(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"\n    Render the component and wrap the content in the response class.\n\n    The response class is taken from `Component.response_class`. Defaults to `django.http.HttpResponse`.\n\n    This is the interface for the `django.views.View` class which allows us to\n    use components as Django views with `component.as_view()`.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n\n    Any additional args and kwargs are passed to the `response_class`.\n\n    Example:\n    ```py\n    MyComponent.render_to_response(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n        # HttpResponse input\n        status=201,\n        headers={...},\n    )\n    # HttpResponse(content=..., status=201, headers=...)\n    ```\n    \"\"\"\n    content = cls.render(\n        args=args,\n        kwargs=kwargs,\n        context=context,\n        slots=slots,\n        escape_slots_content=escape_slots_content,\n        type=type,\n        render_dependencies=True,\n    )\n    return cls.response_class(content, *response_args, **response_kwargs)\n</code></pre>"},{"location":"reference/django_components/#django_components.EmptyDict","title":"EmptyDict","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict with no members.</p> <p>You can use this to define a Component that accepts NO kwargs, or NO slots, or returns NO data from <code>Component.get_context_data()</code> / <code>Component.get_js_data()</code> / <code>Component.get_css_data()</code>:</p> <p>Accepts NO kwargs:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, EmptyDict, Any, Any, Any, Any))\n    ...\n</code></pre> <p>Accepts NO slots:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, Any, EmptyDict, Any, Any, Any))\n    ...\n</code></pre> <p>Returns NO data from <code>get_context_data()</code>:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, Any, Any, EmptyDict, Any, Any))\n    ...\n</code></pre> <p>Going back to the example with NO kwargs, when you then call <code>Component.render()</code> or <code>Component.render_to_response()</code>, the <code>kwargs</code> parameter will raise type error if <code>kwargs</code> is anything else than an empty dict.</p> <pre><code>Table.render(\n    kwargs: {},\n)\n</code></pre> <p>Omitting <code>kwargs</code> is also fine:</p> <pre><code>Table.render()\n</code></pre> <p>Other values are not allowed. This will raise an error with MyPy:</p> <pre><code>Table.render(\n    kwargs: {\n        \"one\": 2,\n        \"three\": 4,\n    },\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.NotRegistered","title":"NotRegistered","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when you try to access a Component, but it's NOT registered with given ComponentRegistry.</p>"},{"location":"reference/django_components/#django_components.RegistrySettings","title":"RegistrySettings","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Configuration for a <code>ComponentRegistry</code>.</p> <p>These settings define how the components registered with this registry will behave when rendered.</p> <pre><code>from django_components import ComponentRegistry, RegistrySettings\n\nregistry_settings = RegistrySettings(\n    context_behavior=\"django\",\n    tag_formatter=\"django_components.component_shorthand_formatter\",\n)\n\nregistry = ComponentRegistry(settings=registry_settings)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>CONTEXT_BEHAVIOR</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            <p>Deprecated. Use <code>context_behavior</code> instead. Will be removed in v1.</p> </li> <li> <code>TAG_FORMATTER</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            <p>Deprecated. Use <code>tag_formatter</code> instead. Will be removed in v1.</p> </li> <li> <code>context_behavior</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            <p>Same as the global</p> </li> <li> <code>tag_formatter</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            <p>Same as the global</p> </li> </ul>"},{"location":"reference/django_components/#django_components.RegistrySettings.CONTEXT_BEHAVIOR","title":"CONTEXT_BEHAVIOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTEXT_BEHAVIOR: Optional[ContextBehaviorType] = None\n</code></pre> <p>Deprecated. Use <code>context_behavior</code> instead. Will be removed in v1.</p> <p>Same as the global <code>COMPONENTS.context_behavior</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.context_behavior</code> setting.</p>"},{"location":"reference/django_components/#django_components.RegistrySettings.TAG_FORMATTER","title":"TAG_FORMATTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAG_FORMATTER: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>Deprecated. Use <code>tag_formatter</code> instead. Will be removed in v1.</p> <p>Same as the global <code>COMPONENTS.tag_formatter</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.tag_formatter</code> setting.</p>"},{"location":"reference/django_components/#django_components.RegistrySettings.context_behavior","title":"context_behavior  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>Same as the global <code>COMPONENTS.context_behavior</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.context_behavior</code> setting.</p>"},{"location":"reference/django_components/#django_components.RegistrySettings.tag_formatter","title":"tag_formatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>Same as the global <code>COMPONENTS.tag_formatter</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.tag_formatter</code> setting.</p>"},{"location":"reference/django_components/#django_components.ShorthandComponentFormatter","title":"ShorthandComponentFormatter","text":"<p>               Bases: <code>TagFormatterABC</code></p> <p>The component tag formatter that uses <code>{% &lt;name&gt; %}</code> / <code>{% end&lt;name&gt; %}</code> tags.</p> <p>This is similar to django-web-components and django-slippers syntax.</p> <p>Example as block: <pre><code>{% mycomp abc=123 %}\n    {% fill \"myfill\" %}\n        ...\n    {% endfill %}\n{% endmycomp %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% mycomp abc=123 / %}\n</code></pre></p>"},{"location":"reference/django_components/#django_components.Slot","title":"Slot  <code>dataclass</code>","text":"<pre><code>Slot(content_func: SlotFunc[TSlotData])\n</code></pre> <p>               Bases: <code>Generic[TSlotData]</code></p> <p>This class holds the slot content function along with related metadata.</p>"},{"location":"reference/django_components/#django_components.SlotRef","title":"SlotRef","text":"<pre><code>SlotRef(slot: SlotNode, context: Context)\n</code></pre> <p>SlotRef allows to treat a slot as a variable. The slot is rendered only once the instance is coerced to string.</p> <p>This is used to access slots as variables inside the templates. When a SlotRef is rendered in the template with <code>{{ my_lazy_slot }}</code>, it will output the contents of the slot.</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(self, slot: \"SlotNode\", context: Context):\n    self._slot = slot\n    self._context = context\n</code></pre>"},{"location":"reference/django_components/#django_components.TagFormatterABC","title":"TagFormatterABC","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for defining custom tag formatters.</p> <p>Tag formatters define how the component tags are used in the template.</p> <p>Read more about Tag formatter.</p> <p>For example, with the default tag formatter (<code>ComponentFormatter</code>), components are written as:</p> <pre><code>{% component \"comp_name\" %}\n{% endcomponent %}\n</code></pre> <p>While with the shorthand tag formatter (<code>ShorthandComponentFormatter</code>), components are written as: <pre><code>{% comp_name %}\n{% endcomp_name %}\n</code></pre></p> <p>Example:</p> <p>Implementation for <code>ShorthandComponentFormatter</code>:</p> <pre><code>from djagno_components import TagFormatterABC, TagResult\n\nclass ShorthandComponentFormatter(TagFormatterABC):\n    def start_tag(self, name: str) -&gt; str:\n        return name\n\n    def end_tag(self, name: str) -&gt; str:\n        return f\"end{name}\"\n\n    def parse(self, tokens: List[str]) -&gt; TagResult:\n        tokens = [*tokens]\n        name = tokens.pop(0)\n        return TagResult(name, tokens)\n</code></pre> <p>Methods:</p> <ul> <li> <code>end_tag</code>             \u2013              <p>Formats the end tag of a block component.</p> </li> <li> <code>parse</code>             \u2013              <p>Given the tokens (words) passed to a component start tag, this function extracts</p> </li> <li> <code>start_tag</code>             \u2013              <p>Formats the start tag of a component.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.TagFormatterABC.end_tag","title":"end_tag  <code>abstractmethod</code>","text":"<pre><code>end_tag(name: str) -&gt; str\n</code></pre> <p>Formats the end tag of a block component.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component's registered name. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The formatted end tag.</p> </li> </ul> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>@abc.abstractmethod\ndef end_tag(self, name: str) -&gt; str:\n    \"\"\"\n    Formats the end tag of a block component.\n\n    Args:\n        name (str): Component's registered name. Required.\n\n    Returns:\n        str: The formatted end tag.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/django_components/#django_components.TagFormatterABC.parse","title":"parse  <code>abstractmethod</code>","text":"<pre><code>parse(tokens: List[str]) -&gt; TagResult\n</code></pre> <p>Given the tokens (words) passed to a component start tag, this function extracts the component name from the tokens list, and returns <code>TagResult</code>, which is a tuple of <code>(component_name, remaining_tokens)</code>.</p> <p>Parameters:</p> <ul> <li> <code>tokens</code>               (<code>[List(str]</code>)           \u2013            <p>List of tokens passed to the component tag.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TagResult</code> (              <code>TagResult</code> )          \u2013            <p>Parsed component name and remaining tokens.</p> </li> </ul> <p>Example:</p> <p>Assuming we used a component in a template like this:</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n{% endcomponent %}\n</code></pre> <p>This function receives a list of tokens:</p> <pre><code>['component', '\"my_comp\"', 'key=val', 'key2=val2']\n</code></pre> <ul> <li><code>component</code> is the tag name, which we drop.</li> <li><code>\"my_comp\"</code> is the component name, but we must remove the extra quotes.</li> <li>The remaining tokens we pass unmodified, as that's the input to the component.</li> </ul> <p>So in the end, we return:</p> <pre><code>TagResult('my_comp', ['key=val', 'key2=val2'])\n</code></pre> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>@abc.abstractmethod\ndef parse(self, tokens: List[str]) -&gt; TagResult:\n    \"\"\"\n    Given the tokens (words) passed to a component start tag, this function extracts\n    the component name from the tokens list, and returns\n    [`TagResult`](../api#django_components.TagResult),\n    which is a tuple of `(component_name, remaining_tokens)`.\n\n    Args:\n        tokens [List(str]): List of tokens passed to the component tag.\n\n    Returns:\n        TagResult: Parsed component name and remaining tokens.\n\n    **Example:**\n\n    Assuming we used a component in a template like this:\n\n    ```django\n    {% component \"my_comp\" key=val key2=val2 %}\n    {% endcomponent %}\n    ```\n\n    This function receives a list of tokens:\n\n    ```python\n    ['component', '\"my_comp\"', 'key=val', 'key2=val2']\n    ```\n\n    - `component` is the tag name, which we drop.\n    - `\"my_comp\"` is the component name, but we must remove the extra quotes.\n    - The remaining tokens we pass unmodified, as that's the input to the component.\n\n    So in the end, we return:\n\n    ```python\n    TagResult('my_comp', ['key=val', 'key2=val2'])\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/django_components/#django_components.TagFormatterABC.start_tag","title":"start_tag  <code>abstractmethod</code>","text":"<pre><code>start_tag(name: str) -&gt; str\n</code></pre> <p>Formats the start tag of a component.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component's registered name. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The formatted start tag.</p> </li> </ul> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>@abc.abstractmethod\ndef start_tag(self, name: str) -&gt; str:\n    \"\"\"\n    Formats the start tag of a component.\n\n    Args:\n        name (str): Component's registered name. Required.\n\n    Returns:\n        str: The formatted start tag.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/django_components/#django_components.TagProtectedError","title":"TagProtectedError","text":"<p>               Bases: <code>Exception</code></p> <p>The way the <code>TagFormatter</code> works is that, based on which start and end tags are used for rendering components, the <code>ComponentRegistry</code> behind the scenes un-/registers the template tags with the associated instance of Django's <code>Library</code>.</p> <p>In other words, if I have registered a component <code>\"table\"</code>, and I use the shorthand syntax:</p> <pre><code>{% table ... %}\n{% endtable %}\n</code></pre> <p>Then <code>ComponentRegistry</code> registers the tag <code>table</code> onto the Django's Library instance.</p> <p>However, that means that if we registered a component <code>\"slot\"</code>, then we would overwrite the <code>{% slot %}</code> tag from django_components.</p> <p>Thus, this exception is raised when a component is attempted to be registered under a forbidden name, such that it would overwrite one of django_component's own template tags.</p>"},{"location":"reference/django_components/#django_components.TagResult","title":"TagResult","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The return value from <code>TagFormatter.parse()</code>.</p> <p>Read more about Tag formatter.</p> <p>Attributes:</p> <ul> <li> <code>component_name</code>               (<code>str</code>)           \u2013            <p>Component name extracted from the template tag</p> </li> <li> <code>tokens</code>               (<code>List[str]</code>)           \u2013            <p>Remaining tokens (words) that were passed to the tag, with component name removed</p> </li> </ul>"},{"location":"reference/django_components/#django_components.TagResult.component_name","title":"component_name  <code>instance-attribute</code>","text":"<pre><code>component_name: str\n</code></pre> <p>Component name extracted from the template tag</p> <p>For example, if we had tag</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n</code></pre> <p>Then <code>component_name</code> would be <code>my_comp</code>.</p>"},{"location":"reference/django_components/#django_components.TagResult.tokens","title":"tokens  <code>instance-attribute</code>","text":"<pre><code>tokens: List[str]\n</code></pre> <p>Remaining tokens (words) that were passed to the tag, with component name removed</p> <p>For example, if we had tag</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n</code></pre> <p>Then <code>tokens</code> would be <code>['key=val', 'key2=val2']</code>.</p>"},{"location":"reference/django_components/#django_components.autodiscover","title":"autodiscover","text":"<pre><code>autodiscover(map_module: Optional[Callable[[str], str]] = None) -&gt; List[str]\n</code></pre> <p>Search for all python files in <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code> and import them.</p> <p>See Autodiscovery.</p> <p>Parameters:</p> <ul> <li> <code>map_module</code>               (<code>Callable[[str], str]</code>, default:                   <code>None</code> )           \u2013            <p>Map the module paths with <code>map_module</code> function.        This serves as an escape hatch for when you need to use this function in tests.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of module paths of imported files.</p> </li> </ul> <p>To get the same list of modules that <code>autodiscover()</code> would return, but without importing them, use <code>get_component_files()</code>:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre> Source code in <code>src/django_components/autodiscovery.py</code> <pre><code>def autodiscover(\n    map_module: Optional[Callable[[str], str]] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Search for all python files in\n    [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n    and\n    [`COMPONENTS.app_dirs`](../settings#django_components.app_settings.ComponentsSettings.app_dirs)\n    and import them.\n\n    See [Autodiscovery](../../concepts/fundamentals/autodiscovery).\n\n    Args:\n        map_module (Callable[[str], str], optional): Map the module paths with `map_module` function.\\\n        This serves as an escape hatch for when you need to use this function in tests.\n\n    Returns:\n        List[str]: A list of module paths of imported files.\n\n    To get the same list of modules that `autodiscover()` would return, but without importing them, use\n    [`get_component_files()`](../api#django_components.get_component_files):\n\n    ```python\n    from django_components import get_component_files\n\n    modules = get_component_files(\".py\")\n    ```\n    \"\"\"\n    modules = get_component_files(\".py\")\n    logger.debug(f\"Autodiscover found {len(modules)} files in component directories.\")\n    return _import_modules([entry.dot_path for entry in modules], map_module)\n</code></pre>"},{"location":"reference/django_components/#django_components.cached_template","title":"cached_template","text":"<pre><code>cached_template(\n    template_string: str,\n    template_cls: Optional[Type[Template]] = None,\n    origin: Optional[Origin] = None,\n    name: Optional[str] = None,\n    engine: Optional[Any] = None,\n) -&gt; Template\n</code></pre> <p>Create a Template instance that will be cached as per the <code>COMPONENTS.template_cache_size</code> setting.</p> <p>Parameters:</p> <ul> <li> <code>template_string</code>               (<code>str</code>)           \u2013            <p>Template as a string, same as the first argument to Django's            <code>Template</code>. Required.</p> </li> <li> <code>template_cls</code>               (<code>Type[Template]</code>, default:                   <code>None</code> )           \u2013            <p>Specify the Template class that should be instantiated.            Defaults to Django's <code>Template</code> class.</p> </li> <li> <code>origin</code>               (<code>Type[Origin]</code>, default:                   <code>None</code> )           \u2013            <p>Sets             <code>Template.Origin</code>.</p> </li> <li> <code>name</code>               (<code>Type[str]</code>, default:                   <code>None</code> )           \u2013            <p>Sets <code>Template.name</code></p> </li> <li> <code>engine</code>               (<code>Type[Any]</code>, default:                   <code>None</code> )           \u2013            <p>Sets <code>Template.engine</code></p> </li> </ul> <pre><code>from django_components import cached_template\n\ntemplate = cached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ntemplate = cached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre> Source code in <code>src/django_components/template.py</code> <pre><code>def cached_template(\n    template_string: str,\n    template_cls: Optional[Type[Template]] = None,\n    origin: Optional[Origin] = None,\n    name: Optional[str] = None,\n    engine: Optional[Any] = None,\n) -&gt; Template:\n    \"\"\"\n    Create a Template instance that will be cached as per the\n    [`COMPONENTS.template_cache_size`](../settings#django_components.app_settings.ComponentsSettings.template_cache_size)\n    setting.\n\n    Args:\n        template_string (str): Template as a string, same as the first argument to Django's\\\n            [`Template`](https://docs.djangoproject.com/en/5.1/topics/templates/#template). Required.\n        template_cls (Type[Template], optional): Specify the Template class that should be instantiated.\\\n            Defaults to Django's [`Template`](https://docs.djangoproject.com/en/5.1/topics/templates/#template) class.\n        origin (Type[Origin], optional): Sets \\\n            [`Template.Origin`](https://docs.djangoproject.com/en/5.1/howto/custom-template-backend/#origin-api-and-3rd-party-integration).\n        name (Type[str], optional): Sets `Template.name`\n        engine (Type[Any], optional): Sets `Template.engine`\n\n    ```python\n    from django_components import cached_template\n\n    template = cached_template(\"Variable: {{ variable }}\")\n\n    # You can optionally specify Template class, and other Template inputs:\n    class MyTemplate(Template):\n        pass\n\n    template = cached_template(\n        \"Variable: {{ variable }}\",\n        template_cls=MyTemplate,\n        name=...\n        origin=...\n        engine=...\n    )\n    ```\n    \"\"\"  # noqa: E501\n    template = _create_template(template_cls or Template, template_string, engine)\n\n    # Assign the origin and name separately, so the caching doesn't depend on them\n    # Since we might be accessing a template from cache, we want to define these only once\n    if not getattr(template, \"_dc_cached\", False):\n        template.origin = origin or Origin(UNKNOWN_SOURCE)\n        template.name = name\n        template._dc_cached = True\n\n    return template\n</code></pre>"},{"location":"reference/django_components/#django_components.get_component_dirs","title":"get_component_dirs","text":"<pre><code>get_component_dirs(include_apps: bool = True) -&gt; List[Path]\n</code></pre> <p>Get directories that may contain component files.</p> <p>This is the heart of all features that deal with filesystem and file lookup. Autodiscovery, Django template resolution, static file resolution - They all use this.</p> <p>Parameters:</p> <ul> <li> <code>include_apps</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Include directories from installed Django apps.            Defaults to <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Path]</code>           \u2013            <p>List[Path]: A list of directories that may contain component files.</p> </li> </ul> <p><code>get_component_dirs()</code> searches for dirs set in <code>COMPONENTS.dirs</code> settings. If none set, defaults to searching for a <code>\"components\"</code> app.</p> <p>In addition to that, also all installed Django apps are checked whether they contain directories as set in <code>COMPONENTS.app_dirs</code> (e.g. <code>[app]/components</code>).</p> <p>Notes:</p> <ul> <li> <p>Paths that do not point to directories are ignored.</p> </li> <li> <p><code>BASE_DIR</code> setting is required.</p> </li> <li> <p>The paths in <code>COMPONENTS.dirs</code>     must be absolute paths.</p> </li> </ul> Source code in <code>src/django_components/util/loader.py</code> <pre><code>def get_component_dirs(include_apps: bool = True) -&gt; List[Path]:\n    \"\"\"\n    Get directories that may contain component files.\n\n    This is the heart of all features that deal with filesystem and file lookup.\n    Autodiscovery, Django template resolution, static file resolution - They all use this.\n\n    Args:\n        include_apps (bool, optional): Include directories from installed Django apps.\\\n            Defaults to `True`.\n\n    Returns:\n        List[Path]: A list of directories that may contain component files.\n\n    `get_component_dirs()` searches for dirs set in\n    [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n    settings. If none set, defaults to searching for a `\"components\"` app.\n\n    In addition to that, also all installed Django apps are checked whether they contain\n    directories as set in\n    [`COMPONENTS.app_dirs`](../settings#django_components.app_settings.ComponentsSettings.app_dirs)\n    (e.g. `[app]/components`).\n\n    **Notes:**\n\n    - Paths that do not point to directories are ignored.\n\n    - `BASE_DIR` setting is required.\n\n    - The paths in [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n        must be absolute paths.\n    \"\"\"\n    # Allow to configure from settings which dirs should be checked for components\n    component_dirs = app_settings.DIRS\n\n    # TODO_REMOVE_IN_V1\n    raw_component_settings = getattr(settings, \"COMPONENTS\", {})\n    if isinstance(raw_component_settings, dict):\n        raw_dirs_value = raw_component_settings.get(\"dirs\", None)\n    elif isinstance(raw_component_settings, ComponentsSettings):\n        raw_dirs_value = raw_component_settings.dirs\n    else:\n        raw_dirs_value = None\n    is_component_dirs_set = raw_dirs_value is not None\n    is_legacy_paths = (\n        # Use value of `STATICFILES_DIRS` ONLY if `COMPONENT.dirs` not set\n        not is_component_dirs_set\n        and hasattr(settings, \"STATICFILES_DIRS\")\n        and settings.STATICFILES_DIRS\n    )\n    if is_legacy_paths:\n        # NOTE: For STATICFILES_DIRS, we use the defaults even for empty list.\n        # We don't do this for COMPONENTS.dirs, so user can explicitly specify \"NO dirs\".\n        component_dirs = settings.STATICFILES_DIRS or [settings.BASE_DIR / \"components\"]\n    # END TODO_REMOVE_IN_V1\n\n    source = \"STATICFILES_DIRS\" if is_legacy_paths else \"COMPONENTS.dirs\"\n\n    logger.debug(\n        \"get_component_dirs will search for valid dirs from following options:\\n\"\n        + \"\\n\".join([f\" - {str(d)}\" for d in component_dirs])\n    )\n\n    # Add `[app]/[APP_DIR]` to the directories. This is, by default `[app]/components`\n    app_paths: List[Path] = []\n    if include_apps:\n        for conf in apps.get_app_configs():\n            for app_dir in app_settings.APP_DIRS:\n                comps_path = Path(conf.path).joinpath(app_dir)\n                if comps_path.exists():\n                    app_paths.append(comps_path)\n\n    directories: Set[Path] = set(app_paths)\n\n    # Validate and add other values from the config\n    for component_dir in component_dirs:\n        # Consider tuples for STATICFILES_DIRS (See #489)\n        # See https://docs.djangoproject.com/en/5.0/ref/settings/#prefixes-optional\n        if isinstance(component_dir, (tuple, list)):\n            component_dir = component_dir[1]\n        try:\n            Path(component_dir)\n        except TypeError:\n            logger.warning(\n                f\"{source} expected str, bytes or os.PathLike object, or tuple/list of length 2. \"\n                f\"See Django documentation for STATICFILES_DIRS. Got {type(component_dir)} : {component_dir}\"\n            )\n            continue\n\n        if not Path(component_dir).is_absolute():\n            raise ValueError(f\"{source} must contain absolute paths, got '{component_dir}'\")\n        else:\n            directories.add(Path(component_dir).resolve())\n\n    logger.debug(\n        \"get_component_dirs matched following template dirs:\\n\" + \"\\n\".join([f\" - {str(d)}\" for d in directories])\n    )\n    return list(directories)\n</code></pre>"},{"location":"reference/django_components/#django_components.get_component_files","title":"get_component_files","text":"<pre><code>get_component_files(suffix: Optional[str] = None) -&gt; List[ComponentFileEntry]\n</code></pre> <p>Search for files within the component directories (as defined in <code>get_component_dirs()</code>).</p> <p>Requires <code>BASE_DIR</code> setting to be set.</p> <p>Parameters:</p> <ul> <li> <code>suffix</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The suffix to search for. E.g. <code>.py</code>, <code>.js</code>, <code>.css</code>.            Defaults to <code>None</code>, which will search for all files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[ComponentFileEntry]</code>           \u2013            <p>List[ComponentFileEntry] A list of entries that contain both the filesystem path and             the python import path (dot path).</p> </li> </ul> <p>Example:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre> Source code in <code>src/django_components/util/loader.py</code> <pre><code>def get_component_files(suffix: Optional[str] = None) -&gt; List[ComponentFileEntry]:\n    \"\"\"\n    Search for files within the component directories (as defined in\n    [`get_component_dirs()`](../api#django_components.get_component_dirs)).\n\n    Requires `BASE_DIR` setting to be set.\n\n    Args:\n        suffix (Optional[str], optional): The suffix to search for. E.g. `.py`, `.js`, `.css`.\\\n            Defaults to `None`, which will search for all files.\n\n    Returns:\n        List[ComponentFileEntry] A list of entries that contain both the filesystem path and \\\n            the python import path (dot path).\n\n    **Example:**\n\n    ```python\n    from django_components import get_component_files\n\n    modules = get_component_files(\".py\")\n    ```\n    \"\"\"\n    search_glob = f\"**/*{suffix}\" if suffix else \"**/*\"\n\n    dirs = get_component_dirs(include_apps=False)\n    component_filepaths = _search_dirs(dirs, search_glob)\n\n    if hasattr(settings, \"BASE_DIR\") and settings.BASE_DIR:\n        project_root = str(settings.BASE_DIR)\n    else:\n        # Fallback for getting the root dir, see https://stackoverflow.com/a/16413955/9788634\n        project_root = os.path.abspath(os.path.dirname(__name__))\n\n    # NOTE: We handle dirs from `COMPONENTS.dirs` and from individual apps separately.\n    modules: List[ComponentFileEntry] = []\n\n    # First let's handle the dirs from `COMPONENTS.dirs`\n    #\n    # Because for dirs in `COMPONENTS.dirs`, we assume they will be nested under `BASE_DIR`,\n    # and that `BASE_DIR` is the current working dir (CWD). So the path relatively to `BASE_DIR`\n    # is ALSO the python import path.\n    for filepath in component_filepaths:\n        module_path = _filepath_to_python_module(filepath, project_root, None)\n        # Ignore files starting with dot `.` or files in dirs that start with dot.\n        #\n        # If any of the parts of the path start with a dot, e.g. the filesystem path\n        # is `./abc/.def`, then this gets converted to python module as `abc..def`\n        #\n        # NOTE: This approach also ignores files:\n        #   - with two dots in the middle (ab..cd.py)\n        #   - an extra dot at the end (abcd..py)\n        #   - files outside of the parent component (../abcd.py).\n        # But all these are NOT valid python modules so that's fine.\n        if \"..\" in module_path:\n            continue\n\n        entry = ComponentFileEntry(dot_path=module_path, filepath=filepath)\n        modules.append(entry)\n\n    # For for apps, the directories may be outside of the project, e.g. in case of third party\n    # apps. So we have to resolve the python import path relative to the package name / the root\n    # import path for the app.\n    # See https://github.com/EmilStenstrom/django-components/issues/669\n    for conf in apps.get_app_configs():\n        for app_dir in app_settings.APP_DIRS:\n            comps_path = Path(conf.path).joinpath(app_dir)\n            if not comps_path.exists():\n                continue\n            app_component_filepaths = _search_dirs([comps_path], search_glob)\n            for filepath in app_component_filepaths:\n                app_component_module = _filepath_to_python_module(filepath, conf.path, conf.name)\n                entry = ComponentFileEntry(dot_path=app_component_module, filepath=filepath)\n                modules.append(entry)\n\n    return modules\n</code></pre>"},{"location":"reference/django_components/#django_components.import_libraries","title":"import_libraries","text":"<pre><code>import_libraries(map_module: Optional[Callable[[str], str]] = None) -&gt; List[str]\n</code></pre> <p>Import modules set in <code>COMPONENTS.libraries</code> setting.</p> <p>See Autodiscovery.</p> <p>Parameters:</p> <ul> <li> <code>map_module</code>               (<code>Callable[[str], str]</code>, default:                   <code>None</code> )           \u2013            <p>Map the module paths with <code>map_module</code> function.        This serves as an escape hatch for when you need to use this function in tests.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of module paths of imported files.</p> </li> </ul> <p>Examples:</p> <p>Normal usage - load libraries after Django has loaded <pre><code>from django_components import import_libraries\n\nclass MyAppConfig(AppConfig):\n    def ready(self):\n        import_libraries()\n</code></pre></p> <p>Potential usage in tests <pre><code>from django_components import import_libraries\n\nimport_libraries(lambda path: path.replace(\"tests.\", \"myapp.\"))\n</code></pre></p> Source code in <code>src/django_components/autodiscovery.py</code> <pre><code>def import_libraries(\n    map_module: Optional[Callable[[str], str]] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Import modules set in\n    [`COMPONENTS.libraries`](../settings#django_components.app_settings.ComponentsSettings.libraries)\n    setting.\n\n    See [Autodiscovery](../../concepts/fundamentals/autodiscovery).\n\n    Args:\n        map_module (Callable[[str], str], optional): Map the module paths with `map_module` function.\\\n        This serves as an escape hatch for when you need to use this function in tests.\n\n    Returns:\n        List[str]: A list of module paths of imported files.\n\n    **Examples:**\n\n    Normal usage - load libraries after Django has loaded\n    ```python\n    from django_components import import_libraries\n\n    class MyAppConfig(AppConfig):\n        def ready(self):\n            import_libraries()\n    ```\n\n    Potential usage in tests\n    ```python\n    from django_components import import_libraries\n\n    import_libraries(lambda path: path.replace(\"tests.\", \"myapp.\"))\n    ```\n    \"\"\"\n    from django_components.app_settings import app_settings\n\n    return _import_modules(app_settings.LIBRARIES, map_module)\n</code></pre>"},{"location":"reference/django_components/#django_components.register","title":"register","text":"<pre><code>register(name: str, registry: Optional[ComponentRegistry] = None) -&gt; Callable[\n    [Type[Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]]],\n    Type[Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]],\n]\n</code></pre> <p>Class decorator for registering a component to a component registry.</p> <p>See Registering components.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Registered name. This is the name by which the component will be accessed            from within a template when using the <code>{% component %}</code> tag. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to which to register this component. If omitted, component is registered to the default registry.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AlreadyRegistered</code>             \u2013            <p>If there is already a component registered under the same name.</p> </li> </ul> <p>Examples:</p> <pre><code>from django_components import Component, register\n\n@register(\"my_component\")\nclass MyComponent(Component):\n    ...\n</code></pre> <p>Specifing <code>ComponentRegistry</code> the component should be registered to by setting the <code>registry</code> kwarg:</p> <pre><code>from django.template import Library\nfrom django_components import Component, ComponentRegistry, register\n\nmy_lib = Library()\nmy_reg = ComponentRegistry(library=my_lib)\n\n@register(\"my_component\", registry=my_reg)\nclass MyComponent(Component):\n    ...\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def register(name: str, registry: Optional[ComponentRegistry] = None) -&gt; Callable[\n    [Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"]],\n    Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"],\n]:\n    \"\"\"\n    Class decorator for registering a [component](./#django_components.Component)\n    to a [component registry](./#django_components.ComponentRegistry).\n\n    See [Registering components](../../concepts/advanced/component_registry).\n\n    Args:\n        name (str): Registered name. This is the name by which the component will be accessed\\\n            from within a template when using the [`{% component %}`](../template_tags#component) tag. Required.\n        registry (ComponentRegistry, optional): Specify the [registry](./#django_components.ComponentRegistry)\\\n            to which to register this component. If omitted, component is registered to the default registry.\n\n    Raises:\n        AlreadyRegistered: If there is already a component registered under the same name.\n\n    **Examples**:\n\n    ```python\n    from django_components import Component, register\n\n    @register(\"my_component\")\n    class MyComponent(Component):\n        ...\n    ```\n\n    Specifing [`ComponentRegistry`](./#django_components.ComponentRegistry) the component\n    should be registered to by setting the `registry` kwarg:\n\n    ```python\n    from django.template import Library\n    from django_components import Component, ComponentRegistry, register\n\n    my_lib = Library()\n    my_reg = ComponentRegistry(library=my_lib)\n\n    @register(\"my_component\", registry=my_reg)\n    class MyComponent(Component):\n        ...\n    ```\n    \"\"\"\n    if registry is None:\n        registry = _the_registry\n\n    def decorator(\n        component: Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"],\n    ) -&gt; Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"]:\n        registry.register(name=name, component=component)\n        return component\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/#django_components.render_dependencies","title":"render_dependencies","text":"<pre><code>render_dependencies(content: TContent, type: RenderType = 'document') -&gt; TContent\n</code></pre> <p>Given a string that contains parts that were rendered by components, this function inserts all used JS and CSS.</p> <p>By default, the string is parsed as an HTML and: - CSS is inserted at the end of <code>&lt;head&gt;</code> (if present) - JS is inserted at the end of <code>&lt;body&gt;</code> (if present)</p> <p>If you used <code>{% component_js_dependencies %}</code> or <code>{% component_css_dependencies %}</code>, then the JS and CSS will be inserted only at these locations.</p> <p>Example: <pre><code>def my_view(request):\n    template = Template('''\n        {% load components %}\n        &lt;!doctype html&gt;\n        &lt;html&gt;\n            &lt;head&gt;&lt;/head&gt;\n            &lt;body&gt;\n                &lt;h1&gt;{{ table_name }}&lt;/h1&gt;\n                {% component \"table\" name=table_name / %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    ''')\n\n    html = template.render(\n        Context({\n            \"table_name\": request.GET[\"name\"],\n        })\n    )\n\n    # This inserts components' JS and CSS\n    processed_html = render_dependencies(html)\n\n    return HttpResponse(processed_html)\n</code></pre></p> Source code in <code>src/django_components/dependencies.py</code> <pre><code>def render_dependencies(content: TContent, type: RenderType = \"document\") -&gt; TContent:\n    \"\"\"\n    Given a string that contains parts that were rendered by components,\n    this function inserts all used JS and CSS.\n\n    By default, the string is parsed as an HTML and:\n    - CSS is inserted at the end of `&lt;head&gt;` (if present)\n    - JS is inserted at the end of `&lt;body&gt;` (if present)\n\n    If you used `{% component_js_dependencies %}` or `{% component_css_dependencies %}`,\n    then the JS and CSS will be inserted only at these locations.\n\n    Example:\n    ```python\n    def my_view(request):\n        template = Template('''\n            {% load components %}\n            &lt;!doctype html&gt;\n            &lt;html&gt;\n                &lt;head&gt;&lt;/head&gt;\n                &lt;body&gt;\n                    &lt;h1&gt;{{ table_name }}&lt;/h1&gt;\n                    {% component \"table\" name=table_name / %}\n                &lt;/body&gt;\n            &lt;/html&gt;\n        ''')\n\n        html = template.render(\n            Context({\n                \"table_name\": request.GET[\"name\"],\n            })\n        )\n\n        # This inserts components' JS and CSS\n        processed_html = render_dependencies(html)\n\n        return HttpResponse(processed_html)\n    ```\n    \"\"\"\n    is_safestring = isinstance(content, SafeString)\n\n    if isinstance(content, str):\n        content_ = content.encode()\n    else:\n        content_ = cast(bytes, content)\n\n    content_, js_dependencies, css_dependencies = _process_dep_declarations(content_, type)\n\n    # Replace the placeholders with the actual content\n    did_find_js_placeholder = False\n    did_find_css_placeholder = False\n\n    def on_replace_match(match: \"re.Match[bytes]\") -&gt; bytes:\n        nonlocal did_find_css_placeholder\n        nonlocal did_find_js_placeholder\n\n        if match[0] == CSS_PLACEHOLDER_BYTES:\n            replacement = css_dependencies\n            did_find_css_placeholder = True\n        elif match[0] == JS_PLACEHOLDER_BYTES:\n            replacement = js_dependencies\n            did_find_js_placeholder = True\n        else:\n            raise RuntimeError(\n                \"Unexpected error: Regex for component dependencies processing\"\n                f\" matched unknown string '{match[0].decode()}'\"\n            )\n        return replacement\n\n    content_ = PLACEHOLDER_REGEX.sub(on_replace_match, content_)\n\n    # By default, if user didn't specify any `{% component_dependencies %}`,\n    # then try to insert the JS scripts at the end of &lt;body&gt; and CSS sheets at the end\n    # of &lt;head&gt;\n    if type == \"document\" and (not did_find_js_placeholder or not did_find_css_placeholder):\n        tree = parse_document_or_nodes(content_.decode())\n\n        if isinstance(tree, LexborHTMLParser):\n            did_modify_html = False\n\n            if not did_find_css_placeholder and tree.head:\n                css_elems = parse_multiroot_html(css_dependencies.decode())\n                for css_elem in css_elems:\n                    tree.head.insert_child(css_elem)  # type: ignore # TODO: Update to selectolax 0.3.25\n                did_modify_html = True\n\n            if not did_find_js_placeholder and tree.body:\n                js_elems = parse_multiroot_html(js_dependencies.decode())\n                for js_elem in js_elems:\n                    tree.body.insert_child(js_elem)  # type: ignore # TODO: Update to selectolax 0.3.25\n                did_modify_html = True\n\n            transformed = cast(str, tree.html)\n            if did_modify_html:\n                content_ = transformed.encode()\n\n    # Return the same type as we were given\n    output = content_.decode() if isinstance(content, str) else content_\n    output = mark_safe(output) if is_safestring else output\n    return cast(TContent, output)\n</code></pre>"},{"location":"reference/django_components/#django_components.app_settings","title":"app_settings","text":"<p>Classes:</p> <ul> <li> <code>ComponentsSettings</code>           \u2013            <p>Settings available for django_components.</p> </li> <li> <code>ContextBehavior</code>           \u2013            <p>Configure how (and whether) the context is passed to the component fills</p> </li> </ul>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings","title":"ComponentsSettings","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Settings available for django_components.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n    dirs = [BASE_DIR / \"components\"],\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>app_dirs</code>               (<code>Optional[Sequence[str]]</code>)           \u2013            <p>Specify the app-level directories that contain your components.</p> </li> <li> <code>autodiscover</code>               (<code>Optional[bool]</code>)           \u2013            <p>Toggle whether to run autodiscovery at the Django server startup.</p> </li> <li> <code>context_behavior</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            <p>Configure whether, inside a component template, you can use variables from the outside</p> </li> <li> <code>dirs</code>               (<code>Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]]</code>)           \u2013            <p>Specify the directories that contain your components.</p> </li> <li> <code>dynamic_component_name</code>               (<code>Optional[str]</code>)           \u2013            <p>By default, the dynamic component</p> </li> <li> <code>forbidden_static_files</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            <p>Deprecated. Use</p> </li> <li> <code>libraries</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Configure extra python modules that should be loaded.</p> </li> <li> <code>multiline_tags</code>               (<code>Optional[bool]</code>)           \u2013            <p>Enable / disable</p> </li> <li> <code>reload_on_file_change</code>               (<code>Optional[bool]</code>)           \u2013            <p>This is relevant if you are using the project structure where</p> </li> <li> <code>reload_on_template_change</code>               (<code>Optional[bool]</code>)           \u2013            <p>Deprecated. Use</p> </li> <li> <code>static_files_allowed</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            <p>A list of file extensions (including the leading dot) that define which files within</p> </li> <li> <code>static_files_forbidden</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            <p>A list of file extensions (including the leading dot) that define which files within</p> </li> <li> <code>tag_formatter</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            <p>Configure what syntax is used inside Django templates to render components.</p> </li> <li> <code>template_cache_size</code>               (<code>Optional[int]</code>)           \u2013            <p>Configure the maximum amount of Django templates to be cached.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.app_dirs","title":"app_dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>app_dirs: Optional[Sequence[str]] = None\n</code></pre> <p>Specify the app-level directories that contain your components.</p> <p>Defaults to <code>[\"components\"]</code>. That is, for each Django app, we search <code>&lt;app&gt;/components/</code> for components.</p> <p>The paths must be relative to app, e.g.:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[\"my_comps\"],\n)\n</code></pre> <p>To search for <code>&lt;app&gt;/my_comps/</code>.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <p>Set to empty list to disable app-level components:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[],\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.autodiscover","title":"autodiscover  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>autodiscover: Optional[bool] = None\n</code></pre> <p>Toggle whether to run autodiscovery at the Django server startup.</p> <p>Defaults to <code>True</code></p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.context_behavior","title":"context_behavior  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>Configure whether, inside a component template, you can use variables from the outside (<code>\"django\"</code>) or not (<code>\"isolated\"</code>). This also affects what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Defaults to <code>\"django\"</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    context_behavior=\"isolated\",\n)\n</code></pre> <p>NOTE: <code>context_behavior</code> and <code>slot_context_behavior</code> options were merged in v0.70.</p> <p>If you are migrating from BEFORE v0.67, set <code>context_behavior</code> to <code>\"django\"</code>. From v0.67 to v0.78 (incl) the default value was <code>\"isolated\"</code>.</p> <p>For v0.79 and later, the default is again <code>\"django\"</code>. See the rationale for change here.</p>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.dirs","title":"dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirs: Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]] = None\n</code></pre> <p>Specify the directories that contain your components.</p> <p>Defaults to <code>[Path(settings.BASE_DIR) / \"components\"]</code>. That is, the root <code>components/</code> app.</p> <p>Directories must be full paths, same as with STATICFILES_DIRS.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[BASE_DIR / \"components\"],\n)\n</code></pre> <p>Set to empty list to disable global components directories:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[],\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.dynamic_component_name","title":"dynamic_component_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dynamic_component_name: Optional[str] = None\n</code></pre> <p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>.</p> <p>In case of a conflict, you can use this setting to change the component name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name:</p> <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.forbidden_static_files","title":"forbidden_static_files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>forbidden_static_files: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>Deprecated. Use <code>COMPONENTS.static_files_forbidden</code> instead.</p>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.libraries","title":"libraries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>libraries: Optional[List[str]] = None\n</code></pre> <p>Configure extra python modules that should be loaded.</p> <p>This may be useful if you are not using the autodiscovery feature, or you need to load components from non-standard locations. Thus you can have a structure of components that is independent from your apps.</p> <p>Expects a list of python module paths. Defaults to empty list.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    libraries=[\n        \"mysite.components.forms\",\n        \"mysite.components.buttons\",\n        \"mysite.components.cards\",\n    ],\n)\n</code></pre> <p>This would be the equivalent of importing these modules from within Django's <code>AppConfig.ready()</code>:</p> <pre><code>class MyAppConfig(AppConfig):\n    def ready(self):\n        import \"mysite.components.forms\"\n        import \"mysite.components.buttons\"\n        import \"mysite.components.cards\"\n</code></pre>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.libraries--manually-loading-libraries","title":"Manually loading libraries","text":"<p>In the rare case that you need to manually trigger the import of libraries, you can use the <code>import_libraries()</code> function:</p> <pre><code>from django_components import import_libraries\n\nimport_libraries()\n</code></pre>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.multiline_tags","title":"multiline_tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>multiline_tags: Optional[bool] = None\n</code></pre> <p>Enable / disable multiline support for template tags. If <code>True</code>, template tags like <code>{% component %}</code> or <code>{{ my_var }}</code> can span multiple lines.</p> <p>Defaults to <code>True</code>.</p> <p>Disable this setting if you are making custom modifications to Django's regular expression for parsing templates at <code>django.template.base.tag_re</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    multiline_tags=False,\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.reload_on_file_change","title":"reload_on_file_change  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reload_on_file_change: Optional[bool] = None\n</code></pre> <p>This is relevant if you are using the project structure where HTML, JS, CSS and Python are in separate files and nested in a directory.</p> <p>In this case you may notice that when you are running a development server, the server sometimes does not reload when you change component files.</p> <p>Django's native live reload logic handles only Python files and HTML template files. It does NOT reload when other file types change or when template files are nested more than one level deep.</p> <p>The setting <code>reload_on_file_change</code> fixes this, reloading the dev server even when your component's HTML, JS, or CSS changes.</p> <p>If <code>True</code>, django_components configures Django to reload when files inside <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> change.</p> <p>See Reload dev server on component file changes.</p> <p>Defaults to <code>False</code>.</p> <p>Warning</p> <p>This setting should be enabled only for the dev environment!</p>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.reload_on_template_change","title":"reload_on_template_change  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reload_on_template_change: Optional[bool] = None\n</code></pre> <p>Deprecated. Use <code>COMPONENTS.reload_on_file_change</code> instead.</p>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.static_files_allowed","title":"static_files_allowed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>static_files_allowed: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> are treated as static files.</p> <p>If a file is matched against any of the patterns, it's considered a static file. Such files are collected when running <code>collectstatic</code>, and can be accessed under the static file endpoint.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, JS, CSS, and common image and font file formats are considered static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_allowed=[\n        \".css\",\n        \".js\", \".jsx\", \".ts\", \".tsx\",\n        # Images\n        \".apng\", \".png\", \".avif\", \".gif\", \".jpg\",\n        \".jpeg\",  \".jfif\", \".pjpeg\", \".pjp\", \".svg\",\n        \".webp\", \".bmp\", \".ico\", \".cur\", \".tif\", \".tiff\",\n        # Fonts\n        \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.static_files_forbidden","title":"static_files_forbidden  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>static_files_forbidden: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> will NEVER be treated as static files.</p> <p>If a file is matched against any of the patterns, it will never be considered a static file, even if the file matches a pattern in <code>static_files_allowed</code>.</p> <p>Use this setting together with <code>static_files_allowed</code> for a fine control over what file types will be exposed.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, any HTML and Python are considered NOT static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_forbidden=[\n        \".html\", \".django\", \".dj\", \".tpl\",\n        # Python files\n        \".py\", \".pyc\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.tag_formatter","title":"tag_formatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>Configure what syntax is used inside Django templates to render components. See the available tag formatters.</p> <p>Defaults to <code>\"django_components.component_formatter\"</code>.</p> <p>Learn more about Customizing component tags with TagFormatter.</p> <p>Can be set either as direct reference:</p> <pre><code>from django_components import component_formatter\n\nCOMPONENTS = ComponentsSettings(\n    \"tag_formatter\": component_formatter\n)\n</code></pre> <p>Or as an import string;</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>Examples:</p> <ul> <li> <p><code>\"django_components.component_formatter\"</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% component \"button\" href=\"...\" %}\n    Click me!\n{% endcomponent %}\n</code></pre> </li> <li> <p><code>django_components.component_shorthand_formatter</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% button href=\"...\" %}\n    Click me!\n{% endbutton %}\n</code></pre> </li> </ul>"},{"location":"reference/django_components/#django_components.app_settings.ComponentsSettings.template_cache_size","title":"template_cache_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_cache_size: Optional[int] = None\n</code></pre> <p>Configure the maximum amount of Django templates to be cached.</p> <p>Defaults to <code>128</code>.</p> <p>Each time a Django template is rendered, it is cached to a global in-memory cache (using Python's <code>lru_cache</code> decorator). This speeds up the next render of the component. As the same component is often used many times on the same page, these savings add up.</p> <p>By default the cache holds 128 component templates in memory, which should be enough for most sites. But if you have a lot of components, or if you are overriding <code>Component.get_template()</code> to render many dynamic templates, you can increase this number.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=256,\n)\n</code></pre> <p>To remove the cache limit altogether and cache everything, set <code>template_cache_size</code> to <code>None</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=None,\n)\n</code></pre> <p>If you want to add templates to the cache yourself, you can use <code>cached_template()</code>:</p> <pre><code>from django_components import cached_template\n\ncached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ncached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.app_settings.ContextBehavior","title":"ContextBehavior","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Configure how (and whether) the context is passed to the component fills and what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Options:</p> <ul> <li><code>django</code>: With this setting, component fills behave as usual Django tags.</li> <li><code>isolated</code>: This setting makes the component fills behave similar to Vue or React.</li> </ul> <p>Attributes:</p> <ul> <li> <code>DJANGO</code>           \u2013            <p>With this setting, component fills behave as usual Django tags.</p> </li> <li> <code>ISOLATED</code>           \u2013            <p>This setting makes the component fills behave similar to Vue or React, where</p> </li> </ul>"},{"location":"reference/django_components/#django_components.app_settings.ContextBehavior.DJANGO","title":"DJANGO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DJANGO = 'django'\n</code></pre> <p>With this setting, component fills behave as usual Django tags. That is, they enrich the context, and pass it along.</p> <ol> <li>Component fills use the context of the component they are within.</li> <li>Variables from <code>Component.get_context_data()</code> are available to the component fill.</li> </ol> <p>Example:</p> <p>Given this template <pre><code>{% with cheese=\"feta\" %}\n  {% component 'my_comp' %}\n    {{ my_var }}  # my_var\n    {{ cheese }}  # cheese\n  {% endcomponent %}\n{% endwith %}\n</code></pre></p> <p>and this context returned from the <code>Component.get_context_data()</code> method <pre><code>{ \"my_var\": 123 }\n</code></pre></p> <p>Then if component \"my_comp\" defines context <pre><code>{ \"my_var\": 456 }\n</code></pre></p> <p>Then this will render: <pre><code>456   # my_var\nfeta  # cheese\n</code></pre></p> <p>Because \"my_comp\" overrides the variable \"my_var\", so <code>{{ my_var }}</code> equals <code>456</code>.</p> <p>And variable \"cheese\" will equal <code>feta</code>, because the fill CAN access the current context.</p>"},{"location":"reference/django_components/#django_components.app_settings.ContextBehavior.ISOLATED","title":"ISOLATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ISOLATED = 'isolated'\n</code></pre> <p>This setting makes the component fills behave similar to Vue or React, where the fills use EXCLUSIVELY the context variables defined in <code>Component.get_context_data()</code>.</p> <p>Example:</p> <p>Given this template <pre><code>{% with cheese=\"feta\" %}\n  {% component 'my_comp' %}\n    {{ my_var }}  # my_var\n    {{ cheese }}  # cheese\n  {% endcomponent %}\n{% endwith %}\n</code></pre></p> <p>and this context returned from the <code>get_context_data()</code> method <pre><code>{ \"my_var\": 123 }\n</code></pre></p> <p>Then if component \"my_comp\" defines context <pre><code>{ \"my_var\": 456 }\n</code></pre></p> <p>Then this will render: <pre><code>123   # my_var\n      # cheese\n</code></pre></p> <p>Because both variables \"my_var\" and \"cheese\" are taken from the root context. Since \"cheese\" is not defined in root context, it's empty.</p>"},{"location":"reference/django_components/#django_components.attributes","title":"attributes","text":"<p>Functions:</p> <ul> <li> <code>append_attributes</code>             \u2013              <p>Merges the key-value pairs and returns a new dictionary.</p> </li> <li> <code>attributes_to_string</code>             \u2013              <p>Convert a dict of attributes to a string.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.attributes.append_attributes","title":"append_attributes","text":"<pre><code>append_attributes(*args: Tuple[str, Any]) -&gt; Dict\n</code></pre> <p>Merges the key-value pairs and returns a new dictionary.</p> <p>If a key is present multiple times, its values are concatenated with a space character as separator in the final dictionary.</p> Source code in <code>src/django_components/attributes.py</code> <pre><code>def append_attributes(*args: Tuple[str, Any]) -&gt; Dict:\n    \"\"\"\n    Merges the key-value pairs and returns a new dictionary.\n\n    If a key is present multiple times, its values are concatenated with a space\n    character as separator in the final dictionary.\n    \"\"\"\n    result: Dict = {}\n\n    for key, value in args:\n        if key in result:\n            result[key] += \" \" + value\n        else:\n            result[key] = value\n\n    return result\n</code></pre>"},{"location":"reference/django_components/#django_components.attributes.attributes_to_string","title":"attributes_to_string","text":"<pre><code>attributes_to_string(attributes: Mapping[str, Any]) -&gt; str\n</code></pre> <p>Convert a dict of attributes to a string.</p> Source code in <code>src/django_components/attributes.py</code> <pre><code>def attributes_to_string(attributes: Mapping[str, Any]) -&gt; str:\n    \"\"\"Convert a dict of attributes to a string.\"\"\"\n    attr_list = []\n\n    for key, value in attributes.items():\n        if value is None or value is False:\n            continue\n        if value is True:\n            attr_list.append(conditional_escape(key))\n        else:\n            attr_list.append(format_html('{}=\"{}\"', key, value))\n\n    return mark_safe(SafeString(\" \").join(attr_list))\n</code></pre>"},{"location":"reference/django_components/#django_components.autodiscovery","title":"autodiscovery","text":"<p>Functions:</p> <ul> <li> <code>autodiscover</code>             \u2013              <p>Search for all python files in</p> </li> <li> <code>import_libraries</code>             \u2013              <p>Import modules set in</p> </li> </ul>"},{"location":"reference/django_components/#django_components.autodiscovery.autodiscover","title":"autodiscover","text":"<pre><code>autodiscover(map_module: Optional[Callable[[str], str]] = None) -&gt; List[str]\n</code></pre> <p>Search for all python files in <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code> and import them.</p> <p>See Autodiscovery.</p> <p>Parameters:</p> <ul> <li> <code>map_module</code>               (<code>Callable[[str], str]</code>, default:                   <code>None</code> )           \u2013            <p>Map the module paths with <code>map_module</code> function.        This serves as an escape hatch for when you need to use this function in tests.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of module paths of imported files.</p> </li> </ul> <p>To get the same list of modules that <code>autodiscover()</code> would return, but without importing them, use <code>get_component_files()</code>:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre> Source code in <code>src/django_components/autodiscovery.py</code> <pre><code>def autodiscover(\n    map_module: Optional[Callable[[str], str]] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Search for all python files in\n    [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n    and\n    [`COMPONENTS.app_dirs`](../settings#django_components.app_settings.ComponentsSettings.app_dirs)\n    and import them.\n\n    See [Autodiscovery](../../concepts/fundamentals/autodiscovery).\n\n    Args:\n        map_module (Callable[[str], str], optional): Map the module paths with `map_module` function.\\\n        This serves as an escape hatch for when you need to use this function in tests.\n\n    Returns:\n        List[str]: A list of module paths of imported files.\n\n    To get the same list of modules that `autodiscover()` would return, but without importing them, use\n    [`get_component_files()`](../api#django_components.get_component_files):\n\n    ```python\n    from django_components import get_component_files\n\n    modules = get_component_files(\".py\")\n    ```\n    \"\"\"\n    modules = get_component_files(\".py\")\n    logger.debug(f\"Autodiscover found {len(modules)} files in component directories.\")\n    return _import_modules([entry.dot_path for entry in modules], map_module)\n</code></pre>"},{"location":"reference/django_components/#django_components.autodiscovery.import_libraries","title":"import_libraries","text":"<pre><code>import_libraries(map_module: Optional[Callable[[str], str]] = None) -&gt; List[str]\n</code></pre> <p>Import modules set in <code>COMPONENTS.libraries</code> setting.</p> <p>See Autodiscovery.</p> <p>Parameters:</p> <ul> <li> <code>map_module</code>               (<code>Callable[[str], str]</code>, default:                   <code>None</code> )           \u2013            <p>Map the module paths with <code>map_module</code> function.        This serves as an escape hatch for when you need to use this function in tests.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of module paths of imported files.</p> </li> </ul> <p>Examples:</p> <p>Normal usage - load libraries after Django has loaded <pre><code>from django_components import import_libraries\n\nclass MyAppConfig(AppConfig):\n    def ready(self):\n        import_libraries()\n</code></pre></p> <p>Potential usage in tests <pre><code>from django_components import import_libraries\n\nimport_libraries(lambda path: path.replace(\"tests.\", \"myapp.\"))\n</code></pre></p> Source code in <code>src/django_components/autodiscovery.py</code> <pre><code>def import_libraries(\n    map_module: Optional[Callable[[str], str]] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Import modules set in\n    [`COMPONENTS.libraries`](../settings#django_components.app_settings.ComponentsSettings.libraries)\n    setting.\n\n    See [Autodiscovery](../../concepts/fundamentals/autodiscovery).\n\n    Args:\n        map_module (Callable[[str], str], optional): Map the module paths with `map_module` function.\\\n        This serves as an escape hatch for when you need to use this function in tests.\n\n    Returns:\n        List[str]: A list of module paths of imported files.\n\n    **Examples:**\n\n    Normal usage - load libraries after Django has loaded\n    ```python\n    from django_components import import_libraries\n\n    class MyAppConfig(AppConfig):\n        def ready(self):\n            import_libraries()\n    ```\n\n    Potential usage in tests\n    ```python\n    from django_components import import_libraries\n\n    import_libraries(lambda path: path.replace(\"tests.\", \"myapp.\"))\n    ```\n    \"\"\"\n    from django_components.app_settings import app_settings\n\n    return _import_modules(app_settings.LIBRARIES, map_module)\n</code></pre>"},{"location":"reference/django_components/#django_components.component","title":"component","text":"<p>Classes:</p> <ul> <li> <code>Component</code>           \u2013            </li> <li> <code>ComponentNode</code>           \u2013            <p>Django.template.Node subclass that renders a django-components component</p> </li> <li> <code>ComponentVars</code>           \u2013            <p>Type for the variables available inside the component templates.</p> </li> <li> <code>ComponentView</code>           \u2013            <p>Subclass of <code>django.views.View</code> where the <code>Component</code> instance is available</p> </li> </ul>"},{"location":"reference/django_components/#django_components.component.Component","title":"Component","text":"<pre><code>Component(\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,\n)\n</code></pre> <p>               Bases: <code>Generic[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]</code></p> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> </li> <li> <code>get_template</code>             \u2013              <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>get_template_name</code>             \u2013              <p>Filepath to the Django template associated with this component.</p> </li> <li> <code>inject</code>             \u2013              <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag</p> </li> <li> <code>on_render_after</code>             \u2013              <p>Hook that runs just after the component's template was rendered.</p> </li> <li> <code>on_render_before</code>             \u2013              <p>Hook that runs just before the component's template is rendered.</p> </li> <li> <code>render</code>             \u2013              <p>Render the component into a string.</p> </li> <li> <code>render_to_response</code>             \u2013              <p>Render the component and wrap the content in the response class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Media</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined CSS associated with this component.</p> </li> <li> <code>input</code>               (<code>RenderInput[ArgsType, KwargsType, SlotsType]</code>)           \u2013            <p>Input holds the data (like arg, kwargs, slots) that were passsed to</p> </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            <p>Dictionary describing which slots have or have not been filled.</p> </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined JS associated with this component.</p> </li> <li> <code>media</code>               (<code>Media</code>)           \u2013            <p>Normalized definition of JS and CSS media files associated with this component.</p> </li> <li> <code>response_class</code>           \u2013            <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p> </li> <li> <code>template</code>               (<code>Optional[Union[str, Template]]</code>)           \u2013            <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Filepath to the Django template associated with this component.</p> </li> </ul> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,  # noqa F811\n):\n    # When user first instantiates the component class before calling\n    # `render` or `render_to_response`, then we want to allow the render\n    # function to make use of the instantiated object.\n    #\n    # So while `MyComp.render()` creates a new instance of MyComp internally,\n    # if we do `MyComp(registered_name=\"abc\").render()`, then we use the\n    # already-instantiated object.\n    #\n    # To achieve that, we want to re-assign the class methods as instance methods.\n    # For that we have to \"unwrap\" the class methods via __func__.\n    # See https://stackoverflow.com/a/76706399/9788634\n    self.render_to_response = types.MethodType(self.__class__.render_to_response.__func__, self)  # type: ignore\n    self.render = types.MethodType(self.__class__.render.__func__, self)  # type: ignore\n    self.as_view = types.MethodType(self.__class__.as_view.__func__, self)  # type: ignore\n\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.component_id = component_id or gen_id()\n    self.registry = registry or registry_\n    self._render_stack: Deque[RenderStackItem[ArgsType, KwargsType, SlotsType]] = deque()\n    # None == uninitialized, False == No types, Tuple == types\n    self._types: Optional[Union[Tuple[Any, Any, Any, Any, Any, Any], Literal[False]]] = None\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.Media","title":"Media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Media = ComponentMediaInput\n</code></pre> <p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/#django_components.component.Component.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>Inlined CSS associated with this component.</p>"},{"location":"reference/django_components/#django_components.component.Component.input","title":"input  <code>property</code>","text":"<pre><code>input: RenderInput[ArgsType, KwargsType, SlotsType]\n</code></pre> <p>Input holds the data (like arg, kwargs, slots) that were passsed to the current execution of the <code>render</code> method.</p>"},{"location":"reference/django_components/#django_components.component.Component.is_filled","title":"is_filled  <code>property</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within the template as <code>{{ component_vars.is_filled.slot_name }}</code>, and within <code>on_render_before</code> and <code>on_render_after</code> hooks.</p>"},{"location":"reference/django_components/#django_components.component.Component.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>Inlined JS associated with this component.</p>"},{"location":"reference/django_components/#django_components.component.Component.media","title":"media  <code>instance-attribute</code>","text":"<pre><code>media: Media\n</code></pre> <p>Normalized definition of JS and CSS media files associated with this component.</p> <p>NOTE: This field is generated from Component.Media class.</p>"},{"location":"reference/django_components/#django_components.component.Component.response_class","title":"response_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>response_class = HttpResponse\n</code></pre> <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p>"},{"location":"reference/django_components/#django_components.component.Component.template","title":"template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template: Optional[Union[str, Template]] = None\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/#django_components.component.Component.template_name","title":"template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = None\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/#django_components.component.Component.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef as_view(cls, **initkwargs: Any) -&gt; ViewFn:\n    \"\"\"\n    Shortcut for calling `Component.View.as_view` and passing component instance to it.\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    # Allow the View class to access this component via `self.component`\n    return comp.View.as_view(**initkwargs, component=comp)\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template(self, context: Context) -&gt; Optional[Union[str, Template]]:\n    \"\"\"\n    Inlined Django template associated with this component. Can be a plain string or a Template instance.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template_name(self, context: Context) -&gt; Optional[str]:\n    \"\"\"\n    Filepath to the Django template associated with this component.\n\n    The filepath must be relative to either the file where the component class was defined,\n    or one of the roots of `STATIFILES_DIRS`.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>provide</code> tag with given key was NOT found.</p> <p>This method mut be used inside the <code>get_context_data()</code> method and raises an error if called elsewhere.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"provider\" hello=\"world\" %}\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ data.hello }}!\"\n    def get_context_data(self):\n        data = self.inject(\"provider\")\n        return {\"data\": data}\n</code></pre></p> <p>This renders into: <pre><code>hi world!\n</code></pre></p> <p>As the <code>{{ data.hello }}</code> is taken from the \"provider\".</p> Source code in <code>src/django_components/component.py</code> <pre><code>def inject(self, key: str, default: Optional[Any] = None) -&gt; Any:\n    \"\"\"\n    Use this method to retrieve the data that was passed to a `{% provide %}` tag\n    with the corresponding key.\n\n    To retrieve the data, `inject()` must be called inside a component that's\n    inside the `{% provide %}` tag.\n\n    You may also pass a default that will be used if the `provide` tag with given\n    key was NOT found.\n\n    This method mut be used inside the `get_context_data()` method and raises\n    an error if called elsewhere.\n\n    Example:\n\n    Given this template:\n    ```django\n    {% provide \"provider\" hello=\"world\" %}\n        {% component \"my_comp\" %}\n        {% endcomponent %}\n    {% endprovide %}\n    ```\n\n    And given this definition of \"my_comp\" component:\n    ```py\n    from django_components import Component, register\n\n    @register(\"my_comp\")\n    class MyComp(Component):\n        template = \"hi {{ data.hello }}!\"\n        def get_context_data(self):\n            data = self.inject(\"provider\")\n            return {\"data\": data}\n    ```\n\n    This renders into:\n    ```\n    hi world!\n    ```\n\n    As the `{{ data.hello }}` is taken from the \"provider\".\n    \"\"\"\n    if self.input is None:\n        raise RuntimeError(\n            f\"Method 'inject()' of component '{self.name}' was called outside of 'get_context_data()'\"\n        )\n\n    return get_injected_context_var(self.name, self.input.context, key, default)\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Template, content: str) -&gt; Optional[SlotResult]\n</code></pre> <p>Hook that runs just after the component's template was rendered. It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_after(self, context: Context, template: Template, content: str) -&gt; Optional[SlotResult]:\n    \"\"\"\n    Hook that runs just after the component's template was rendered.\n    It receives the rendered output as the last argument.\n\n    You can use this hook to access the context or the template, but modifying\n    them won't have any effect.\n\n    To override the content that gets rendered, you can return a string or SafeString\n    from this hook.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Template) -&gt; None\n</code></pre> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_before(self, context: Context, template: Template) -&gt; None:\n    \"\"\"\n    Hook that runs just before the component's template is rendered.\n\n    You can use this hook to access or modify the context or the template.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str\n</code></pre> <p>Render the component into a string.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag. - <code>render_dependencies</code> - Set this to <code>False</code> if you want to insert the resulting HTML into another component.</p> <p>Example: <pre><code>MyComponent.render(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str:\n    \"\"\"\n    Render the component into a string.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n    - `render_dependencies` - Set this to `False` if you want to insert the resulting HTML into another component.\n\n    Example:\n    ```py\n    MyComponent.render(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n    )\n    ```\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    return comp._render(context, args, kwargs, slots, escape_slots_content, type, render_dependencies)\n</code></pre>"},{"location":"reference/django_components/#django_components.component.Component.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and wrap the content in the response class.</p> <p>The response class is taken from <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <p>This is the interface for the <code>django.views.View</code> class which allows us to use components as Django views with <code>component.as_view()</code>.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag.</p> <p>Any additional args and kwargs are passed to the <code>response_class</code>.</p> <p>Example: <pre><code>MyComponent.render_to_response(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n    # HttpResponse input\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render_to_response(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"\n    Render the component and wrap the content in the response class.\n\n    The response class is taken from `Component.response_class`. Defaults to `django.http.HttpResponse`.\n\n    This is the interface for the `django.views.View` class which allows us to\n    use components as Django views with `component.as_view()`.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n\n    Any additional args and kwargs are passed to the `response_class`.\n\n    Example:\n    ```py\n    MyComponent.render_to_response(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n        # HttpResponse input\n        status=201,\n        headers={...},\n    )\n    # HttpResponse(content=..., status=201, headers=...)\n    ```\n    \"\"\"\n    content = cls.render(\n        args=args,\n        kwargs=kwargs,\n        context=context,\n        slots=slots,\n        escape_slots_content=escape_slots_content,\n        type=type,\n        render_dependencies=True,\n    )\n    return cls.response_class(content, *response_args, **response_kwargs)\n</code></pre>"},{"location":"reference/django_components/#django_components.component.ComponentNode","title":"ComponentNode","text":"<pre><code>ComponentNode(\n    name: str,\n    args: List[Expression],\n    kwargs: RuntimeKwargs,\n    registry: ComponentRegistry,\n    isolated_context: bool = False,\n    nodelist: Optional[NodeList] = None,\n    node_id: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>BaseNode</code></p> <p>Django.template.Node subclass that renders a django-components component</p> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    args: List[Expression],\n    kwargs: RuntimeKwargs,\n    registry: ComponentRegistry,  # noqa F811\n    isolated_context: bool = False,\n    nodelist: Optional[NodeList] = None,\n    node_id: Optional[str] = None,\n) -&gt; None:\n    super().__init__(nodelist=nodelist or NodeList(), args=args, kwargs=kwargs, node_id=node_id)\n\n    self.name = name\n    self.isolated_context = isolated_context\n    self.registry = registry\n</code></pre>"},{"location":"reference/django_components/#django_components.component.ComponentVars","title":"ComponentVars","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Type for the variables available inside the component templates.</p> <p>All variables here are scoped under <code>component_vars.</code>, so e.g. attribute <code>is_filled</code> on this class is accessible inside the template as:</p> <pre><code>{{ component_vars.is_filled }}\n</code></pre> <p>Attributes:</p> <ul> <li> <code>is_filled</code>               (<code>Dict[str, bool]</code>)           \u2013            <p>Dictonary describing which component slots are filled (<code>True</code>) or are not (<code>False</code>).</p> </li> </ul>"},{"location":"reference/django_components/#django_components.component.ComponentVars.is_filled","title":"is_filled  <code>instance-attribute</code>","text":"<pre><code>is_filled: Dict[str, bool]\n</code></pre> <p>Dictonary describing which component slots are filled (<code>True</code>) or are not (<code>False</code>).</p> <p>New in version 0.70</p> <p>Use as <code>{{ component_vars.is_filled }}</code></p> <p>Example:</p> <pre><code>{# Render wrapping HTML only if the slot is defined #}\n{% if component_vars.is_filled.my_slot %}\n    &lt;div class=\"slot-wrapper\"&gt;\n        {% slot \"my_slot\" / %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre>"},{"location":"reference/django_components/#django_components.component.ComponentView","title":"ComponentView","text":"<pre><code>ComponentView(component: Component, **kwargs: Any)\n</code></pre> <p>               Bases: <code>View</code></p> <p>Subclass of <code>django.views.View</code> where the <code>Component</code> instance is available via <code>self.component</code>.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(self, component: \"Component\", **kwargs: Any) -&gt; None:\n    super().__init__(**kwargs)\n    self.component = component\n</code></pre>"},{"location":"reference/django_components/#django_components.component_media","title":"component_media","text":"<p>Classes:</p> <ul> <li> <code>ComponentMediaInput</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>MediaMeta</code>           \u2013            <p>Metaclass for handling media files for components.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.component_media.ComponentMediaInput","title":"ComponentMediaInput","text":"<p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/#django_components.component_media.MediaMeta","title":"MediaMeta","text":"<p>               Bases: <code>MediaDefiningClass</code></p> <p>Metaclass for handling media files for components.</p> <p>Similar to <code>MediaDefiningClass</code>, this class supports the use of <code>Media</code> attribute to define associated JS/CSS files, which are then available under <code>media</code> attribute as a instance of <code>Media</code> class.</p> <p>This subclass has following changes:</p>"},{"location":"reference/django_components/#django_components.component_media.MediaMeta--1-support-for-multiple-interfaces-of-jscss","title":"1. Support for multiple interfaces of JS/CSS","text":"<ol> <li> <p>As plain strings     <pre><code>class MyComponent(Component):\n    class Media:\n        js = \"path/to/script.js\"\n        css = \"path/to/style.css\"\n</code></pre></p> </li> <li> <p>As lists     <pre><code>class MyComponent(Component):\n    class Media:\n        js = [\"path/to/script1.js\", \"path/to/script2.js\"]\n        css = [\"path/to/style1.css\", \"path/to/style2.css\"]\n</code></pre></p> </li> <li> <p>[CSS ONLY] Dicts of strings     <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": \"path/to/style1.css\",\n            \"print\": \"path/to/style2.css\",\n        }\n</code></pre></p> </li> <li> <p>[CSS ONLY] Dicts of lists     <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": [\"path/to/style1.css\"],\n            \"print\": [\"path/to/style2.css\"],\n        }\n</code></pre></p> </li> </ol>"},{"location":"reference/django_components/#django_components.component_media.MediaMeta--2-media-are-first-resolved-relative-to-class-definition-file","title":"2. Media are first resolved relative to class definition file","text":"<p>E.g. if in a directory <code>my_comp</code> you have <code>script.js</code> and <code>my_comp.py</code>, and <code>my_comp.py</code> looks like this:</p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = \"script.js\"\n</code></pre> <p>Then <code>script.js</code> will be resolved as <code>my_comp/script.js</code>.</p>"},{"location":"reference/django_components/#django_components.component_media.MediaMeta--3-media-can-be-defined-as-str-bytes-pathlike-safestring-or-function-of-thereof","title":"3. Media can be defined as str, bytes, PathLike, SafeString, or function of thereof","text":"<p>E.g.:</p> <pre><code>def lazy_eval_css():\n    # do something\n    return path\n\nclass MyComponent(Component):\n    class Media:\n        js = b\"script.js\"\n        css = lazy_eval_css\n</code></pre>"},{"location":"reference/django_components/#django_components.component_media.MediaMeta--4-subclass-media-class-with-media_class","title":"4. Subclass <code>Media</code> class with <code>media_class</code>","text":"<p>Normal <code>MediaDefiningClass</code> creates an instance of <code>Media</code> class under the <code>media</code> attribute. This class allows to override which class will be instantiated with <code>media_class</code> attribute:</p> <pre><code>class MyMedia(Media):\n    def render_js(self):\n        ...\n\nclass MyComponent(Component):\n    media_class = MyMedia\n    def get_context_data(self):\n        assert isinstance(self.media, MyMedia)\n</code></pre>"},{"location":"reference/django_components/#django_components.component_registry","title":"component_registry","text":"<p>Classes:</p> <ul> <li> <code>AlreadyRegistered</code>           \u2013            <p>Raised when you try to register a Component,</p> </li> <li> <code>ComponentRegistry</code>           \u2013            <p>Manages components and makes them available</p> </li> <li> <code>NotRegistered</code>           \u2013            <p>Raised when you try to access a Component,</p> </li> <li> <code>RegistrySettings</code>           \u2013            <p>Configuration for a <code>ComponentRegistry</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>register</code>             \u2013              <p>Class decorator for registering a component</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            <p>The default and global component registry.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.component_registry.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry: ComponentRegistry = ComponentRegistry()\n</code></pre> <p>The default and global component registry. Use this instance to directly register or remove components:</p> <p>See Registering components.</p> <pre><code># Register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n\n# Get single\nregistry.get(\"button\")\n\n# Get all\nregistry.all()\n\n# Unregister single\nregistry.unregister(\"button\")\n\n# Unregister all\nregistry.clear()\n</code></pre>"},{"location":"reference/django_components/#django_components.component_registry.AlreadyRegistered","title":"AlreadyRegistered","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when you try to register a Component, but it's already registered with given ComponentRegistry.</p>"},{"location":"reference/django_components/#django_components.component_registry.ComponentRegistry","title":"ComponentRegistry","text":"<pre><code>ComponentRegistry(\n    library: Optional[Library] = None, settings: Optional[Union[RegistrySettings, Callable[[ComponentRegistry], RegistrySettings]]] = None\n)\n</code></pre> <p>Manages components and makes them available in the template, by default as <code>{% component %}</code> tags.</p> <pre><code>{% component \"my_comp\" key=value %}\n{% endcomponent %}\n</code></pre> <p>To enable a component to be used in a template, the component must be registered with a component registry.</p> <p>When you register a component to a registry, behind the scenes the registry automatically adds the component's template tag (e.g. <code>{% component %}</code> to the <code>Library</code>. And the opposite happens when you unregister a component - the tag is removed.</p> <p>See Registering components.</p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>, default:                   <code>None</code> )           \u2013            <p>Django            <code>Library</code>            associated with this registry. If omitted, the default Library instance from django_components is used.</p> </li> <li> <code>settings</code>               (<code>Union[RegistrySettings, Callable[[ComponentRegistry], RegistrySettings]]</code>, default:                   <code>None</code> )           \u2013            <p>Configure            how the components registered with this registry will behave when rendered.            See <code>RegistrySettings</code>. Can be either            a static value or a callable that returns the settings. If omitted, the settings from            <code>COMPONENTS</code> are used.</p> </li> </ul> <p>Notes:</p> <ul> <li>The default registry is available as <code>django_components.registry</code>.</li> <li>The default registry is used when registering components with <code>@register</code> decorator.</li> </ul> <p>Example:</p> <pre><code># Use with default Library\nregistry = ComponentRegistry()\n\n# Or a custom one\nmy_lib = Library()\nregistry = ComponentRegistry(library=my_lib)\n\n# Usage\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\nregistry.all()\nregistry.clear()\nregistry.get()\n</code></pre>"},{"location":"reference/django_components/#django_components.component_registry.ComponentRegistry--using-registry-to-share-components","title":"Using registry to share components","text":"<p>You can use component registry for isolating or \"packaging\" components:</p> <ol> <li> <p>Create new instance of <code>ComponentRegistry</code> and Library:     <pre><code>my_comps = Library()\nmy_comps_reg = ComponentRegistry(library=my_comps)\n</code></pre></p> </li> <li> <p>Register components to the registry:     <pre><code>my_comps_reg.register(\"my_button\", ButtonComponent)\nmy_comps_reg.register(\"my_card\", CardComponent)\n</code></pre></p> </li> <li> <p>In your target project, load the Library associated with the registry:     <pre><code>{% load my_comps %}\n</code></pre></p> </li> <li> <p>Use the registered components in your templates:     <pre><code>{% component \"button\" %}\n{% endcomponent %}\n</code></pre></p> </li> </ol> <p>Methods:</p> <ul> <li> <code>all</code>             \u2013              <p>Retrieve all registered <code>Component</code> classes.</p> </li> <li> <code>clear</code>             \u2013              <p>Clears the registry, unregistering all components.</p> </li> <li> <code>get</code>             \u2013              <p>Retrieve a <code>Component</code></p> </li> <li> <code>register</code>             \u2013              <p>Register a <code>Component</code> class</p> </li> <li> <code>unregister</code>             \u2013              <p>Unregister the <code>Component</code> class</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            <p>The template tag <code>Library</code></p> </li> <li> <code>settings</code>               (<code>InternalRegistrySettings</code>)           \u2013            <p>Registry settings configured for this registry.</p> </li> </ul> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def __init__(\n    self,\n    library: Optional[Library] = None,\n    settings: Optional[Union[RegistrySettings, Callable[[\"ComponentRegistry\"], RegistrySettings]]] = None,\n) -&gt; None:\n    self._registry: Dict[str, ComponentRegistryEntry] = {}  # component name -&gt; component_entry mapping\n    self._tags: Dict[str, Set[str]] = {}  # tag -&gt; list[component names]\n    self._library = library\n    self._settings_input = settings\n    self._settings: Optional[Callable[[], InternalRegistrySettings]] = None\n\n    all_registries.append(self)\n</code></pre>"},{"location":"reference/django_components/#django_components.component_registry.ComponentRegistry.library","title":"library  <code>property</code>","text":"<pre><code>library: Library\n</code></pre> <p>The template tag <code>Library</code> that is associated with the registry.</p>"},{"location":"reference/django_components/#django_components.component_registry.ComponentRegistry.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: InternalRegistrySettings\n</code></pre> <p>Registry settings configured for this registry.</p>"},{"location":"reference/django_components/#django_components.component_registry.ComponentRegistry.all","title":"all","text":"<pre><code>all() -&gt; Dict[str, Type[Component]]\n</code></pre> <p>Retrieve all registered <code>Component</code> classes.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Type[Component]]</code>           \u2013            <p>Dict[str, Type[Component]]: A dictionary of component names to component classes</p> </li> </ul> <p>Example:</p> <pre><code># First register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n# Then get all\nregistry.all()\n# &gt; {\n# &gt;   \"button\": ButtonComponent,\n# &gt;   \"card\": CardComponent,\n# &gt; }\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def all(self) -&gt; Dict[str, Type[\"Component\"]]:\n    \"\"\"\n    Retrieve all registered [`Component`](../api#django_components.Component) classes.\n\n    Returns:\n        Dict[str, Type[Component]]: A dictionary of component names to component classes\n\n    **Example:**\n\n    ```python\n    # First register components\n    registry.register(\"button\", ButtonComponent)\n    registry.register(\"card\", CardComponent)\n    # Then get all\n    registry.all()\n    # &gt; {\n    # &gt;   \"button\": ButtonComponent,\n    # &gt;   \"card\": CardComponent,\n    # &gt; }\n    ```\n    \"\"\"\n    comps = {key: entry.cls for key, entry in self._registry.items()}\n    return comps\n</code></pre>"},{"location":"reference/django_components/#django_components.component_registry.ComponentRegistry.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clears the registry, unregistering all components.</p> <p>Example:</p> <pre><code># First register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n# Then clear\nregistry.clear()\n# Then get all\nregistry.all()\n# &gt; {}\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Clears the registry, unregistering all components.\n\n    Example:\n\n    ```python\n    # First register components\n    registry.register(\"button\", ButtonComponent)\n    registry.register(\"card\", CardComponent)\n    # Then clear\n    registry.clear()\n    # Then get all\n    registry.all()\n    # &gt; {}\n    ```\n    \"\"\"\n    all_comp_names = list(self._registry.keys())\n    for comp_name in all_comp_names:\n        self.unregister(comp_name)\n\n    self._registry = {}\n    self._tags = {}\n</code></pre>"},{"location":"reference/django_components/#django_components.component_registry.ComponentRegistry.get","title":"get","text":"<pre><code>get(name: str) -&gt; Type[Component]\n</code></pre> <p>Retrieve a <code>Component</code> class registered under the given name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component was registered. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Type[Component]</code>           \u2013            <p>Type[Component]: The component class registered under the given name.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>NotRegistered</code>   if the given name is not registered.</li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then get\nregistry.get(\"button\")\n# &gt; ButtonComponent\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def get(self, name: str) -&gt; Type[\"Component\"]:\n    \"\"\"\n    Retrieve a [`Component`](../api#django_components.Component)\n    class registered under the given name.\n\n    Args:\n        name (str): The name under which the component was registered. Required.\n\n    Returns:\n        Type[Component]: The component class registered under the given name.\n\n    **Raises:**\n\n    - [`NotRegistered`](../exceptions#django_components.NotRegistered)\n      if the given name is not registered.\n\n    **Example:**\n\n    ```python\n    # First register component\n    registry.register(\"button\", ButtonComponent)\n    # Then get\n    registry.get(\"button\")\n    # &gt; ButtonComponent\n    ```\n    \"\"\"\n    if name not in self._registry:\n        raise NotRegistered('The component \"%s\" is not registered' % name)\n\n    return self._registry[name].cls\n</code></pre>"},{"location":"reference/django_components/#django_components.component_registry.ComponentRegistry.register","title":"register","text":"<pre><code>register(name: str, component: Type[Component]) -&gt; None\n</code></pre> <p>Register a <code>Component</code> class with this registry under the given name.</p> <p>A component MUST be registered before it can be used in a template such as: <pre><code>{% component \"my_comp\" %}\n{% endcomponent %}\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component will be registered. Required.</p> </li> <li> <code>component</code>               (<code>Type[Component]</code>)           \u2013            <p>The component class to register. Required.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>AlreadyRegistered</code> if a different component was already registered under the same name.</li> </ul> <p>Example:</p> <pre><code>registry.register(\"button\", ButtonComponent)\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def register(self, name: str, component: Type[\"Component\"]) -&gt; None:\n    \"\"\"\n    Register a [`Component`](../api#django_components.Component) class\n    with this registry under the given name.\n\n    A component MUST be registered before it can be used in a template such as:\n    ```django\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n    ```\n\n    Args:\n        name (str): The name under which the component will be registered. Required.\n        component (Type[Component]): The component class to register. Required.\n\n    **Raises:**\n\n    - [`AlreadyRegistered`](../exceptions#django_components.AlreadyRegistered)\n    if a different component was already registered under the same name.\n\n    **Example:**\n\n    ```python\n    registry.register(\"button\", ButtonComponent)\n    ```\n    \"\"\"\n    existing_component = self._registry.get(name)\n    if existing_component and existing_component.cls._class_hash != component._class_hash:\n        raise AlreadyRegistered('The component \"%s\" has already been registered' % name)\n\n    entry = self._register_to_library(name, component)\n\n    # Keep track of which components use which tags, because multiple components may\n    # use the same tag.\n    tag = entry.tag\n    if tag not in self._tags:\n        self._tags[tag] = set()\n    self._tags[tag].add(name)\n\n    self._registry[name] = entry\n</code></pre>"},{"location":"reference/django_components/#django_components.component_registry.ComponentRegistry.unregister","title":"unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Unregister the <code>Component</code> class that was registered under the given name.</p> <p>Once a component is unregistered, it is no longer available in the templates.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component is registered. Required.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>NotRegistered</code> if the given name is not registered.</li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then unregister\nregistry.unregister(\"button\")\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def unregister(self, name: str) -&gt; None:\n    \"\"\"\n    Unregister the [`Component`](../api#django_components.Component) class\n    that was registered under the given name.\n\n    Once a component is unregistered, it is no longer available in the templates.\n\n    Args:\n        name (str): The name under which the component is registered. Required.\n\n    **Raises:**\n\n    - [`NotRegistered`](../exceptions#django_components.NotRegistered)\n    if the given name is not registered.\n\n    **Example:**\n\n    ```python\n    # First register component\n    registry.register(\"button\", ButtonComponent)\n    # Then unregister\n    registry.unregister(\"button\")\n    ```\n    \"\"\"\n    # Validate\n    self.get(name)\n\n    entry = self._registry[name]\n    tag = entry.tag\n\n    # Unregister the tag from library if this was the last component using this tag\n    # Unlink component from tag\n    self._tags[tag].remove(name)\n\n    # Cleanup\n    is_tag_empty = not len(self._tags[tag])\n    if is_tag_empty:\n        del self._tags[tag]\n\n    # Only unregister a tag if it's NOT protected\n    is_protected = is_tag_protected(self.library, tag)\n    if not is_protected:\n        # Unregister the tag from library if this was the last component using this tag\n        if is_tag_empty and tag in self.library.tags:\n            del self.library.tags[tag]\n\n    del self._registry[name]\n</code></pre>"},{"location":"reference/django_components/#django_components.component_registry.NotRegistered","title":"NotRegistered","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when you try to access a Component, but it's NOT registered with given ComponentRegistry.</p>"},{"location":"reference/django_components/#django_components.component_registry.RegistrySettings","title":"RegistrySettings","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Configuration for a <code>ComponentRegistry</code>.</p> <p>These settings define how the components registered with this registry will behave when rendered.</p> <pre><code>from django_components import ComponentRegistry, RegistrySettings\n\nregistry_settings = RegistrySettings(\n    context_behavior=\"django\",\n    tag_formatter=\"django_components.component_shorthand_formatter\",\n)\n\nregistry = ComponentRegistry(settings=registry_settings)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>CONTEXT_BEHAVIOR</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            <p>Deprecated. Use <code>context_behavior</code> instead. Will be removed in v1.</p> </li> <li> <code>TAG_FORMATTER</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            <p>Deprecated. Use <code>tag_formatter</code> instead. Will be removed in v1.</p> </li> <li> <code>context_behavior</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            <p>Same as the global</p> </li> <li> <code>tag_formatter</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            <p>Same as the global</p> </li> </ul>"},{"location":"reference/django_components/#django_components.component_registry.RegistrySettings.CONTEXT_BEHAVIOR","title":"CONTEXT_BEHAVIOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTEXT_BEHAVIOR: Optional[ContextBehaviorType] = None\n</code></pre> <p>Deprecated. Use <code>context_behavior</code> instead. Will be removed in v1.</p> <p>Same as the global <code>COMPONENTS.context_behavior</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.context_behavior</code> setting.</p>"},{"location":"reference/django_components/#django_components.component_registry.RegistrySettings.TAG_FORMATTER","title":"TAG_FORMATTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAG_FORMATTER: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>Deprecated. Use <code>tag_formatter</code> instead. Will be removed in v1.</p> <p>Same as the global <code>COMPONENTS.tag_formatter</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.tag_formatter</code> setting.</p>"},{"location":"reference/django_components/#django_components.component_registry.RegistrySettings.context_behavior","title":"context_behavior  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>Same as the global <code>COMPONENTS.context_behavior</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.context_behavior</code> setting.</p>"},{"location":"reference/django_components/#django_components.component_registry.RegistrySettings.tag_formatter","title":"tag_formatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>Same as the global <code>COMPONENTS.tag_formatter</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.tag_formatter</code> setting.</p>"},{"location":"reference/django_components/#django_components.component_registry.register","title":"register","text":"<pre><code>register(name: str, registry: Optional[ComponentRegistry] = None) -&gt; Callable[\n    [Type[Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]]],\n    Type[Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]],\n]\n</code></pre> <p>Class decorator for registering a component to a component registry.</p> <p>See Registering components.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Registered name. This is the name by which the component will be accessed            from within a template when using the <code>{% component %}</code> tag. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to which to register this component. If omitted, component is registered to the default registry.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AlreadyRegistered</code>             \u2013            <p>If there is already a component registered under the same name.</p> </li> </ul> <p>Examples:</p> <pre><code>from django_components import Component, register\n\n@register(\"my_component\")\nclass MyComponent(Component):\n    ...\n</code></pre> <p>Specifing <code>ComponentRegistry</code> the component should be registered to by setting the <code>registry</code> kwarg:</p> <pre><code>from django.template import Library\nfrom django_components import Component, ComponentRegistry, register\n\nmy_lib = Library()\nmy_reg = ComponentRegistry(library=my_lib)\n\n@register(\"my_component\", registry=my_reg)\nclass MyComponent(Component):\n    ...\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def register(name: str, registry: Optional[ComponentRegistry] = None) -&gt; Callable[\n    [Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"]],\n    Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"],\n]:\n    \"\"\"\n    Class decorator for registering a [component](./#django_components.Component)\n    to a [component registry](./#django_components.ComponentRegistry).\n\n    See [Registering components](../../concepts/advanced/component_registry).\n\n    Args:\n        name (str): Registered name. This is the name by which the component will be accessed\\\n            from within a template when using the [`{% component %}`](../template_tags#component) tag. Required.\n        registry (ComponentRegistry, optional): Specify the [registry](./#django_components.ComponentRegistry)\\\n            to which to register this component. If omitted, component is registered to the default registry.\n\n    Raises:\n        AlreadyRegistered: If there is already a component registered under the same name.\n\n    **Examples**:\n\n    ```python\n    from django_components import Component, register\n\n    @register(\"my_component\")\n    class MyComponent(Component):\n        ...\n    ```\n\n    Specifing [`ComponentRegistry`](./#django_components.ComponentRegistry) the component\n    should be registered to by setting the `registry` kwarg:\n\n    ```python\n    from django.template import Library\n    from django_components import Component, ComponentRegistry, register\n\n    my_lib = Library()\n    my_reg = ComponentRegistry(library=my_lib)\n\n    @register(\"my_component\", registry=my_reg)\n    class MyComponent(Component):\n        ...\n    ```\n    \"\"\"\n    if registry is None:\n        registry = _the_registry\n\n    def decorator(\n        component: Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"],\n    ) -&gt; Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"]:\n        registry.register(name=name, component=component)\n        return component\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/#django_components.components","title":"components","text":"<p>Modules:</p> <ul> <li> <code>dynamic</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>DynamicComponent</code>           \u2013            <p>This component is given a registered name or a reference to another component,</p> </li> </ul>"},{"location":"reference/django_components/#django_components.components.DynamicComponent","title":"DynamicComponent","text":"<pre><code>DynamicComponent(\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>This component is given a registered name or a reference to another component, and behaves as if the other component was in its place.</p> <p>The args, kwargs, and slot fills are all passed down to the underlying component.</p> <p>Parameters:</p> <ul> <li> <code>is</code>               (<code>str | Type[Component]</code>)           \u2013            <p>Component that should be rendered. Either a registered name of a component, or a Component class directly. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to search for the registered name. If omitted, all registries are searched until the first match.</p> </li> <li> <code>*args</code>           \u2013            <p>Additional data passed to the component.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional data passed to the component.</p> </li> </ul> <p>Slots:</p> <ul> <li>Any slots, depending on the actual component.</li> </ul> <p>Examples:</p> <p>Django <pre><code>{% component \"dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Python <pre><code>from django_components import DynamicComponent\n\nDynamicComponent.render(\n    kwargs={\n        \"is\": table_comp,\n        \"data\": table_data,\n        \"headers\": table_headers,\n    },\n    slots={\n        \"pagination\": PaginationComponent.render(\n            render_dependencies=False,\n        ),\n    },\n)\n</code></pre></p>"},{"location":"reference/django_components/#django_components.components.DynamicComponent--use-cases","title":"Use cases","text":"<p>Dynamic components are suitable if you are writing something like a form component. You may design it such that users give you a list of input types, and you render components depending on the input types.</p> <p>While you could handle this with a series of if / else statements, that's not an extensible approach. Instead, you can use the dynamic component in place of normal components.</p>"},{"location":"reference/django_components/#django_components.components.DynamicComponent--component-name","title":"Component name","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can set the <code>COMPONENTS.dynamic_component_name</code> setting to change the name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name: <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> </li> <li> <code>get_template</code>             \u2013              <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>get_template_name</code>             \u2013              <p>Filepath to the Django template associated with this component.</p> </li> <li> <code>inject</code>             \u2013              <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag</p> </li> <li> <code>on_render_after</code>             \u2013              <p>Hook that runs just after the component's template was rendered.</p> </li> <li> <code>on_render_before</code>             \u2013              <p>Hook that runs just before the component's template is rendered.</p> </li> <li> <code>render</code>             \u2013              <p>Render the component into a string.</p> </li> <li> <code>render_to_response</code>             \u2013              <p>Render the component and wrap the content in the response class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Media</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined CSS associated with this component.</p> </li> <li> <code>input</code>               (<code>RenderInput[ArgsType, KwargsType, SlotsType]</code>)           \u2013            <p>Input holds the data (like arg, kwargs, slots) that were passsed to</p> </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            <p>Dictionary describing which slots have or have not been filled.</p> </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined JS associated with this component.</p> </li> <li> <code>media</code>               (<code>Media</code>)           \u2013            <p>Normalized definition of JS and CSS media files associated with this component.</p> </li> <li> <code>response_class</code>           \u2013            <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p> </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Filepath to the Django template associated with this component.</p> </li> </ul> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,  # noqa F811\n):\n    # When user first instantiates the component class before calling\n    # `render` or `render_to_response`, then we want to allow the render\n    # function to make use of the instantiated object.\n    #\n    # So while `MyComp.render()` creates a new instance of MyComp internally,\n    # if we do `MyComp(registered_name=\"abc\").render()`, then we use the\n    # already-instantiated object.\n    #\n    # To achieve that, we want to re-assign the class methods as instance methods.\n    # For that we have to \"unwrap\" the class methods via __func__.\n    # See https://stackoverflow.com/a/76706399/9788634\n    self.render_to_response = types.MethodType(self.__class__.render_to_response.__func__, self)  # type: ignore\n    self.render = types.MethodType(self.__class__.render.__func__, self)  # type: ignore\n    self.as_view = types.MethodType(self.__class__.as_view.__func__, self)  # type: ignore\n\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.component_id = component_id or gen_id()\n    self.registry = registry or registry_\n    self._render_stack: Deque[RenderStackItem[ArgsType, KwargsType, SlotsType]] = deque()\n    # None == uninitialized, False == No types, Tuple == types\n    self._types: Optional[Union[Tuple[Any, Any, Any, Any, Any, Any], Literal[False]]] = None\n</code></pre>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.Media","title":"Media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Media = ComponentMediaInput\n</code></pre> <p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>Inlined CSS associated with this component.</p>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.input","title":"input  <code>property</code>","text":"<pre><code>input: RenderInput[ArgsType, KwargsType, SlotsType]\n</code></pre> <p>Input holds the data (like arg, kwargs, slots) that were passsed to the current execution of the <code>render</code> method.</p>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.is_filled","title":"is_filled  <code>property</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within the template as <code>{{ component_vars.is_filled.slot_name }}</code>, and within <code>on_render_before</code> and <code>on_render_after</code> hooks.</p>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>Inlined JS associated with this component.</p>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.media","title":"media  <code>instance-attribute</code>","text":"<pre><code>media: Media\n</code></pre> <p>Normalized definition of JS and CSS media files associated with this component.</p> <p>NOTE: This field is generated from Component.Media class.</p>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.response_class","title":"response_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>response_class = HttpResponse\n</code></pre> <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.template_name","title":"template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = None\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef as_view(cls, **initkwargs: Any) -&gt; ViewFn:\n    \"\"\"\n    Shortcut for calling `Component.View.as_view` and passing component instance to it.\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    # Allow the View class to access this component via `self.component`\n    return comp.View.as_view(**initkwargs, component=comp)\n</code></pre>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template(self, context: Context) -&gt; Optional[Union[str, Template]]:\n    \"\"\"\n    Inlined Django template associated with this component. Can be a plain string or a Template instance.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template_name(self, context: Context) -&gt; Optional[str]:\n    \"\"\"\n    Filepath to the Django template associated with this component.\n\n    The filepath must be relative to either the file where the component class was defined,\n    or one of the roots of `STATIFILES_DIRS`.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>provide</code> tag with given key was NOT found.</p> <p>This method mut be used inside the <code>get_context_data()</code> method and raises an error if called elsewhere.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"provider\" hello=\"world\" %}\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ data.hello }}!\"\n    def get_context_data(self):\n        data = self.inject(\"provider\")\n        return {\"data\": data}\n</code></pre></p> <p>This renders into: <pre><code>hi world!\n</code></pre></p> <p>As the <code>{{ data.hello }}</code> is taken from the \"provider\".</p> Source code in <code>src/django_components/component.py</code> <pre><code>def inject(self, key: str, default: Optional[Any] = None) -&gt; Any:\n    \"\"\"\n    Use this method to retrieve the data that was passed to a `{% provide %}` tag\n    with the corresponding key.\n\n    To retrieve the data, `inject()` must be called inside a component that's\n    inside the `{% provide %}` tag.\n\n    You may also pass a default that will be used if the `provide` tag with given\n    key was NOT found.\n\n    This method mut be used inside the `get_context_data()` method and raises\n    an error if called elsewhere.\n\n    Example:\n\n    Given this template:\n    ```django\n    {% provide \"provider\" hello=\"world\" %}\n        {% component \"my_comp\" %}\n        {% endcomponent %}\n    {% endprovide %}\n    ```\n\n    And given this definition of \"my_comp\" component:\n    ```py\n    from django_components import Component, register\n\n    @register(\"my_comp\")\n    class MyComp(Component):\n        template = \"hi {{ data.hello }}!\"\n        def get_context_data(self):\n            data = self.inject(\"provider\")\n            return {\"data\": data}\n    ```\n\n    This renders into:\n    ```\n    hi world!\n    ```\n\n    As the `{{ data.hello }}` is taken from the \"provider\".\n    \"\"\"\n    if self.input is None:\n        raise RuntimeError(\n            f\"Method 'inject()' of component '{self.name}' was called outside of 'get_context_data()'\"\n        )\n\n    return get_injected_context_var(self.name, self.input.context, key, default)\n</code></pre>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Template, content: str) -&gt; Optional[SlotResult]\n</code></pre> <p>Hook that runs just after the component's template was rendered. It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_after(self, context: Context, template: Template, content: str) -&gt; Optional[SlotResult]:\n    \"\"\"\n    Hook that runs just after the component's template was rendered.\n    It receives the rendered output as the last argument.\n\n    You can use this hook to access the context or the template, but modifying\n    them won't have any effect.\n\n    To override the content that gets rendered, you can return a string or SafeString\n    from this hook.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Template) -&gt; None\n</code></pre> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_before(self, context: Context, template: Template) -&gt; None:\n    \"\"\"\n    Hook that runs just before the component's template is rendered.\n\n    You can use this hook to access or modify the context or the template.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str\n</code></pre> <p>Render the component into a string.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag. - <code>render_dependencies</code> - Set this to <code>False</code> if you want to insert the resulting HTML into another component.</p> <p>Example: <pre><code>MyComponent.render(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str:\n    \"\"\"\n    Render the component into a string.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n    - `render_dependencies` - Set this to `False` if you want to insert the resulting HTML into another component.\n\n    Example:\n    ```py\n    MyComponent.render(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n    )\n    ```\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    return comp._render(context, args, kwargs, slots, escape_slots_content, type, render_dependencies)\n</code></pre>"},{"location":"reference/django_components/#django_components.components.DynamicComponent.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and wrap the content in the response class.</p> <p>The response class is taken from <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <p>This is the interface for the <code>django.views.View</code> class which allows us to use components as Django views with <code>component.as_view()</code>.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag.</p> <p>Any additional args and kwargs are passed to the <code>response_class</code>.</p> <p>Example: <pre><code>MyComponent.render_to_response(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n    # HttpResponse input\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render_to_response(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"\n    Render the component and wrap the content in the response class.\n\n    The response class is taken from `Component.response_class`. Defaults to `django.http.HttpResponse`.\n\n    This is the interface for the `django.views.View` class which allows us to\n    use components as Django views with `component.as_view()`.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n\n    Any additional args and kwargs are passed to the `response_class`.\n\n    Example:\n    ```py\n    MyComponent.render_to_response(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n        # HttpResponse input\n        status=201,\n        headers={...},\n    )\n    # HttpResponse(content=..., status=201, headers=...)\n    ```\n    \"\"\"\n    content = cls.render(\n        args=args,\n        kwargs=kwargs,\n        context=context,\n        slots=slots,\n        escape_slots_content=escape_slots_content,\n        type=type,\n        render_dependencies=True,\n    )\n    return cls.response_class(content, *response_args, **response_kwargs)\n</code></pre>"},{"location":"reference/django_components/#django_components.components.dynamic","title":"dynamic","text":"<p>Modules:</p> <ul> <li> <code>types</code>           \u2013            <p>Helper types for IDEs.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DynamicComponent</code>           \u2013            <p>This component is given a registered name or a reference to another component,</p> </li> </ul>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent","title":"DynamicComponent","text":"<pre><code>DynamicComponent(\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>This component is given a registered name or a reference to another component, and behaves as if the other component was in its place.</p> <p>The args, kwargs, and slot fills are all passed down to the underlying component.</p> <p>Parameters:</p> <ul> <li> <code>is</code>               (<code>str | Type[Component]</code>)           \u2013            <p>Component that should be rendered. Either a registered name of a component, or a Component class directly. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to search for the registered name. If omitted, all registries are searched until the first match.</p> </li> <li> <code>*args</code>           \u2013            <p>Additional data passed to the component.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional data passed to the component.</p> </li> </ul> <p>Slots:</p> <ul> <li>Any slots, depending on the actual component.</li> </ul> <p>Examples:</p> <p>Django <pre><code>{% component \"dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Python <pre><code>from django_components import DynamicComponent\n\nDynamicComponent.render(\n    kwargs={\n        \"is\": table_comp,\n        \"data\": table_data,\n        \"headers\": table_headers,\n    },\n    slots={\n        \"pagination\": PaginationComponent.render(\n            render_dependencies=False,\n        ),\n    },\n)\n</code></pre></p>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent--use-cases","title":"Use cases","text":"<p>Dynamic components are suitable if you are writing something like a form component. You may design it such that users give you a list of input types, and you render components depending on the input types.</p> <p>While you could handle this with a series of if / else statements, that's not an extensible approach. Instead, you can use the dynamic component in place of normal components.</p>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent--component-name","title":"Component name","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can set the <code>COMPONENTS.dynamic_component_name</code> setting to change the name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name: <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> </li> <li> <code>get_template</code>             \u2013              <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>get_template_name</code>             \u2013              <p>Filepath to the Django template associated with this component.</p> </li> <li> <code>inject</code>             \u2013              <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag</p> </li> <li> <code>on_render_after</code>             \u2013              <p>Hook that runs just after the component's template was rendered.</p> </li> <li> <code>on_render_before</code>             \u2013              <p>Hook that runs just before the component's template is rendered.</p> </li> <li> <code>render</code>             \u2013              <p>Render the component into a string.</p> </li> <li> <code>render_to_response</code>             \u2013              <p>Render the component and wrap the content in the response class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Media</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined CSS associated with this component.</p> </li> <li> <code>input</code>               (<code>RenderInput[ArgsType, KwargsType, SlotsType]</code>)           \u2013            <p>Input holds the data (like arg, kwargs, slots) that were passsed to</p> </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            <p>Dictionary describing which slots have or have not been filled.</p> </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined JS associated with this component.</p> </li> <li> <code>media</code>               (<code>Media</code>)           \u2013            <p>Normalized definition of JS and CSS media files associated with this component.</p> </li> <li> <code>response_class</code>           \u2013            <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p> </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Filepath to the Django template associated with this component.</p> </li> </ul> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,  # noqa F811\n):\n    # When user first instantiates the component class before calling\n    # `render` or `render_to_response`, then we want to allow the render\n    # function to make use of the instantiated object.\n    #\n    # So while `MyComp.render()` creates a new instance of MyComp internally,\n    # if we do `MyComp(registered_name=\"abc\").render()`, then we use the\n    # already-instantiated object.\n    #\n    # To achieve that, we want to re-assign the class methods as instance methods.\n    # For that we have to \"unwrap\" the class methods via __func__.\n    # See https://stackoverflow.com/a/76706399/9788634\n    self.render_to_response = types.MethodType(self.__class__.render_to_response.__func__, self)  # type: ignore\n    self.render = types.MethodType(self.__class__.render.__func__, self)  # type: ignore\n    self.as_view = types.MethodType(self.__class__.as_view.__func__, self)  # type: ignore\n\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.component_id = component_id or gen_id()\n    self.registry = registry or registry_\n    self._render_stack: Deque[RenderStackItem[ArgsType, KwargsType, SlotsType]] = deque()\n    # None == uninitialized, False == No types, Tuple == types\n    self._types: Optional[Union[Tuple[Any, Any, Any, Any, Any, Any], Literal[False]]] = None\n</code></pre>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.Media","title":"Media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Media = ComponentMediaInput\n</code></pre> <p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>Inlined CSS associated with this component.</p>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.input","title":"input  <code>property</code>","text":"<pre><code>input: RenderInput[ArgsType, KwargsType, SlotsType]\n</code></pre> <p>Input holds the data (like arg, kwargs, slots) that were passsed to the current execution of the <code>render</code> method.</p>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.is_filled","title":"is_filled  <code>property</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within the template as <code>{{ component_vars.is_filled.slot_name }}</code>, and within <code>on_render_before</code> and <code>on_render_after</code> hooks.</p>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>Inlined JS associated with this component.</p>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.media","title":"media  <code>instance-attribute</code>","text":"<pre><code>media: Media\n</code></pre> <p>Normalized definition of JS and CSS media files associated with this component.</p> <p>NOTE: This field is generated from Component.Media class.</p>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.response_class","title":"response_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>response_class = HttpResponse\n</code></pre> <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.template_name","title":"template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = None\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef as_view(cls, **initkwargs: Any) -&gt; ViewFn:\n    \"\"\"\n    Shortcut for calling `Component.View.as_view` and passing component instance to it.\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    # Allow the View class to access this component via `self.component`\n    return comp.View.as_view(**initkwargs, component=comp)\n</code></pre>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template(self, context: Context) -&gt; Optional[Union[str, Template]]:\n    \"\"\"\n    Inlined Django template associated with this component. Can be a plain string or a Template instance.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template_name(self, context: Context) -&gt; Optional[str]:\n    \"\"\"\n    Filepath to the Django template associated with this component.\n\n    The filepath must be relative to either the file where the component class was defined,\n    or one of the roots of `STATIFILES_DIRS`.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>provide</code> tag with given key was NOT found.</p> <p>This method mut be used inside the <code>get_context_data()</code> method and raises an error if called elsewhere.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"provider\" hello=\"world\" %}\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ data.hello }}!\"\n    def get_context_data(self):\n        data = self.inject(\"provider\")\n        return {\"data\": data}\n</code></pre></p> <p>This renders into: <pre><code>hi world!\n</code></pre></p> <p>As the <code>{{ data.hello }}</code> is taken from the \"provider\".</p> Source code in <code>src/django_components/component.py</code> <pre><code>def inject(self, key: str, default: Optional[Any] = None) -&gt; Any:\n    \"\"\"\n    Use this method to retrieve the data that was passed to a `{% provide %}` tag\n    with the corresponding key.\n\n    To retrieve the data, `inject()` must be called inside a component that's\n    inside the `{% provide %}` tag.\n\n    You may also pass a default that will be used if the `provide` tag with given\n    key was NOT found.\n\n    This method mut be used inside the `get_context_data()` method and raises\n    an error if called elsewhere.\n\n    Example:\n\n    Given this template:\n    ```django\n    {% provide \"provider\" hello=\"world\" %}\n        {% component \"my_comp\" %}\n        {% endcomponent %}\n    {% endprovide %}\n    ```\n\n    And given this definition of \"my_comp\" component:\n    ```py\n    from django_components import Component, register\n\n    @register(\"my_comp\")\n    class MyComp(Component):\n        template = \"hi {{ data.hello }}!\"\n        def get_context_data(self):\n            data = self.inject(\"provider\")\n            return {\"data\": data}\n    ```\n\n    This renders into:\n    ```\n    hi world!\n    ```\n\n    As the `{{ data.hello }}` is taken from the \"provider\".\n    \"\"\"\n    if self.input is None:\n        raise RuntimeError(\n            f\"Method 'inject()' of component '{self.name}' was called outside of 'get_context_data()'\"\n        )\n\n    return get_injected_context_var(self.name, self.input.context, key, default)\n</code></pre>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Template, content: str) -&gt; Optional[SlotResult]\n</code></pre> <p>Hook that runs just after the component's template was rendered. It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_after(self, context: Context, template: Template, content: str) -&gt; Optional[SlotResult]:\n    \"\"\"\n    Hook that runs just after the component's template was rendered.\n    It receives the rendered output as the last argument.\n\n    You can use this hook to access the context or the template, but modifying\n    them won't have any effect.\n\n    To override the content that gets rendered, you can return a string or SafeString\n    from this hook.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Template) -&gt; None\n</code></pre> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_before(self, context: Context, template: Template) -&gt; None:\n    \"\"\"\n    Hook that runs just before the component's template is rendered.\n\n    You can use this hook to access or modify the context or the template.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str\n</code></pre> <p>Render the component into a string.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag. - <code>render_dependencies</code> - Set this to <code>False</code> if you want to insert the resulting HTML into another component.</p> <p>Example: <pre><code>MyComponent.render(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str:\n    \"\"\"\n    Render the component into a string.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n    - `render_dependencies` - Set this to `False` if you want to insert the resulting HTML into another component.\n\n    Example:\n    ```py\n    MyComponent.render(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n    )\n    ```\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    return comp._render(context, args, kwargs, slots, escape_slots_content, type, render_dependencies)\n</code></pre>"},{"location":"reference/django_components/#django_components.components.dynamic.DynamicComponent.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and wrap the content in the response class.</p> <p>The response class is taken from <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <p>This is the interface for the <code>django.views.View</code> class which allows us to use components as Django views with <code>component.as_view()</code>.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag.</p> <p>Any additional args and kwargs are passed to the <code>response_class</code>.</p> <p>Example: <pre><code>MyComponent.render_to_response(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n    # HttpResponse input\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render_to_response(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"\n    Render the component and wrap the content in the response class.\n\n    The response class is taken from `Component.response_class`. Defaults to `django.http.HttpResponse`.\n\n    This is the interface for the `django.views.View` class which allows us to\n    use components as Django views with `component.as_view()`.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n\n    Any additional args and kwargs are passed to the `response_class`.\n\n    Example:\n    ```py\n    MyComponent.render_to_response(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n        # HttpResponse input\n        status=201,\n        headers={...},\n    )\n    # HttpResponse(content=..., status=201, headers=...)\n    ```\n    \"\"\"\n    content = cls.render(\n        args=args,\n        kwargs=kwargs,\n        context=context,\n        slots=slots,\n        escape_slots_content=escape_slots_content,\n        type=type,\n        render_dependencies=True,\n    )\n    return cls.response_class(content, *response_args, **response_kwargs)\n</code></pre>"},{"location":"reference/django_components/#django_components.context","title":"context","text":"<p>This file centralizes various ways we use Django's Context class pass data across components, nodes, slots, and contexts.</p> <p>You can think of the Context as our storage system.</p> <p>Functions:</p> <ul> <li> <code>copy_forloop_context</code>             \u2013              <p>Forward the info about the current loop</p> </li> <li> <code>get_injected_context_var</code>             \u2013              <p>Retrieve a 'provided' field. The field MUST have been previously 'provided'</p> </li> <li> <code>set_provided_context_var</code>             \u2013              <p>'Provide' given data under given key. In other words, this data can be retrieved</p> </li> </ul>"},{"location":"reference/django_components/#django_components.context.copy_forloop_context","title":"copy_forloop_context","text":"<pre><code>copy_forloop_context(from_context: Context, to_context: Context) -&gt; None\n</code></pre> <p>Forward the info about the current loop</p> Source code in <code>src/django_components/context.py</code> <pre><code>def copy_forloop_context(from_context: Context, to_context: Context) -&gt; None:\n    \"\"\"Forward the info about the current loop\"\"\"\n    # Note that the ForNode (which implements for loop behavior) does not\n    # only add the `forloop` key, but also keys corresponding to the loop elements\n    # So if the loop syntax is `{% for my_val in my_lists %}`, then ForNode also\n    # sets a `my_val` key.\n    # For this reason, instead of copying individual keys, we copy the whole stack layer\n    # set by ForNode.\n    if \"forloop\" in from_context:\n        forloop_dict_index = find_last_index(from_context.dicts, lambda d: \"forloop\" in d)\n        to_context.update(from_context.dicts[forloop_dict_index])\n</code></pre>"},{"location":"reference/django_components/#django_components.context.get_injected_context_var","title":"get_injected_context_var","text":"<pre><code>get_injected_context_var(component_name: str, context: Context, key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Retrieve a 'provided' field. The field MUST have been previously 'provided' by the component's ancestors using the <code>{% provide %}</code> template tag.</p> Source code in <code>src/django_components/context.py</code> <pre><code>def get_injected_context_var(\n    component_name: str,\n    context: Context,\n    key: str,\n    default: Optional[Any] = None,\n) -&gt; Any:\n    \"\"\"\n    Retrieve a 'provided' field. The field MUST have been previously 'provided'\n    by the component's ancestors using the `{% provide %}` template tag.\n    \"\"\"\n    # NOTE: For simplicity, we keep the provided values directly on the context.\n    # This plays nicely with Django's Context, which behaves like a stack, so \"newer\"\n    # values overshadow the \"older\" ones.\n    internal_key = _INJECT_CONTEXT_KEY_PREFIX + key\n\n    # Return provided value if found\n    if internal_key in context:\n        return context[internal_key]\n\n    # If a default was given, return that\n    if default is not None:\n        return default\n\n    # Otherwise raise error\n    raise KeyError(\n        f\"Component '{component_name}' tried to inject a variable '{key}' before it was provided.\"\n        f\" To fix this, make sure that at least one ancestor of component '{component_name}' has\"\n        f\" the variable '{key}' in their 'provide' attribute.\"\n    )\n</code></pre>"},{"location":"reference/django_components/#django_components.context.set_provided_context_var","title":"set_provided_context_var","text":"<pre><code>set_provided_context_var(context: Context, key: str, provided_kwargs: Dict[str, Any]) -&gt; None\n</code></pre> <p>'Provide' given data under given key. In other words, this data can be retrieved using <code>self.inject(key)</code> inside of <code>get_context_data()</code> method of components that are nested inside the <code>{% provide %}</code> tag.</p> Source code in <code>src/django_components/context.py</code> <pre><code>def set_provided_context_var(\n    context: Context,\n    key: str,\n    provided_kwargs: Dict[str, Any],\n) -&gt; None:\n    \"\"\"\n    'Provide' given data under given key. In other words, this data can be retrieved\n    using `self.inject(key)` inside of `get_context_data()` method of components that\n    are nested inside the `{% provide %}` tag.\n    \"\"\"\n    # NOTE: We raise TemplateSyntaxError since this func should be called only from\n    # within template.\n    if not key:\n        raise TemplateSyntaxError(\n            \"Provide tag received an empty string. Key must be non-empty and a valid identifier.\"\n        )\n    if not key.isidentifier():\n        raise TemplateSyntaxError(\n            \"Provide tag received a non-identifier string. Key must be non-empty and a valid identifier.\"\n        )\n\n    # We turn the kwargs into a NamedTuple so that the object that's \"provided\"\n    # is immutable. This ensures that the data returned from `inject` will always\n    # have all the keys that were passed to the `provide` tag.\n    tpl_cls = namedtuple(\"DepInject\", provided_kwargs.keys())  # type: ignore[misc]\n    payload = tpl_cls(**provided_kwargs)\n\n    internal_key = _INJECT_CONTEXT_KEY_PREFIX + key\n    context[internal_key] = payload\n</code></pre>"},{"location":"reference/django_components/#django_components.dependencies","title":"dependencies","text":"<p>All code related to management of component dependencies (JS and CSS scripts)</p> <p>Modules:</p> <ul> <li> <code>types</code>           \u2013            <p>Helper types for IDEs.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>ComponentDependencyMiddleware</code>           \u2013            <p>Middleware that inserts CSS/JS dependencies for all rendered</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>render_dependencies</code>             \u2013              <p>Given a string that contains parts that were rendered by components,</p> </li> </ul>"},{"location":"reference/django_components/#django_components.dependencies.ComponentDependencyMiddleware","title":"ComponentDependencyMiddleware","text":"<pre><code>ComponentDependencyMiddleware(get_response: Callable[[HttpRequest], HttpResponse])\n</code></pre> <p>Middleware that inserts CSS/JS dependencies for all rendered components at points marked with template tags.</p> Source code in <code>src/django_components/dependencies.py</code> <pre><code>def __init__(self, get_response: \"Callable[[HttpRequest], HttpResponse]\") -&gt; None:\n    self.get_response = get_response\n\n    # NOTE: Required to work with async\n    if iscoroutinefunction(self.get_response):\n        markcoroutinefunction(self)\n</code></pre>"},{"location":"reference/django_components/#django_components.dependencies.render_dependencies","title":"render_dependencies","text":"<pre><code>render_dependencies(content: TContent, type: RenderType = 'document') -&gt; TContent\n</code></pre> <p>Given a string that contains parts that were rendered by components, this function inserts all used JS and CSS.</p> <p>By default, the string is parsed as an HTML and: - CSS is inserted at the end of <code>&lt;head&gt;</code> (if present) - JS is inserted at the end of <code>&lt;body&gt;</code> (if present)</p> <p>If you used <code>{% component_js_dependencies %}</code> or <code>{% component_css_dependencies %}</code>, then the JS and CSS will be inserted only at these locations.</p> <p>Example: <pre><code>def my_view(request):\n    template = Template('''\n        {% load components %}\n        &lt;!doctype html&gt;\n        &lt;html&gt;\n            &lt;head&gt;&lt;/head&gt;\n            &lt;body&gt;\n                &lt;h1&gt;{{ table_name }}&lt;/h1&gt;\n                {% component \"table\" name=table_name / %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    ''')\n\n    html = template.render(\n        Context({\n            \"table_name\": request.GET[\"name\"],\n        })\n    )\n\n    # This inserts components' JS and CSS\n    processed_html = render_dependencies(html)\n\n    return HttpResponse(processed_html)\n</code></pre></p> Source code in <code>src/django_components/dependencies.py</code> <pre><code>def render_dependencies(content: TContent, type: RenderType = \"document\") -&gt; TContent:\n    \"\"\"\n    Given a string that contains parts that were rendered by components,\n    this function inserts all used JS and CSS.\n\n    By default, the string is parsed as an HTML and:\n    - CSS is inserted at the end of `&lt;head&gt;` (if present)\n    - JS is inserted at the end of `&lt;body&gt;` (if present)\n\n    If you used `{% component_js_dependencies %}` or `{% component_css_dependencies %}`,\n    then the JS and CSS will be inserted only at these locations.\n\n    Example:\n    ```python\n    def my_view(request):\n        template = Template('''\n            {% load components %}\n            &lt;!doctype html&gt;\n            &lt;html&gt;\n                &lt;head&gt;&lt;/head&gt;\n                &lt;body&gt;\n                    &lt;h1&gt;{{ table_name }}&lt;/h1&gt;\n                    {% component \"table\" name=table_name / %}\n                &lt;/body&gt;\n            &lt;/html&gt;\n        ''')\n\n        html = template.render(\n            Context({\n                \"table_name\": request.GET[\"name\"],\n            })\n        )\n\n        # This inserts components' JS and CSS\n        processed_html = render_dependencies(html)\n\n        return HttpResponse(processed_html)\n    ```\n    \"\"\"\n    is_safestring = isinstance(content, SafeString)\n\n    if isinstance(content, str):\n        content_ = content.encode()\n    else:\n        content_ = cast(bytes, content)\n\n    content_, js_dependencies, css_dependencies = _process_dep_declarations(content_, type)\n\n    # Replace the placeholders with the actual content\n    did_find_js_placeholder = False\n    did_find_css_placeholder = False\n\n    def on_replace_match(match: \"re.Match[bytes]\") -&gt; bytes:\n        nonlocal did_find_css_placeholder\n        nonlocal did_find_js_placeholder\n\n        if match[0] == CSS_PLACEHOLDER_BYTES:\n            replacement = css_dependencies\n            did_find_css_placeholder = True\n        elif match[0] == JS_PLACEHOLDER_BYTES:\n            replacement = js_dependencies\n            did_find_js_placeholder = True\n        else:\n            raise RuntimeError(\n                \"Unexpected error: Regex for component dependencies processing\"\n                f\" matched unknown string '{match[0].decode()}'\"\n            )\n        return replacement\n\n    content_ = PLACEHOLDER_REGEX.sub(on_replace_match, content_)\n\n    # By default, if user didn't specify any `{% component_dependencies %}`,\n    # then try to insert the JS scripts at the end of &lt;body&gt; and CSS sheets at the end\n    # of &lt;head&gt;\n    if type == \"document\" and (not did_find_js_placeholder or not did_find_css_placeholder):\n        tree = parse_document_or_nodes(content_.decode())\n\n        if isinstance(tree, LexborHTMLParser):\n            did_modify_html = False\n\n            if not did_find_css_placeholder and tree.head:\n                css_elems = parse_multiroot_html(css_dependencies.decode())\n                for css_elem in css_elems:\n                    tree.head.insert_child(css_elem)  # type: ignore # TODO: Update to selectolax 0.3.25\n                did_modify_html = True\n\n            if not did_find_js_placeholder and tree.body:\n                js_elems = parse_multiroot_html(js_dependencies.decode())\n                for js_elem in js_elems:\n                    tree.body.insert_child(js_elem)  # type: ignore # TODO: Update to selectolax 0.3.25\n                did_modify_html = True\n\n            transformed = cast(str, tree.html)\n            if did_modify_html:\n                content_ = transformed.encode()\n\n    # Return the same type as we were given\n    output = content_.decode() if isinstance(content, str) else content_\n    output = mark_safe(output) if is_safestring else output\n    return cast(TContent, output)\n</code></pre>"},{"location":"reference/django_components/#django_components.expression","title":"expression","text":"<p>Classes:</p> <ul> <li> <code>Operator</code>           \u2013            <p>Operator describes something that somehow changes the inputs</p> </li> <li> <code>SpreadOperator</code>           \u2013            <p>Operator that inserts one or more kwargs at the specified location.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>process_aggregate_kwargs</code>             \u2013              <p>This function aggregates \"prefixed\" kwargs into dicts. \"Prefixed\" kwargs</p> </li> </ul>"},{"location":"reference/django_components/#django_components.expression.Operator","title":"Operator","text":"<p>               Bases: <code>ABC</code></p> <p>Operator describes something that somehow changes the inputs to template tags (the <code>{% %}</code>).</p> <p>For example, a SpreadOperator inserts one or more kwargs at the specified location.</p>"},{"location":"reference/django_components/#django_components.expression.SpreadOperator","title":"SpreadOperator","text":"<pre><code>SpreadOperator(expr: Expression)\n</code></pre> <p>               Bases: <code>Operator</code></p> <p>Operator that inserts one or more kwargs at the specified location.</p> Source code in <code>src/django_components/expression.py</code> <pre><code>def __init__(self, expr: Expression) -&gt; None:\n    self.expr = expr\n</code></pre>"},{"location":"reference/django_components/#django_components.expression.process_aggregate_kwargs","title":"process_aggregate_kwargs","text":"<pre><code>process_aggregate_kwargs(kwargs: Mapping[str, Any]) -&gt; Dict[str, Any]\n</code></pre> <p>This function aggregates \"prefixed\" kwargs into dicts. \"Prefixed\" kwargs start with some prefix delimited with <code>:</code> (e.g. <code>attrs:</code>).</p> <p>Example: <pre><code>process_component_kwargs({\"abc:one\": 1, \"abc:two\": 2, \"def:three\": 3, \"four\": 4})\n# {\"abc\": {\"one\": 1, \"two\": 2}, \"def\": {\"three\": 3}, \"four\": 4}\n</code></pre></p> <p>We want to support a use case similar to Vue's fallthrough attributes. In other words, where a component author can designate a prop (input) which is a dict and which will be rendered as HTML attributes.</p> <p>This is useful for allowing component users to tweak styling or add event handling to the underlying HTML. E.g.:</p> <p><code>class=\"pa-4 d-flex text-black\"</code> or <code>@click.stop=\"alert('clicked!')\"</code></p> <p>So if the prop is <code>attrs</code>, and the component is called like so: <pre><code>{% component \"my_comp\" attrs=attrs %}\n</code></pre></p> <p>then, if <code>attrs</code> is: <pre><code>{\"class\": \"text-red pa-4\", \"@click\": \"dispatch('my_event', 123)\"}\n</code></pre></p> <p>and the component template is: <pre><code>&lt;div {% html_attrs attrs add:class=\"extra-class\" %}&gt;&lt;/div&gt;\n</code></pre></p> <p>Then this renders: <pre><code>&lt;div class=\"text-red pa-4 extra-class\" @click=\"dispatch('my_event', 123)\" &gt;&lt;/div&gt;\n</code></pre></p> <p>However, this way it is difficult for the component user to define the <code>attrs</code> variable, especially if they want to combine static and dynamic values. Because they will need to pre-process the <code>attrs</code> dict.</p> <p>So, instead, we allow to \"aggregate\" props into a dict. So all props that start with <code>attrs:</code>, like <code>attrs:class=\"text-red\"</code>, will be collected into a dict at key <code>attrs</code>.</p> <p>This provides sufficient flexiblity to make it easy for component users to provide \"fallthrough attributes\", and sufficiently easy for component authors to process that input while still being able to provide their own keys.</p> Source code in <code>src/django_components/expression.py</code> <pre><code>def process_aggregate_kwargs(kwargs: Mapping[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    This function aggregates \"prefixed\" kwargs into dicts. \"Prefixed\" kwargs\n    start with some prefix delimited with `:` (e.g. `attrs:`).\n\n    Example:\n    ```py\n    process_component_kwargs({\"abc:one\": 1, \"abc:two\": 2, \"def:three\": 3, \"four\": 4})\n    # {\"abc\": {\"one\": 1, \"two\": 2}, \"def\": {\"three\": 3}, \"four\": 4}\n    ```\n\n    ---\n\n    We want to support a use case similar to Vue's fallthrough attributes.\n    In other words, where a component author can designate a prop (input)\n    which is a dict and which will be rendered as HTML attributes.\n\n    This is useful for allowing component users to tweak styling or add\n    event handling to the underlying HTML. E.g.:\n\n    `class=\"pa-4 d-flex text-black\"` or `@click.stop=\"alert('clicked!')\"`\n\n    So if the prop is `attrs`, and the component is called like so:\n    ```django\n    {% component \"my_comp\" attrs=attrs %}\n    ```\n\n    then, if `attrs` is:\n    ```py\n    {\"class\": \"text-red pa-4\", \"@click\": \"dispatch('my_event', 123)\"}\n    ```\n\n    and the component template is:\n    ```django\n    &lt;div {% html_attrs attrs add:class=\"extra-class\" %}&gt;&lt;/div&gt;\n    ```\n\n    Then this renders:\n    ```html\n    &lt;div class=\"text-red pa-4 extra-class\" @click=\"dispatch('my_event', 123)\" &gt;&lt;/div&gt;\n    ```\n\n    However, this way it is difficult for the component user to define the `attrs`\n    variable, especially if they want to combine static and dynamic values. Because\n    they will need to pre-process the `attrs` dict.\n\n    So, instead, we allow to \"aggregate\" props into a dict. So all props that start\n    with `attrs:`, like `attrs:class=\"text-red\"`, will be collected into a dict\n    at key `attrs`.\n\n    This provides sufficient flexiblity to make it easy for component users to provide\n    \"fallthrough attributes\", and sufficiently easy for component authors to process\n    that input while still being able to provide their own keys.\n    \"\"\"\n    processed_kwargs = {}\n    nested_kwargs: Dict[str, Dict[str, Any]] = {}\n    for key, val in kwargs.items():\n        if not is_aggregate_key(key):\n            processed_kwargs[key] = val\n            continue\n\n        # NOTE: Trim off the prefix from keys\n        prefix, sub_key = key.split(\":\", 1)\n        if prefix not in nested_kwargs:\n            nested_kwargs[prefix] = {}\n        nested_kwargs[prefix][sub_key] = val\n\n    # Assign aggregated values into normal input\n    for key, val in nested_kwargs.items():\n        if key in processed_kwargs:\n            raise TemplateSyntaxError(\n                f\"Received argument '{key}' both as a regular input ({key}=...)\"\n                f\" and as an aggregate dict ('{key}:key=...'). Must be only one of the two\"\n            )\n        processed_kwargs[key] = val\n\n    return processed_kwargs\n</code></pre>"},{"location":"reference/django_components/#django_components.finders","title":"finders","text":"<p>Classes:</p> <ul> <li> <code>ComponentsFileSystemFinder</code>           \u2013            <p>A static files finder based on <code>FileSystemFinder</code>.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.finders.ComponentsFileSystemFinder","title":"ComponentsFileSystemFinder","text":"<pre><code>ComponentsFileSystemFinder(app_names: Any = None, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>BaseFinder</code></p> <p>A static files finder based on <code>FileSystemFinder</code>.</p> <p>Differences: - This finder uses <code>COMPONENTS.dirs</code> setting to locate files instead of <code>STATICFILES_DIRS</code>. - Whether a file within <code>COMPONENTS.dirs</code> is considered a STATIC file is configured   by <code>COMPONENTS.static_files_allowed</code> and <code>COMPONENTS.static_files_forbidden</code>. - If <code>COMPONENTS.dirs</code> is not set, defaults to <code>settings.BASE_DIR / \"components\"</code></p> <p>Methods:</p> <ul> <li> <code>find</code>             \u2013              <p>Look for files in the extra locations as defined in COMPONENTS.dirs.</p> </li> <li> <code>find_location</code>             \u2013              <p>Find a requested static file in a location and return the found</p> </li> <li> <code>list</code>             \u2013              <p>List all files in all locations.</p> </li> </ul> Source code in <code>src/django_components/finders.py</code> <pre><code>def __init__(self, app_names: Any = None, *args: Any, **kwargs: Any) -&gt; None:\n    component_dirs = [str(p) for p in get_component_dirs()]\n\n    # NOTE: The rest of the __init__ is the same as `django.contrib.staticfiles.finders.FileSystemFinder`,\n    # but using our locations instead of STATICFILES_DIRS.\n\n    # List of locations with static files\n    self.locations: List[Tuple[str, str]] = []\n\n    # Maps dir paths to an appropriate storage instance\n    self.storages: Dict[str, FileSystemStorage] = {}\n    for root in component_dirs:\n        if isinstance(root, (list, tuple)):\n            prefix, root = root\n        else:\n            prefix = \"\"\n        if (prefix, root) not in self.locations:\n            self.locations.append((prefix, root))\n    for prefix, root in self.locations:\n        filesystem_storage = FileSystemStorage(location=root)\n        filesystem_storage.prefix = prefix\n        self.storages[root] = filesystem_storage\n\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/django_components/#django_components.finders.ComponentsFileSystemFinder.find","title":"find","text":"<pre><code>find(path: str, all: bool = False) -&gt; Union[List[str], str]\n</code></pre> <p>Look for files in the extra locations as defined in COMPONENTS.dirs.</p> Source code in <code>src/django_components/finders.py</code> <pre><code>def find(self, path: str, all: bool = False) -&gt; Union[List[str], str]:\n    \"\"\"\n    Look for files in the extra locations as defined in COMPONENTS.dirs.\n    \"\"\"\n    matches: List[str] = []\n    for prefix, root in self.locations:\n        if root not in searched_locations:\n            searched_locations.append(root)\n        matched_path = self.find_location(root, path, prefix)\n        if matched_path:\n            if not all:\n                return matched_path\n            matches.append(matched_path)\n    return matches\n</code></pre>"},{"location":"reference/django_components/#django_components.finders.ComponentsFileSystemFinder.find_location","title":"find_location","text":"<pre><code>find_location(root: str, path: str, prefix: Optional[str] = None) -&gt; Optional[str]\n</code></pre> <p>Find a requested static file in a location and return the found absolute path (or <code>None</code> if no match).</p> Source code in <code>src/django_components/finders.py</code> <pre><code>def find_location(self, root: str, path: str, prefix: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"\n    Find a requested static file in a location and return the found\n    absolute path (or ``None`` if no match).\n    \"\"\"\n    if prefix:\n        prefix = \"%s%s\" % (prefix, os.sep)\n        if not path.startswith(prefix):\n            return None\n        path = path.removeprefix(prefix)\n    path = safe_join(root, path)\n\n    if os.path.exists(path) and self._is_path_valid(path):\n        return path\n    return None\n</code></pre>"},{"location":"reference/django_components/#django_components.finders.ComponentsFileSystemFinder.list","title":"list","text":"<pre><code>list(ignore_patterns: List[str]) -&gt; Iterable[Tuple[str, FileSystemStorage]]\n</code></pre> <p>List all files in all locations.</p> Source code in <code>src/django_components/finders.py</code> <pre><code>def list(self, ignore_patterns: List[str]) -&gt; Iterable[Tuple[str, FileSystemStorage]]:\n    \"\"\"\n    List all files in all locations.\n    \"\"\"\n    for prefix, root in self.locations:\n        # Skip nonexistent directories.\n        if os.path.isdir(root):\n            storage = self.storages[root]\n            for path in get_files(storage, ignore_patterns):\n                if self._is_path_valid(path):\n                    yield path, storage\n</code></pre>"},{"location":"reference/django_components/#django_components.library","title":"library","text":"<p>Module for interfacing with Django's Library (<code>django.template.library</code>)</p> <p>Classes:</p> <ul> <li> <code>TagProtectedError</code>           \u2013            <p>The way the <code>TagFormatter</code> works is that,</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>PROTECTED_TAGS</code>           \u2013            <p>These are the names that users cannot choose for their components,</p> </li> </ul>"},{"location":"reference/django_components/#django_components.library.PROTECTED_TAGS","title":"PROTECTED_TAGS  <code>module-attribute</code>","text":"<pre><code>PROTECTED_TAGS = ['component_css_dependencies', 'component_js_dependencies', 'fill', 'html_attrs', 'provide', 'slot']\n</code></pre> <p>These are the names that users cannot choose for their components, as they would conflict with other tags in the Library.</p>"},{"location":"reference/django_components/#django_components.library.TagProtectedError","title":"TagProtectedError","text":"<p>               Bases: <code>Exception</code></p> <p>The way the <code>TagFormatter</code> works is that, based on which start and end tags are used for rendering components, the <code>ComponentRegistry</code> behind the scenes un-/registers the template tags with the associated instance of Django's <code>Library</code>.</p> <p>In other words, if I have registered a component <code>\"table\"</code>, and I use the shorthand syntax:</p> <pre><code>{% table ... %}\n{% endtable %}\n</code></pre> <p>Then <code>ComponentRegistry</code> registers the tag <code>table</code> onto the Django's Library instance.</p> <p>However, that means that if we registered a component <code>\"slot\"</code>, then we would overwrite the <code>{% slot %}</code> tag from django_components.</p> <p>Thus, this exception is raised when a component is attempted to be registered under a forbidden name, such that it would overwrite one of django_component's own template tags.</p>"},{"location":"reference/django_components/#django_components.management","title":"management","text":"<p>Modules:</p> <ul> <li> <code>commands</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/#django_components.management.commands","title":"commands","text":"<p>Modules:</p> <ul> <li> <code>startcomponent</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/#django_components.management.commands.startcomponent","title":"startcomponent","text":"<p>Classes:</p> <ul> <li> <code>Command</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/#django_components.management.commands.startcomponent--management-command-usage","title":"Management Command Usage","text":""},{"location":"reference/django_components/#django_components.management.commands.startcomponent.Command","title":"Command","text":"<p>               Bases: <code>BaseCommand</code></p>"},{"location":"reference/django_components/#django_components.management.commands.startcomponent.Command--management-command-usage","title":"Management Command Usage","text":"<p>To use the command, run the following command in your terminal:</p> <pre><code>python manage.py startcomponent &lt;name&gt; --path &lt;path&gt; --js &lt;js_filename&gt; --css &lt;css_filename&gt; --template &lt;template_filename&gt; --force --verbose --dry-run\n</code></pre> <p>Replace <code>&lt;name&gt;</code>, <code>&lt;path&gt;</code>, <code>&lt;js_filename&gt;</code>, <code>&lt;css_filename&gt;</code>, and <code>&lt;template_filename&gt;</code> with your desired values.</p>"},{"location":"reference/django_components/#django_components.management.commands.startcomponent.Command--management-command-examples","title":"Management Command Examples","text":"<p>Here are some examples of how you can use the command:</p>"},{"location":"reference/django_components/#django_components.management.commands.startcomponent.Command--creating-a-component-with-default-settings","title":"Creating a Component with Default Settings","text":"<p>To create a component with the default settings, you only need to provide the name of the component:</p> <pre><code>python manage.py startcomponent my_component\n</code></pre> <p>This will create a new component named <code>my_component</code> in the <code>components</code> directory of your Django project. The JavaScript, CSS, and template files will be named <code>script.js</code>, <code>style.css</code>, and <code>template.html</code>, respectively.</p>"},{"location":"reference/django_components/#django_components.management.commands.startcomponent.Command--creating-a-component-with-custom-settings","title":"Creating a Component with Custom Settings","text":"<p>You can also create a component with custom settings by providing additional arguments:</p> <pre><code>python manage.py startcomponent new_component --path my_components --js my_script.js --css my_style.css --template my_template.html\n</code></pre> <p>This will create a new component named <code>new_component</code> in the <code>my_components</code> directory. The JavaScript, CSS, and template files will be named <code>my_script.js</code>, <code>my_style.css</code>, and <code>my_template.html</code>, respectively.</p>"},{"location":"reference/django_components/#django_components.management.commands.startcomponent.Command--overwriting-an-existing-component","title":"Overwriting an Existing Component","text":"<p>If you want to overwrite an existing component, you can use the <code>--force</code> option:</p> <pre><code>python manage.py startcomponent my_component --force\n</code></pre> <p>This will overwrite the existing <code>my_component</code> if it exists.</p>"},{"location":"reference/django_components/#django_components.management.commands.startcomponent.Command--simulating-component-creation","title":"Simulating Component Creation","text":"<p>If you want to simulate the creation of a component without actually creating any files, you can use the <code>--dry-run</code> option:</p> <pre><code>python manage.py startcomponent my_component --dry-run\n</code></pre> <p>This will simulate the creation of <code>my_component</code> without creating any files.</p>"},{"location":"reference/django_components/#django_components.middleware","title":"middleware","text":"<p>Classes:</p> <ul> <li> <code>ComponentDependencyMiddleware</code>           \u2013            <p>Middleware that inserts CSS/JS dependencies for all rendered</p> </li> </ul>"},{"location":"reference/django_components/#django_components.middleware.ComponentDependencyMiddleware","title":"ComponentDependencyMiddleware","text":"<pre><code>ComponentDependencyMiddleware(get_response: Callable[[HttpRequest], HttpResponse])\n</code></pre> <p>Middleware that inserts CSS/JS dependencies for all rendered components at points marked with template tags.</p> Source code in <code>src/django_components/dependencies.py</code> <pre><code>def __init__(self, get_response: \"Callable[[HttpRequest], HttpResponse]\") -&gt; None:\n    self.get_response = get_response\n\n    # NOTE: Required to work with async\n    if iscoroutinefunction(self.get_response):\n        markcoroutinefunction(self)\n</code></pre>"},{"location":"reference/django_components/#django_components.node","title":"node","text":"<p>Classes:</p> <ul> <li> <code>BaseNode</code>           \u2013            <p>Shared behavior for our subclasses of Django's <code>Node</code></p> </li> </ul>"},{"location":"reference/django_components/#django_components.node.BaseNode","title":"BaseNode","text":"<pre><code>BaseNode(\n    nodelist: Optional[NodeList] = None,\n    node_id: Optional[str] = None,\n    args: Optional[List[Expression]] = None,\n    kwargs: Optional[RuntimeKwargs] = None,\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>Shared behavior for our subclasses of Django's <code>Node</code></p> Source code in <code>src/django_components/node.py</code> <pre><code>def __init__(\n    self,\n    nodelist: Optional[NodeList] = None,\n    node_id: Optional[str] = None,\n    args: Optional[List[Expression]] = None,\n    kwargs: Optional[RuntimeKwargs] = None,\n):\n    self.nodelist = nodelist or NodeList()\n    self.node_id = node_id or gen_id()\n    self.args = args or []\n    self.kwargs = kwargs or RuntimeKwargs({})\n</code></pre>"},{"location":"reference/django_components/#django_components.provide","title":"provide","text":"<p>Classes:</p> <ul> <li> <code>ProvideNode</code>           \u2013            <p>Implementation of the <code>{% provide %}</code> tag.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.provide.ProvideNode","title":"ProvideNode","text":"<pre><code>ProvideNode(nodelist: NodeList, trace_id: str, node_id: Optional[str] = None, kwargs: Optional[RuntimeKwargs] = None)\n</code></pre> <p>               Bases: <code>BaseNode</code></p> <p>Implementation of the <code>{% provide %}</code> tag. For more info see <code>Component.inject</code>.</p> Source code in <code>src/django_components/provide.py</code> <pre><code>def __init__(\n    self,\n    nodelist: NodeList,\n    trace_id: str,\n    node_id: Optional[str] = None,\n    kwargs: Optional[RuntimeKwargs] = None,\n):\n    super().__init__(nodelist=nodelist, args=None, kwargs=kwargs, node_id=node_id)\n\n    self.nodelist = nodelist\n    self.node_id = node_id or gen_id()\n    self.trace_id = trace_id\n    self.kwargs = kwargs or RuntimeKwargs({})\n</code></pre>"},{"location":"reference/django_components/#django_components.slots","title":"slots","text":"<p>Classes:</p> <ul> <li> <code>FillNode</code>           \u2013            <p>Node corresponding to <code>{% fill %}</code></p> </li> <li> <code>Slot</code>           \u2013            <p>This class holds the slot content function along with related metadata.</p> </li> <li> <code>SlotFill</code>           \u2013            <p>SlotFill describes what WILL be rendered.</p> </li> <li> <code>SlotIsFilled</code>           \u2013            <p>Dictionary that returns <code>True</code> if the slot is filled (key is found), <code>False</code> otherwise.</p> </li> <li> <code>SlotNode</code>           \u2013            <p>Node corresponding to <code>{% slot %}</code></p> </li> <li> <code>SlotRef</code>           \u2013            <p>SlotRef allows to treat a slot as a variable. The slot is rendered only once</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>resolve_fills</code>             \u2013              <p>Given a component body (<code>django.template.NodeList</code>), find all slot fills,</p> </li> </ul>"},{"location":"reference/django_components/#django_components.slots.FillNode","title":"FillNode","text":"<pre><code>FillNode(nodelist: NodeList, kwargs: RuntimeKwargs, trace_id: str, node_id: Optional[str] = None)\n</code></pre> <p>               Bases: <code>BaseNode</code></p> <p>Node corresponding to <code>{% fill %}</code></p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(\n    self,\n    nodelist: NodeList,\n    kwargs: RuntimeKwargs,\n    trace_id: str,\n    node_id: Optional[str] = None,\n):\n    super().__init__(nodelist=nodelist, args=None, kwargs=kwargs, node_id=node_id)\n\n    self.trace_id = trace_id\n</code></pre>"},{"location":"reference/django_components/#django_components.slots.Slot","title":"Slot  <code>dataclass</code>","text":"<pre><code>Slot(content_func: SlotFunc[TSlotData])\n</code></pre> <p>               Bases: <code>Generic[TSlotData]</code></p> <p>This class holds the slot content function along with related metadata.</p>"},{"location":"reference/django_components/#django_components.slots.SlotFill","title":"SlotFill  <code>dataclass</code>","text":"<pre><code>SlotFill(name: str, is_filled: bool, slot: Slot[TSlotData])\n</code></pre> <p>               Bases: <code>Generic[TSlotData]</code></p> <p>SlotFill describes what WILL be rendered.</p> <p>The fill may be provided by the user from the outside (<code>is_filled=True</code>), or it may be the default content of the slot (<code>is_filled=False</code>).</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the slot.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.slots.SlotFill.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the slot.</p>"},{"location":"reference/django_components/#django_components.slots.SlotIsFilled","title":"SlotIsFilled","text":"<pre><code>SlotIsFilled(fills: Dict, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>dict</code></p> <p>Dictionary that returns <code>True</code> if the slot is filled (key is found), <code>False</code> otherwise.</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(self, fills: Dict, *args: Any, **kwargs: Any) -&gt; None:\n    escaped_fill_names = {_escape_slot_name(fill_name): True for fill_name in fills.keys()}\n    super().__init__(escaped_fill_names, *args, **kwargs)\n</code></pre>"},{"location":"reference/django_components/#django_components.slots.SlotNode","title":"SlotNode","text":"<pre><code>SlotNode(\n    nodelist: NodeList,\n    trace_id: str,\n    node_id: Optional[str] = None,\n    kwargs: Optional[RuntimeKwargs] = None,\n    is_required: bool = False,\n    is_default: bool = False,\n)\n</code></pre> <p>               Bases: <code>BaseNode</code></p> <p>Node corresponding to <code>{% slot %}</code></p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(\n    self,\n    nodelist: NodeList,\n    trace_id: str,\n    node_id: Optional[str] = None,\n    kwargs: Optional[RuntimeKwargs] = None,\n    is_required: bool = False,\n    is_default: bool = False,\n):\n    super().__init__(nodelist=nodelist, args=None, kwargs=kwargs, node_id=node_id)\n\n    self.is_required = is_required\n    self.is_default = is_default\n    self.trace_id = trace_id\n</code></pre>"},{"location":"reference/django_components/#django_components.slots.SlotRef","title":"SlotRef","text":"<pre><code>SlotRef(slot: SlotNode, context: Context)\n</code></pre> <p>SlotRef allows to treat a slot as a variable. The slot is rendered only once the instance is coerced to string.</p> <p>This is used to access slots as variables inside the templates. When a SlotRef is rendered in the template with <code>{{ my_lazy_slot }}</code>, it will output the contents of the slot.</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(self, slot: \"SlotNode\", context: Context):\n    self._slot = slot\n    self._context = context\n</code></pre>"},{"location":"reference/django_components/#django_components.slots.resolve_fills","title":"resolve_fills","text":"<pre><code>resolve_fills(context: Context, nodelist: NodeList, component_name: str) -&gt; Dict[SlotName, Slot]\n</code></pre> <p>Given a component body (<code>django.template.NodeList</code>), find all slot fills, whether defined explicitly with <code>{% fill %}</code> or implicitly.</p> <p>So if we have a component body: <pre><code>{% component \"mycomponent\" %}\n    {% fill \"first_fill\" %}\n        Hello!\n    {% endfill %}\n    {% fill \"second_fill\" %}\n        Hello too!\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Then this function finds 2 fill nodes: \"first_fill\" and \"second_fill\", and formats them as slot functions, returning:</p> <pre><code>{\n    \"first_fill\": SlotFunc(...),\n    \"second_fill\": SlotFunc(...),\n}\n</code></pre> <p>If no fill nodes are found, then the content is treated as default slot content.</p> <pre><code>{\n    DEFAULT_SLOT_KEY: SlotFunc(...),\n}\n</code></pre> <p>This function also handles for-loops, if/else statements, or include tags to generate fill tags:</p> <pre><code>{% component \"mycomponent\" %}\n    {% for slot_name in slots %}\n        {% fill name=slot_name %}\n            {% slot name=slot_name / %}\n        {% endfill %}\n    {% endfor %}\n{% endcomponent %}\n</code></pre> Source code in <code>src/django_components/slots.py</code> <pre><code>def resolve_fills(\n    context: Context,\n    nodelist: NodeList,\n    component_name: str,\n) -&gt; Dict[SlotName, Slot]:\n    \"\"\"\n    Given a component body (`django.template.NodeList`), find all slot fills,\n    whether defined explicitly with `{% fill %}` or implicitly.\n\n    So if we have a component body:\n    ```django\n    {% component \"mycomponent\" %}\n        {% fill \"first_fill\" %}\n            Hello!\n        {% endfill %}\n        {% fill \"second_fill\" %}\n            Hello too!\n        {% endfill %}\n    {% endcomponent %}\n    ```\n\n    Then this function finds 2 fill nodes: \"first_fill\" and \"second_fill\",\n    and formats them as slot functions, returning:\n\n    ```python\n    {\n        \"first_fill\": SlotFunc(...),\n        \"second_fill\": SlotFunc(...),\n    }\n    ```\n\n    If no fill nodes are found, then the content is treated as default slot content.\n\n    ```python\n    {\n        DEFAULT_SLOT_KEY: SlotFunc(...),\n    }\n    ```\n\n    This function also handles for-loops, if/else statements, or include tags to generate fill tags:\n\n    ```django\n    {% component \"mycomponent\" %}\n        {% for slot_name in slots %}\n            {% fill name=slot_name %}\n                {% slot name=slot_name / %}\n            {% endfill %}\n        {% endfor %}\n    {% endcomponent %}\n    ```\n    \"\"\"\n    slots: Dict[SlotName, Slot] = {}\n\n    if not nodelist:\n        return slots\n\n    maybe_fills = _extract_fill_content(nodelist, context, component_name)\n\n    # The content has no fills, so treat it as default slot, e.g.:\n    # {% component \"mycomponent\" %}\n    #   Hello!\n    #   {% if True %} 123 {% endif %}\n    # {% endcomponent %}\n    if maybe_fills is False:\n        # Ignore empty content between `{% component %} ... {% endcomponent %}` tags\n        nodelist_is_empty = not len(nodelist) or all(\n            isinstance(node, TextNode) and not node.s.strip() for node in nodelist\n        )\n\n        if not nodelist_is_empty:\n            slots[DEFAULT_SLOT_KEY] = _nodelist_to_slot_render_func(\n                DEFAULT_SLOT_KEY,\n                nodelist,\n                data_var=None,\n                default_var=None,\n            )\n\n    # The content has fills\n    else:\n        # NOTE: If slot fills are explicitly defined, we use them even if they are empty (or only whitespace).\n        #       This is different from the default slot, where we ignore empty content.\n        for fill in maybe_fills:\n            slots[fill.name] = _nodelist_to_slot_render_func(\n                slot_name=fill.name,\n                nodelist=fill.fill.nodelist,\n                data_var=fill.data_var,\n                default_var=fill.default_var,\n                extra_context=fill.extra_context,\n            )\n\n    return slots\n</code></pre>"},{"location":"reference/django_components/#django_components.tag_formatter","title":"tag_formatter","text":"<p>Classes:</p> <ul> <li> <code>ComponentFormatter</code>           \u2013            <p>The original django_component's component tag formatter, it uses the <code>{% component %}</code></p> </li> <li> <code>InternalTagFormatter</code>           \u2013            <p>Internal wrapper around user-provided TagFormatters, so that we validate the outputs.</p> </li> <li> <code>ShorthandComponentFormatter</code>           \u2013            <p>The component tag formatter that uses <code>{% &lt;name&gt; %}</code> / <code>{% end&lt;name&gt; %}</code> tags.</p> </li> <li> <code>TagFormatterABC</code>           \u2013            <p>Abstract base class for defining custom tag formatters.</p> </li> <li> <code>TagResult</code>           \u2013            <p>The return value from <code>TagFormatter.parse()</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_tag_formatter</code>             \u2013              <p>Returns an instance of the currently configured component tag formatter.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.tag_formatter.ComponentFormatter","title":"ComponentFormatter","text":"<pre><code>ComponentFormatter(tag: str)\n</code></pre> <p>               Bases: <code>TagFormatterABC</code></p> <p>The original django_component's component tag formatter, it uses the <code>{% component %}</code> and <code>{% endcomponent %}</code> tags, and the component name is given as the first positional arg.</p> <p>Example as block: <pre><code>{% component \"mycomp\" abc=123 %}\n    {% fill \"myfill\" %}\n        ...\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% component \"mycomp\" abc=123 / %}\n</code></pre></p> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>def __init__(self, tag: str):\n    self.tag = tag\n</code></pre>"},{"location":"reference/django_components/#django_components.tag_formatter.InternalTagFormatter","title":"InternalTagFormatter","text":"<pre><code>InternalTagFormatter(tag_formatter: TagFormatterABC)\n</code></pre> <p>Internal wrapper around user-provided TagFormatters, so that we validate the outputs.</p> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>def __init__(self, tag_formatter: TagFormatterABC):\n    self.tag_formatter = tag_formatter\n</code></pre>"},{"location":"reference/django_components/#django_components.tag_formatter.ShorthandComponentFormatter","title":"ShorthandComponentFormatter","text":"<p>               Bases: <code>TagFormatterABC</code></p> <p>The component tag formatter that uses <code>{% &lt;name&gt; %}</code> / <code>{% end&lt;name&gt; %}</code> tags.</p> <p>This is similar to django-web-components and django-slippers syntax.</p> <p>Example as block: <pre><code>{% mycomp abc=123 %}\n    {% fill \"myfill\" %}\n        ...\n    {% endfill %}\n{% endmycomp %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% mycomp abc=123 / %}\n</code></pre></p>"},{"location":"reference/django_components/#django_components.tag_formatter.TagFormatterABC","title":"TagFormatterABC","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for defining custom tag formatters.</p> <p>Tag formatters define how the component tags are used in the template.</p> <p>Read more about Tag formatter.</p> <p>For example, with the default tag formatter (<code>ComponentFormatter</code>), components are written as:</p> <pre><code>{% component \"comp_name\" %}\n{% endcomponent %}\n</code></pre> <p>While with the shorthand tag formatter (<code>ShorthandComponentFormatter</code>), components are written as: <pre><code>{% comp_name %}\n{% endcomp_name %}\n</code></pre></p> <p>Example:</p> <p>Implementation for <code>ShorthandComponentFormatter</code>:</p> <pre><code>from djagno_components import TagFormatterABC, TagResult\n\nclass ShorthandComponentFormatter(TagFormatterABC):\n    def start_tag(self, name: str) -&gt; str:\n        return name\n\n    def end_tag(self, name: str) -&gt; str:\n        return f\"end{name}\"\n\n    def parse(self, tokens: List[str]) -&gt; TagResult:\n        tokens = [*tokens]\n        name = tokens.pop(0)\n        return TagResult(name, tokens)\n</code></pre> <p>Methods:</p> <ul> <li> <code>end_tag</code>             \u2013              <p>Formats the end tag of a block component.</p> </li> <li> <code>parse</code>             \u2013              <p>Given the tokens (words) passed to a component start tag, this function extracts</p> </li> <li> <code>start_tag</code>             \u2013              <p>Formats the start tag of a component.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.tag_formatter.TagFormatterABC.end_tag","title":"end_tag  <code>abstractmethod</code>","text":"<pre><code>end_tag(name: str) -&gt; str\n</code></pre> <p>Formats the end tag of a block component.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component's registered name. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The formatted end tag.</p> </li> </ul> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>@abc.abstractmethod\ndef end_tag(self, name: str) -&gt; str:\n    \"\"\"\n    Formats the end tag of a block component.\n\n    Args:\n        name (str): Component's registered name. Required.\n\n    Returns:\n        str: The formatted end tag.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/django_components/#django_components.tag_formatter.TagFormatterABC.parse","title":"parse  <code>abstractmethod</code>","text":"<pre><code>parse(tokens: List[str]) -&gt; TagResult\n</code></pre> <p>Given the tokens (words) passed to a component start tag, this function extracts the component name from the tokens list, and returns <code>TagResult</code>, which is a tuple of <code>(component_name, remaining_tokens)</code>.</p> <p>Parameters:</p> <ul> <li> <code>tokens</code>               (<code>[List(str]</code>)           \u2013            <p>List of tokens passed to the component tag.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TagResult</code> (              <code>TagResult</code> )          \u2013            <p>Parsed component name and remaining tokens.</p> </li> </ul> <p>Example:</p> <p>Assuming we used a component in a template like this:</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n{% endcomponent %}\n</code></pre> <p>This function receives a list of tokens:</p> <pre><code>['component', '\"my_comp\"', 'key=val', 'key2=val2']\n</code></pre> <ul> <li><code>component</code> is the tag name, which we drop.</li> <li><code>\"my_comp\"</code> is the component name, but we must remove the extra quotes.</li> <li>The remaining tokens we pass unmodified, as that's the input to the component.</li> </ul> <p>So in the end, we return:</p> <pre><code>TagResult('my_comp', ['key=val', 'key2=val2'])\n</code></pre> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>@abc.abstractmethod\ndef parse(self, tokens: List[str]) -&gt; TagResult:\n    \"\"\"\n    Given the tokens (words) passed to a component start tag, this function extracts\n    the component name from the tokens list, and returns\n    [`TagResult`](../api#django_components.TagResult),\n    which is a tuple of `(component_name, remaining_tokens)`.\n\n    Args:\n        tokens [List(str]): List of tokens passed to the component tag.\n\n    Returns:\n        TagResult: Parsed component name and remaining tokens.\n\n    **Example:**\n\n    Assuming we used a component in a template like this:\n\n    ```django\n    {% component \"my_comp\" key=val key2=val2 %}\n    {% endcomponent %}\n    ```\n\n    This function receives a list of tokens:\n\n    ```python\n    ['component', '\"my_comp\"', 'key=val', 'key2=val2']\n    ```\n\n    - `component` is the tag name, which we drop.\n    - `\"my_comp\"` is the component name, but we must remove the extra quotes.\n    - The remaining tokens we pass unmodified, as that's the input to the component.\n\n    So in the end, we return:\n\n    ```python\n    TagResult('my_comp', ['key=val', 'key2=val2'])\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/django_components/#django_components.tag_formatter.TagFormatterABC.start_tag","title":"start_tag  <code>abstractmethod</code>","text":"<pre><code>start_tag(name: str) -&gt; str\n</code></pre> <p>Formats the start tag of a component.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component's registered name. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The formatted start tag.</p> </li> </ul> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>@abc.abstractmethod\ndef start_tag(self, name: str) -&gt; str:\n    \"\"\"\n    Formats the start tag of a component.\n\n    Args:\n        name (str): Component's registered name. Required.\n\n    Returns:\n        str: The formatted start tag.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/django_components/#django_components.tag_formatter.TagResult","title":"TagResult","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The return value from <code>TagFormatter.parse()</code>.</p> <p>Read more about Tag formatter.</p> <p>Attributes:</p> <ul> <li> <code>component_name</code>               (<code>str</code>)           \u2013            <p>Component name extracted from the template tag</p> </li> <li> <code>tokens</code>               (<code>List[str]</code>)           \u2013            <p>Remaining tokens (words) that were passed to the tag, with component name removed</p> </li> </ul>"},{"location":"reference/django_components/#django_components.tag_formatter.TagResult.component_name","title":"component_name  <code>instance-attribute</code>","text":"<pre><code>component_name: str\n</code></pre> <p>Component name extracted from the template tag</p> <p>For example, if we had tag</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n</code></pre> <p>Then <code>component_name</code> would be <code>my_comp</code>.</p>"},{"location":"reference/django_components/#django_components.tag_formatter.TagResult.tokens","title":"tokens  <code>instance-attribute</code>","text":"<pre><code>tokens: List[str]\n</code></pre> <p>Remaining tokens (words) that were passed to the tag, with component name removed</p> <p>For example, if we had tag</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n</code></pre> <p>Then <code>tokens</code> would be <code>['key=val', 'key2=val2']</code>.</p>"},{"location":"reference/django_components/#django_components.tag_formatter.get_tag_formatter","title":"get_tag_formatter","text":"<pre><code>get_tag_formatter(registry: ComponentRegistry) -&gt; InternalTagFormatter\n</code></pre> <p>Returns an instance of the currently configured component tag formatter.</p> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>def get_tag_formatter(registry: \"ComponentRegistry\") -&gt; InternalTagFormatter:\n    \"\"\"Returns an instance of the currently configured component tag formatter.\"\"\"\n    # Allow users to configure the component TagFormatter\n    formatter_cls_or_str = registry.settings.tag_formatter\n\n    if isinstance(formatter_cls_or_str, str):\n        tag_formatter: TagFormatterABC = import_string(formatter_cls_or_str)\n    else:\n        tag_formatter = formatter_cls_or_str\n\n    return InternalTagFormatter(tag_formatter)\n</code></pre>"},{"location":"reference/django_components/#django_components.template","title":"template","text":"<p>Functions:</p> <ul> <li> <code>cached_template</code>             \u2013              <p>Create a Template instance that will be cached as per the</p> </li> </ul>"},{"location":"reference/django_components/#django_components.template.cached_template","title":"cached_template","text":"<pre><code>cached_template(\n    template_string: str,\n    template_cls: Optional[Type[Template]] = None,\n    origin: Optional[Origin] = None,\n    name: Optional[str] = None,\n    engine: Optional[Any] = None,\n) -&gt; Template\n</code></pre> <p>Create a Template instance that will be cached as per the <code>COMPONENTS.template_cache_size</code> setting.</p> <p>Parameters:</p> <ul> <li> <code>template_string</code>               (<code>str</code>)           \u2013            <p>Template as a string, same as the first argument to Django's            <code>Template</code>. Required.</p> </li> <li> <code>template_cls</code>               (<code>Type[Template]</code>, default:                   <code>None</code> )           \u2013            <p>Specify the Template class that should be instantiated.            Defaults to Django's <code>Template</code> class.</p> </li> <li> <code>origin</code>               (<code>Type[Origin]</code>, default:                   <code>None</code> )           \u2013            <p>Sets             <code>Template.Origin</code>.</p> </li> <li> <code>name</code>               (<code>Type[str]</code>, default:                   <code>None</code> )           \u2013            <p>Sets <code>Template.name</code></p> </li> <li> <code>engine</code>               (<code>Type[Any]</code>, default:                   <code>None</code> )           \u2013            <p>Sets <code>Template.engine</code></p> </li> </ul> <pre><code>from django_components import cached_template\n\ntemplate = cached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ntemplate = cached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre> Source code in <code>src/django_components/template.py</code> <pre><code>def cached_template(\n    template_string: str,\n    template_cls: Optional[Type[Template]] = None,\n    origin: Optional[Origin] = None,\n    name: Optional[str] = None,\n    engine: Optional[Any] = None,\n) -&gt; Template:\n    \"\"\"\n    Create a Template instance that will be cached as per the\n    [`COMPONENTS.template_cache_size`](../settings#django_components.app_settings.ComponentsSettings.template_cache_size)\n    setting.\n\n    Args:\n        template_string (str): Template as a string, same as the first argument to Django's\\\n            [`Template`](https://docs.djangoproject.com/en/5.1/topics/templates/#template). Required.\n        template_cls (Type[Template], optional): Specify the Template class that should be instantiated.\\\n            Defaults to Django's [`Template`](https://docs.djangoproject.com/en/5.1/topics/templates/#template) class.\n        origin (Type[Origin], optional): Sets \\\n            [`Template.Origin`](https://docs.djangoproject.com/en/5.1/howto/custom-template-backend/#origin-api-and-3rd-party-integration).\n        name (Type[str], optional): Sets `Template.name`\n        engine (Type[Any], optional): Sets `Template.engine`\n\n    ```python\n    from django_components import cached_template\n\n    template = cached_template(\"Variable: {{ variable }}\")\n\n    # You can optionally specify Template class, and other Template inputs:\n    class MyTemplate(Template):\n        pass\n\n    template = cached_template(\n        \"Variable: {{ variable }}\",\n        template_cls=MyTemplate,\n        name=...\n        origin=...\n        engine=...\n    )\n    ```\n    \"\"\"  # noqa: E501\n    template = _create_template(template_cls or Template, template_string, engine)\n\n    # Assign the origin and name separately, so the caching doesn't depend on them\n    # Since we might be accessing a template from cache, we want to define these only once\n    if not getattr(template, \"_dc_cached\", False):\n        template.origin = origin or Origin(UNKNOWN_SOURCE)\n        template.name = name\n        template._dc_cached = True\n\n    return template\n</code></pre>"},{"location":"reference/django_components/#django_components.template_loader","title":"template_loader","text":"<p>Template loader that loads templates from each Django app's \"components\" directory.</p> <p>Classes:</p> <ul> <li> <code>Loader</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/#django_components.template_loader.Loader","title":"Loader","text":"<p>               Bases: <code>Loader</code></p> <p>Methods:</p> <ul> <li> <code>get_dirs</code>             \u2013              <p>Prepare directories that may contain component files:</p> </li> </ul>"},{"location":"reference/django_components/#django_components.template_loader.Loader.get_dirs","title":"get_dirs","text":"<pre><code>get_dirs(include_apps: bool = True) -&gt; List[Path]\n</code></pre> <p>Prepare directories that may contain component files:</p> <p>Searches for dirs set in <code>COMPONENTS.dirs</code> settings. If none set, defaults to searching for a \"components\" app. The dirs in <code>COMPONENTS.dirs</code> must be absolute paths.</p> <p>In addition to that, also all apps are checked for <code>[app]/components</code> dirs.</p> <p>Paths are accepted only if they resolve to a directory. E.g. <code>/path/to/django_project/my_app/components/</code>.</p> <p><code>BASE_DIR</code> setting is required.</p> Source code in <code>src/django_components/template_loader.py</code> <pre><code>def get_dirs(self, include_apps: bool = True) -&gt; List[Path]:\n    \"\"\"\n    Prepare directories that may contain component files:\n\n    Searches for dirs set in `COMPONENTS.dirs` settings. If none set, defaults to searching\n    for a \"components\" app. The dirs in `COMPONENTS.dirs` must be absolute paths.\n\n    In addition to that, also all apps are checked for `[app]/components` dirs.\n\n    Paths are accepted only if they resolve to a directory.\n    E.g. `/path/to/django_project/my_app/components/`.\n\n    `BASE_DIR` setting is required.\n    \"\"\"\n    return get_component_dirs(include_apps)\n</code></pre>"},{"location":"reference/django_components/#django_components.template_parser","title":"template_parser","text":"<p>Overrides for the Django Template system to allow finer control over template parsing.</p> <p>Based on Django Slippers v0.6.2 - https://github.com/mixxorz/slippers/blob/main/slippers/template.py</p> <p>Functions:</p> <ul> <li> <code>parse_bits</code>             \u2013              <p>Parse bits for template tag helpers simple_tag and inclusion_tag, in</p> </li> <li> <code>token_kwargs</code>             \u2013              <p>Parse token keyword arguments and return a dictionary of the arguments</p> </li> </ul>"},{"location":"reference/django_components/#django_components.template_parser.parse_bits","title":"parse_bits","text":"<pre><code>parse_bits(\n    parser: Parser, bits: List[str], params: List[str], name: str\n) -&gt; Tuple[List[FilterExpression], List[Tuple[str, FilterExpression]]]\n</code></pre> <p>Parse bits for template tag helpers simple_tag and inclusion_tag, in particular by detecting syntax errors and by extracting positional and keyword arguments.</p> <p>This is a simplified version of <code>django.template.library.parse_bits</code> where we use custom regex to handle special characters in keyword names.</p> <p>Furthermore, our version allows duplicate keys, and instead of return kwargs as a dict, we return it as a list of key-value pairs. So it is up to the user of this function to decide whether they support duplicate keys or not.</p> Source code in <code>src/django_components/template_parser.py</code> <pre><code>def parse_bits(\n    parser: Parser,\n    bits: List[str],\n    params: List[str],\n    name: str,\n) -&gt; Tuple[List[FilterExpression], List[Tuple[str, FilterExpression]]]:\n    \"\"\"\n    Parse bits for template tag helpers simple_tag and inclusion_tag, in\n    particular by detecting syntax errors and by extracting positional and\n    keyword arguments.\n\n    This is a simplified version of `django.template.library.parse_bits`\n    where we use custom regex to handle special characters in keyword names.\n\n    Furthermore, our version allows duplicate keys, and instead of return kwargs\n    as a dict, we return it as a list of key-value pairs. So it is up to the\n    user of this function to decide whether they support duplicate keys or not.\n    \"\"\"\n    args: List[FilterExpression] = []\n    kwargs: List[Tuple[str, FilterExpression]] = []\n    unhandled_params = list(params)\n    for bit in bits:\n        # First we try to extract a potential kwarg from the bit\n        kwarg = token_kwargs([bit], parser)\n        if kwarg:\n            # The kwarg was successfully extracted\n            param, value = kwarg.popitem()\n            # All good, record the keyword argument\n            kwargs.append((str(param), value))\n            if param in unhandled_params:\n                # If using the keyword syntax for a positional arg, then\n                # consume it.\n                unhandled_params.remove(param)\n        else:\n            if kwargs:\n                raise TemplateSyntaxError(\n                    \"'%s' received some positional argument(s) after some \" \"keyword argument(s)\" % name\n                )\n            else:\n                # Record the positional argument\n                args.append(parser.compile_filter(bit))\n                try:\n                    # Consume from the list of expected positional arguments\n                    unhandled_params.pop(0)\n                except IndexError:\n                    pass\n    if unhandled_params:\n        # Some positional arguments were not supplied\n        raise TemplateSyntaxError(\n            \"'%s' did not receive value(s) for the argument(s): %s\"\n            % (name, \", \".join(\"'%s'\" % p for p in unhandled_params))\n        )\n    return args, kwargs\n</code></pre>"},{"location":"reference/django_components/#django_components.template_parser.token_kwargs","title":"token_kwargs","text":"<pre><code>token_kwargs(bits: List[str], parser: Parser) -&gt; Dict[str, FilterExpression]\n</code></pre> <p>Parse token keyword arguments and return a dictionary of the arguments retrieved from the <code>bits</code> token list.</p> <p><code>bits</code> is a list containing the remainder of the token (split by spaces) that is to be checked for arguments. Valid arguments are removed from this list.</p> <p>There is no requirement for all remaining token <code>bits</code> to be keyword arguments, so return the dictionary as soon as an invalid argument format is reached.</p> Source code in <code>src/django_components/template_parser.py</code> <pre><code>def token_kwargs(bits: List[str], parser: Parser) -&gt; Dict[str, FilterExpression]:\n    \"\"\"\n    Parse token keyword arguments and return a dictionary of the arguments\n    retrieved from the ``bits`` token list.\n\n    `bits` is a list containing the remainder of the token (split by spaces)\n    that is to be checked for arguments. Valid arguments are removed from this\n    list.\n\n    There is no requirement for all remaining token ``bits`` to be keyword\n    arguments, so return the dictionary as soon as an invalid argument format\n    is reached.\n    \"\"\"\n    if not bits:\n        return {}\n    match = kwarg_re.match(bits[0])\n    kwarg_format = match and match[1]\n    if not kwarg_format:\n        return {}\n\n    kwargs: Dict[str, FilterExpression] = {}\n    while bits:\n        if kwarg_format:\n            match = kwarg_re.match(bits[0])\n            if not match or not match[1]:\n                return kwargs\n            key, value = match.groups()\n            del bits[:1]\n        else:\n            if len(bits) &lt; 3 or bits[1] != \"as\":\n                return kwargs\n            key, value = bits[2], bits[0]\n            del bits[:3]\n\n        # This is the only difference from the original token_kwargs. We use\n        # the ComponentsFilterExpression instead of the original FilterExpression.\n        kwargs[key] = ComponentsFilterExpression(value, parser)\n        if bits and not kwarg_format:\n            if bits[0] != \"and\":\n                return kwargs\n            del bits[:1]\n    return kwargs\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags","title":"templatetags","text":"<p>Modules:</p> <ul> <li> <code>component_tags</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/#django_components.templatetags.component_tags","title":"component_tags","text":"<p>Functions:</p> <ul> <li> <code>component</code>             \u2013              <p>Renders one of the components that was previously registered with</p> </li> <li> <code>component_css_dependencies</code>             \u2013              <p>Marks location where CSS link tags should be rendered after the whole HTML has been generated.</p> </li> <li> <code>component_js_dependencies</code>             \u2013              <p>Marks location where JS link tags should be rendered after the whole HTML has been generated.</p> </li> <li> <code>fill</code>             \u2013              <p>Use this tag to insert content into component's slots.</p> </li> <li> <code>html_attrs</code>             \u2013              <p>Generate HTML attributes (<code>key=\"value\"</code>), combining data from multiple sources,</p> </li> <li> <code>provide</code>             \u2013              <p>The \"provider\" part of the provide / inject feature.</p> </li> <li> <code>slot</code>             \u2013              <p>Slot tag marks a place inside a component where content can be inserted</p> </li> </ul>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.TagSpec","title":"TagSpec","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Definition of args, kwargs, flags, etc, for a template tag.</p> <p>Attributes:</p> <ul> <li> <code>end_tag</code>               (<code>Optional[str]</code>)           \u2013            <p>End tag.</p> </li> <li> <code>flags</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>List of allowed flags.</p> </li> <li> <code>keywordonly_args</code>               (<code>Optional[Union[bool, List[str]]]</code>)           \u2013            <p>Parameters that MUST be given only as kwargs (not accounting for <code>pos_or_keyword_args</code>).</p> </li> <li> <code>optional_kwargs</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Specify which kwargs can be optional.</p> </li> <li> <code>pos_or_keyword_args</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Like regular Python kwargs, these can be given EITHER as positional OR as keyword arguments.</p> </li> <li> <code>positional_args_allow_extra</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, allows variable number of positional args, e.g. <code>{% mytag val1 1234 val2 890 ... %}</code></p> </li> <li> <code>positional_only_args</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Arguments that MUST be given as positional args.</p> </li> <li> <code>repeatable_kwargs</code>               (<code>Optional[Union[bool, List[str]]]</code>)           \u2013            <p>Whether this tag allows all or certain kwargs to be repeated.</p> </li> <li> <code>tag</code>               (<code>str</code>)           \u2013            <p>Tag name. E.g. <code>\"slot\"</code> means the tag is written like so <code>{% slot ... %}</code></p> </li> </ul>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.TagSpec.end_tag","title":"end_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_tag: Optional[str] = None\n</code></pre> <p>End tag.</p> <p>E.g. <code>\"endslot\"</code> means anything between the start tag and <code>{% endslot %}</code> is considered the slot's body.</p>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.TagSpec.flags","title":"flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flags: Optional[List[str]] = None\n</code></pre> <p>List of allowed flags.</p> <p>Flags are like kwargs, but without the value part. E.g. in <code>{% mytag only required %}</code>: - <code>only</code> and <code>required</code> are treated as <code>only=True</code> and <code>required=True</code> if present - and treated as <code>only=False</code> and <code>required=False</code> if omitted</p>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.TagSpec.keywordonly_args","title":"keywordonly_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keywordonly_args: Optional[Union[bool, List[str]]] = False\n</code></pre> <p>Parameters that MUST be given only as kwargs (not accounting for <code>pos_or_keyword_args</code>).</p> <ul> <li>If <code>False</code>, NO extra kwargs allowed.</li> <li>If <code>True</code>, ANY number of extra kwargs allowed.</li> <li>If a list of strings, e.g. <code>[\"class\", \"style\"]</code>, then only those kwargs are allowed.</li> </ul>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.TagSpec.optional_kwargs","title":"optional_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>optional_kwargs: Optional[List[str]] = None\n</code></pre> <p>Specify which kwargs can be optional.</p>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.TagSpec.pos_or_keyword_args","title":"pos_or_keyword_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pos_or_keyword_args: Optional[List[str]] = None\n</code></pre> <p>Like regular Python kwargs, these can be given EITHER as positional OR as keyword arguments.</p>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.TagSpec.positional_args_allow_extra","title":"positional_args_allow_extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>positional_args_allow_extra: bool = False\n</code></pre> <p>If <code>True</code>, allows variable number of positional args, e.g. <code>{% mytag val1 1234 val2 890 ... %}</code></p>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.TagSpec.positional_only_args","title":"positional_only_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>positional_only_args: Optional[List[str]] = None\n</code></pre> <p>Arguments that MUST be given as positional args.</p>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.TagSpec.repeatable_kwargs","title":"repeatable_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>repeatable_kwargs: Optional[Union[bool, List[str]]] = False\n</code></pre> <p>Whether this tag allows all or certain kwargs to be repeated.</p> <ul> <li>If <code>False</code>, NO kwargs can repeat.</li> <li>If <code>True</code>, ALL kwargs can repeat.</li> <li>If a list of strings, e.g. <code>[\"class\", \"style\"]</code>, then only those kwargs can repeat.</li> </ul> <p>E.g. <code>[\"class\"]</code> means one can write <code>{% mytag class=\"one\" class=\"two\" %}</code></p>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.TagSpec.tag","title":"tag  <code>instance-attribute</code>","text":"<pre><code>tag: str\n</code></pre> <p>Tag name. E.g. <code>\"slot\"</code> means the tag is written like so <code>{% slot ... %}</code></p>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.component","title":"component","text":"<pre><code>component(parser: Parser, token: Token, registry: ComponentRegistry, tag_name: str, tag_spec: TagSpec) -&gt; ComponentNode\n</code></pre> <p>Renders one of the components that was previously registered with <code>@register()</code> decorator.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Registered name of the component to render</li> <li>All other args and kwargs are defined based on the component itself.</li> </ul> <p>If you defined a component <code>\"my_table\"</code></p> <pre><code>from django_component import Component, register\n\n@register(\"my_table\")\nclass MyTable(Component):\n    template = \"\"\"\n      &lt;table&gt;\n        &lt;thead&gt;\n          {% for header in headers %}\n            &lt;th&gt;{{ header }}&lt;/th&gt;\n          {% endfor %}\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          {% for row in rows %}\n            &lt;tr&gt;\n              {% for cell in row %}\n                &lt;td&gt;{{ cell }}&lt;/td&gt;\n              {% endfor %}\n            &lt;/tr&gt;\n          {% endfor %}\n        &lt;tbody&gt;\n      &lt;/table&gt;\n    \"\"\"\n\n    def get_context_data(self, rows: List, headers: List):\n        return {\n            \"rows\": rows,\n            \"headers\": headers,\n        }\n</code></pre> <p>Then you can render this component by referring to <code>MyTable</code> via its registered name <code>\"my_table\"</code>:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.component--component-input","title":"Component input","text":"<p>Positional and keyword arguments can be literals or template variables.</p> <p>The component name must be a single- or double-quotes string and must be either:</p> <ul> <li> <p>The first positional argument after <code>component</code>:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n</code></pre> </li> <li> <p>Passed as kwarg <code>name</code>:</p> <pre><code>{% component rows=rows headers=headers name=\"my_table\" ... / %}\n</code></pre> </li> </ul>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.component--inserting-into-slots","title":"Inserting into slots","text":"<p>If the component defined any slots, you can pass in the content to be placed inside those slots by inserting <code>{% fill %}</code> tags, directly within the <code>{% component %}</code> tag:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.component--isolating-components","title":"Isolating components","text":"<p>By default, components behave similarly to Django's <code>{% include %}</code>, and the template inside the component has access to the variables defined in the outer template.</p> <p>You can selectively isolate a component, using the <code>only</code> flag, so that the inner template can access only the data that was explicitly passed to it:</p> <pre><code>{% component \"name\" positional_arg keyword_arg=value ... only %}\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@with_tag_spec(\n    TagSpec(\n        tag=\"component\",\n        end_tag=\"endcomponent\",\n        positional_only_args=[],\n        positional_args_allow_extra=True,  # Allow many args\n        keywordonly_args=True,\n        repeatable_kwargs=False,\n        flags=[COMP_ONLY_FLAG],\n    )\n)\ndef component(\n    parser: Parser,\n    token: Token,\n    registry: ComponentRegistry,\n    tag_name: str,\n    tag_spec: TagSpec,\n) -&gt; ComponentNode:\n    \"\"\"\n    Renders one of the components that was previously registered with\n    [`@register()`](./api.md#django_components.register)\n    decorator.\n\n    **Args:**\n\n    - `name` (str, required): Registered name of the component to render\n    - All other args and kwargs are defined based on the component itself.\n\n    If you defined a component `\"my_table\"`\n\n    ```python\n    from django_component import Component, register\n\n    @register(\"my_table\")\n    class MyTable(Component):\n        template = \\\"\\\"\\\"\n          &lt;table&gt;\n            &lt;thead&gt;\n              {% for header in headers %}\n                &lt;th&gt;{{ header }}&lt;/th&gt;\n              {% endfor %}\n            &lt;/thead&gt;\n            &lt;tbody&gt;\n              {% for row in rows %}\n                &lt;tr&gt;\n                  {% for cell in row %}\n                    &lt;td&gt;{{ cell }}&lt;/td&gt;\n                  {% endfor %}\n                &lt;/tr&gt;\n              {% endfor %}\n            &lt;tbody&gt;\n          &lt;/table&gt;\n        \\\"\\\"\\\"\n\n        def get_context_data(self, rows: List, headers: List):\n            return {\n                \"rows\": rows,\n                \"headers\": headers,\n            }\n    ```\n\n    Then you can render this component by referring to `MyTable` via its\n    registered name `\"my_table\"`:\n\n    ```django\n    {% component \"my_table\" rows=rows headers=headers ... / %}\n    ```\n\n    ### Component input\n\n    Positional and keyword arguments can be literals or template variables.\n\n    The component name must be a single- or double-quotes string and must\n    be either:\n\n    - The first positional argument after `component`:\n\n        ```django\n        {% component \"my_table\" rows=rows headers=headers ... / %}\n        ```\n\n    - Passed as kwarg `name`:\n\n        ```django\n        {% component rows=rows headers=headers name=\"my_table\" ... / %}\n        ```\n\n    ### Inserting into slots\n\n    If the component defined any [slots](../concepts/fundamentals/slots.md), you can\n    pass in the content to be placed inside those slots by inserting [`{% fill %}`](#fill) tags,\n    directly within the `{% component %}` tag:\n\n    ```django\n    {% component \"my_table\" rows=rows headers=headers ... / %}\n      {% fill \"pagination\" %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Isolating components\n\n    By default, components behave similarly to Django's\n    [`{% include %}`](https://docs.djangoproject.com/en/5.1/ref/templates/builtins/#include),\n    and the template inside the component has access to the variables defined in the outer template.\n\n    You can selectively isolate a component, using the `only` flag, so that the inner template\n    can access only the data that was explicitly passed to it:\n\n    ```django\n    {% component \"name\" positional_arg keyword_arg=value ... only %}\n    ```\n    \"\"\"\n    _fix_nested_tags(parser, token)\n    bits = token.split_contents()\n\n    # Let the TagFormatter pre-process the tokens\n    formatter = get_tag_formatter(registry)\n    result = formatter.parse([*bits])\n    end_tag = formatter.end_tag(result.component_name)\n\n    # NOTE: The tokens returned from TagFormatter.parse do NOT include the tag itself\n    bits = [bits[0], *result.tokens]\n    token.contents = \" \".join(bits)\n\n    tag = _parse_tag(\n        parser,\n        token,\n        TagSpec(\n            **{\n                **tag_spec._asdict(),\n                \"tag\": tag_name,\n                \"end_tag\": end_tag,\n            }\n        ),\n    )\n\n    # Check for isolated context keyword\n    isolated_context = tag.flags[COMP_ONLY_FLAG]\n\n    trace_msg(\"PARSE\", \"COMP\", result.component_name, tag.id)\n\n    body = tag.parse_body()\n\n    component_node = ComponentNode(\n        name=result.component_name,\n        args=tag.args,\n        kwargs=tag.kwargs,\n        isolated_context=isolated_context,\n        nodelist=body,\n        node_id=tag.id,\n        registry=registry,\n    )\n\n    trace_msg(\"PARSE\", \"COMP\", result.component_name, tag.id, \"...Done!\")\n    return component_node\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.component_css_dependencies","title":"component_css_dependencies","text":"<pre><code>component_css_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode\n</code></pre> <p>Marks location where CSS link tags should be rendered after the whole HTML has been generated.</p> <p>Generally, this should be inserted into the <code>&lt;head&gt;</code> tag of the HTML.</p> <p>If the generated HTML does NOT contain any <code>{% component_css_dependencies %}</code> tags, CSS links are by default inserted into the <code>&lt;head&gt;</code> tag of the HTML. (See JS and CSS output locations)</p> <p>Note that there should be only one <code>{% component_css_dependencies %}</code> for the whole HTML document. If you insert this tag multiple times, ALL CSS links will be duplicately inserted into ALL these places.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"component_css_dependencies\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"component_css_dependencies\",\n        end_tag=None,  # inline-only\n    )\n)\ndef component_css_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode:\n    \"\"\"\n    Marks location where CSS link tags should be rendered after the whole HTML has been generated.\n\n    Generally, this should be inserted into the `&lt;head&gt;` tag of the HTML.\n\n    If the generated HTML does NOT contain any `{% component_css_dependencies %}` tags, CSS links\n    are by default inserted into the `&lt;head&gt;` tag of the HTML. (See\n    [JS and CSS output locations](../../concepts/advanced/rendering_js_css/#js-and-css-output-locations))\n\n    Note that there should be only one `{% component_css_dependencies %}` for the whole HTML document.\n    If you insert this tag multiple times, ALL CSS links will be duplicately inserted into ALL these places.\n    \"\"\"\n    # Parse to check that the syntax is valid\n    _parse_tag(parser, token, tag_spec)\n    return _component_dependencies(\"css\")\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.component_js_dependencies","title":"component_js_dependencies","text":"<pre><code>component_js_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode\n</code></pre> <p>Marks location where JS link tags should be rendered after the whole HTML has been generated.</p> <p>Generally, this should be inserted at the end of the <code>&lt;body&gt;</code> tag of the HTML.</p> <p>If the generated HTML does NOT contain any <code>{% component_js_dependencies %}</code> tags, JS scripts are by default inserted at the end of the <code>&lt;body&gt;</code> tag of the HTML. (See JS and CSS output locations)</p> <p>Note that there should be only one <code>{% component_js_dependencies %}</code> for the whole HTML document. If you insert this tag multiple times, ALL JS scripts will be duplicately inserted into ALL these places.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(name=\"component_js_dependencies\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"component_js_dependencies\",\n        end_tag=None,  # inline-only\n    )\n)\ndef component_js_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode:\n    \"\"\"\n    Marks location where JS link tags should be rendered after the whole HTML has been generated.\n\n    Generally, this should be inserted at the end of the `&lt;body&gt;` tag of the HTML.\n\n    If the generated HTML does NOT contain any `{% component_js_dependencies %}` tags, JS scripts\n    are by default inserted at the end of the `&lt;body&gt;` tag of the HTML. (See\n    [JS and CSS output locations](../../concepts/advanced/rendering_js_css/#js-and-css-output-locations))\n\n    Note that there should be only one `{% component_js_dependencies %}` for the whole HTML document.\n    If you insert this tag multiple times, ALL JS scripts will be duplicately inserted into ALL these places.\n    \"\"\"\n    # Parse to check that the syntax is valid\n    _parse_tag(parser, token, tag_spec)\n    return _component_dependencies(\"js\")\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.fill","title":"fill","text":"<pre><code>fill(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; FillNode\n</code></pre> <p>Use this tag to insert content into component's slots.</p> <p><code>{% fill %}</code> tag may be used only within a <code>{% component %}..{% endcomponent %}</code> block. Runtime checks should prohibit other usages.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Name of the slot to insert this content into. Use <code>\"default\"</code> for     the default slot.</li> <li><code>default</code> (str, optional): This argument allows you to access the original content of the slot     under the specified variable name. See     Accessing original content of slots</li> <li><code>data</code> (str, optional): This argument allows you to access the data passed to the slot     under the specified variable name. See Scoped slots</li> </ul> <p>Examples:</p> <p>Basic usage: <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre></p>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.fill--accessing-slots-default-content-with-the-default-kwarg","title":"Accessing slot's default content with the <code>default</code> kwarg","text":"<pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" default=\"default_pag\" %}\n    &lt;div class=\"my-class\"&gt;\n      {{ default_pag }}\n    &lt;/div&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.fill--accessing-slots-data-with-the-data-kwarg","title":"Accessing slot's data with the <code>data</code> kwarg","text":"<pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" pages=pages %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" data=\"slot_data\" %}\n    {% for page in slot_data.pages %}\n        &lt;a href=\"{{ page.link }}\"&gt;\n          {{ page.index }}\n        &lt;/a&gt;\n    {% endfor %}\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.fill--accessing-slot-data-and-default-content-on-the-default-slot","title":"Accessing slot data and default content on the default slot","text":"<p>To access slot data and the default slot content on the default slot, use <code>{% fill %}</code> with <code>name</code> set to <code>\"default\"</code>:</p> <pre><code>{% component \"button\" %}\n  {% fill name=\"default\" data=\"slot_data\" default=\"default_slot\" %}\n    You clicked me {{ slot_data.count }} times!\n    {{ default_slot }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"fill\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"fill\",\n        end_tag=\"endfill\",\n        positional_only_args=[],\n        pos_or_keyword_args=[SLOT_NAME_KWARG],\n        keywordonly_args=[SLOT_DATA_KWARG, SLOT_DEFAULT_KWARG],\n        optional_kwargs=[SLOT_DATA_KWARG, SLOT_DEFAULT_KWARG],\n        repeatable_kwargs=False,\n    )\n)\ndef fill(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; FillNode:\n    \"\"\"\n    Use this tag to insert content into component's slots.\n\n    `{% fill %}` tag may be used only within a `{% component %}..{% endcomponent %}` block.\n    Runtime checks should prohibit other usages.\n\n    **Args:**\n\n    - `name` (str, required): Name of the slot to insert this content into. Use `\"default\"` for\n        the default slot.\n    - `default` (str, optional): This argument allows you to access the original content of the slot\n        under the specified variable name. See\n        [Accessing original content of slots](../../concepts/fundamentals/slots#accessing-original-content-of-slots)\n    - `data` (str, optional): This argument allows you to access the data passed to the slot\n        under the specified variable name. See [Scoped slots](../../concepts/fundamentals/slots#scoped-slots)\n\n    **Examples:**\n\n    Basic usage:\n    ```django\n    {% component \"my_table\" %}\n      {% fill \"pagination\" %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Accessing slot's default content with the `default` kwarg\n\n    ```django\n    {# my_table.html #}\n    &lt;table&gt;\n      ...\n      {% slot \"pagination\" %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endslot %}\n    &lt;/table&gt;\n    ```\n\n    ```django\n    {% component \"my_table\" %}\n      {% fill \"pagination\" default=\"default_pag\" %}\n        &lt;div class=\"my-class\"&gt;\n          {{ default_pag }}\n        &lt;/div&gt;\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Accessing slot's data with the `data` kwarg\n\n    ```django\n    {# my_table.html #}\n    &lt;table&gt;\n      ...\n      {% slot \"pagination\" pages=pages %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endslot %}\n    &lt;/table&gt;\n    ```\n\n    ```django\n    {% component \"my_table\" %}\n      {% fill \"pagination\" data=\"slot_data\" %}\n        {% for page in slot_data.pages %}\n            &lt;a href=\"{{ page.link }}\"&gt;\n              {{ page.index }}\n            &lt;/a&gt;\n        {% endfor %}\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Accessing slot data and default content on the default slot\n\n    To access slot data and the default slot content on the default slot,\n    use `{% fill %}` with `name` set to `\"default\"`:\n\n    ```django\n    {% component \"button\" %}\n      {% fill name=\"default\" data=\"slot_data\" default=\"default_slot\" %}\n        You clicked me {{ slot_data.count }} times!\n        {{ default_slot }}\n      {% endfill %}\n    {% endcomponent %}\n    ```\n    \"\"\"\n    tag = _parse_tag(parser, token, tag_spec)\n\n    fill_name_kwarg = tag.kwargs.kwargs.get(SLOT_NAME_KWARG, None)\n    trace_id = f\"fill-id-{tag.id} ({fill_name_kwarg})\" if fill_name_kwarg else f\"fill-id-{tag.id}\"\n\n    trace_msg(\"PARSE\", \"FILL\", trace_id, tag.id)\n\n    body = tag.parse_body()\n    fill_node = FillNode(\n        nodelist=body,\n        node_id=tag.id,\n        kwargs=tag.kwargs,\n        trace_id=trace_id,\n    )\n\n    trace_msg(\"PARSE\", \"FILL\", trace_id, tag.id, \"...Done!\")\n    return fill_node\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.html_attrs","title":"html_attrs","text":"<pre><code>html_attrs(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; HtmlAttrsNode\n</code></pre> <p>Generate HTML attributes (<code>key=\"value\"</code>), combining data from multiple sources, whether its template variables or static text.</p> <p>It is designed to easily merge HTML attributes passed from outside with the internal. See how to in Passing HTML attributes to components.</p> <p>Args:</p> <ul> <li><code>attrs</code> (dict, optional): Optional dictionary that holds HTML attributes. On conflict, overrides     values in the <code>default</code> dictionary.</li> <li><code>default</code> (str, optional): Optional dictionary that holds HTML attributes. On conflict, is overriden     with values in the <code>attrs</code> dictionary.</li> <li>Any extra kwargs will be appended to the corresponding keys</li> </ul> <p>The attributes in <code>attrs</code> and <code>defaults</code> are merged and resulting dict is rendered as HTML attributes (<code>key=\"value\"</code>).</p> <p>Extra kwargs (<code>key=value</code>) are concatenated to existing keys. So if we have</p> <pre><code>attrs = {\"class\": \"my-class\"}\n</code></pre> <p>Then</p> <pre><code>{% html_attrs attrs class=\"extra-class\" %}\n</code></pre> <p>will result in <code>class=\"my-class extra-class\"</code>.</p> <p>Example: <pre><code>&lt;div {% html_attrs\n    attrs\n    defaults:class=\"default-class\"\n    class=\"extra-class\"\n    data-id=\"123\"\n%}&gt;\n</code></pre></p> <p>renders</p> <pre><code>&lt;div class=\"my-class extra-class\" data-id=\"123\"&gt;\n</code></pre> <p>See more usage examples in HTML attributes.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"html_attrs\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"html_attrs\",\n        end_tag=None,  # inline-only\n        positional_only_args=[],\n        pos_or_keyword_args=[HTML_ATTRS_ATTRS_KEY, HTML_ATTRS_DEFAULTS_KEY],\n        optional_kwargs=[HTML_ATTRS_ATTRS_KEY, HTML_ATTRS_DEFAULTS_KEY],\n        keywordonly_args=True,\n        repeatable_kwargs=True,\n        flags=[],\n    )\n)\ndef html_attrs(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; HtmlAttrsNode:\n    \"\"\"\n    Generate HTML attributes (`key=\"value\"`), combining data from multiple sources,\n    whether its template variables or static text.\n\n    It is designed to easily merge HTML attributes passed from outside with the internal.\n    See how to in [Passing HTML attributes to components](../../guides/howto/passing_html_attrs/).\n\n    **Args:**\n\n    - `attrs` (dict, optional): Optional dictionary that holds HTML attributes. On conflict, overrides\n        values in the `default` dictionary.\n    - `default` (str, optional): Optional dictionary that holds HTML attributes. On conflict, is overriden\n        with values in the `attrs` dictionary.\n    - Any extra kwargs will be appended to the corresponding keys\n\n    The attributes in `attrs` and `defaults` are merged and resulting dict is rendered as HTML attributes\n    (`key=\"value\"`).\n\n    Extra kwargs (`key=value`) are concatenated to existing keys. So if we have\n\n    ```python\n    attrs = {\"class\": \"my-class\"}\n    ```\n\n    Then\n\n    ```django\n    {% html_attrs attrs class=\"extra-class\" %}\n    ```\n\n    will result in `class=\"my-class extra-class\"`.\n\n    **Example:**\n    ```django\n    &lt;div {% html_attrs\n        attrs\n        defaults:class=\"default-class\"\n        class=\"extra-class\"\n        data-id=\"123\"\n    %}&gt;\n    ```\n\n    renders\n\n    ```html\n    &lt;div class=\"my-class extra-class\" data-id=\"123\"&gt;\n    ```\n\n    **See more usage examples in\n    [HTML attributes](../../concepts/fundamentals/html_attributes#examples-for-html_attrs).**\n    \"\"\"\n    tag = _parse_tag(parser, token, tag_spec)\n\n    return HtmlAttrsNode(\n        kwargs=tag.kwargs,\n        kwarg_pairs=tag.kwarg_pairs,\n    )\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.provide","title":"provide","text":"<pre><code>provide(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; ProvideNode\n</code></pre> <p>The \"provider\" part of the provide / inject feature. Pass kwargs to this tag to define the provider's data. Any components defined within the <code>{% provide %}..{% endprovide %}</code> tags will be able to access this data with <code>Component.inject()</code>.</p> <p>This is similar to React's <code>ContextProvider</code>, or Vue's <code>provide()</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Provider name. This is the name you will then use in     <code>Component.inject()</code>.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the provided data.</li> </ul> <p>Example:</p> <p>Provide the \"user_data\" in parent component:</p> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% provide \"user_data\" user=user %}\n          {% component \"child\" / %}\n        {% endprovide %}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_context_data(self, user: User):\n        return {\n            \"user\": user,\n        }\n</code></pre> <p>Since the \"child\" component is used within the <code>{% provide %} / {% endprovide %}</code> tags, we can request the \"user_data\" using <code>Component.inject(\"user_data\")</code>:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        User is: {{ user }}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_context_data(self):\n        user = self.inject(\"user_data\").user\n        return {\n            \"user\": user,\n        }\n</code></pre> <p>Notice that the keys defined on the <code>{% provide %}</code> tag are then accessed as attributes when accessing them with <code>Component.inject()</code>.</p> <p>\u2705 Do this <pre><code>user = self.inject(\"user_data\").user\n</code></pre></p> <p>\u274c Don't do this <pre><code>user = self.inject(\"user_data\")[\"user\"]\n</code></pre></p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"provide\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"provide\",\n        end_tag=\"endprovide\",\n        positional_only_args=[],\n        pos_or_keyword_args=[PROVIDE_NAME_KWARG],\n        keywordonly_args=True,\n        repeatable_kwargs=False,\n        flags=[],\n    )\n)\ndef provide(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; ProvideNode:\n    \"\"\"\n    The \"provider\" part of the [provide / inject feature](../../concepts/advanced/provide_inject).\n    Pass kwargs to this tag to define the provider's data.\n    Any components defined within the `{% provide %}..{% endprovide %}` tags will be able to access this data\n    with [`Component.inject()`](../api#django_components.Component.inject).\n\n    This is similar to React's [`ContextProvider`](https://react.dev/learn/passing-data-deeply-with-context),\n    or Vue's [`provide()`](https://vuejs.org/guide/components/provide-inject).\n\n    **Args:**\n\n    - `name` (str, required): Provider name. This is the name you will then use in\n        [`Component.inject()`](../api#django_components.Component.inject).\n    - `**kwargs`: Any extra kwargs will be passed as the provided data.\n\n    **Example:**\n\n    Provide the \"user_data\" in parent component:\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% provide \"user_data\" user=user %}\n              {% component \"child\" / %}\n            {% endprovide %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n\n        def get_context_data(self, user: User):\n            return {\n                \"user\": user,\n            }\n    ```\n\n    Since the \"child\" component is used within the `{% provide %} / {% endprovide %}` tags,\n    we can request the \"user_data\" using `Component.inject(\"user_data\")`:\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            User is: {{ user }}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n\n        def get_context_data(self):\n            user = self.inject(\"user_data\").user\n            return {\n                \"user\": user,\n            }\n    ```\n\n    Notice that the keys defined on the `{% provide %}` tag are then accessed as attributes\n    when accessing them with [`Component.inject()`](../api#django_components.Component.inject).\n\n    \u2705 Do this\n    ```python\n    user = self.inject(\"user_data\").user\n    ```\n\n    \u274c Don't do this\n    ```python\n    user = self.inject(\"user_data\")[\"user\"]\n    ```\n    \"\"\"\n    # e.g. {% provide &lt;name&gt; key=val key2=val2 %}\n    tag = _parse_tag(parser, token, tag_spec)\n\n    name_kwarg = tag.kwargs.kwargs.get(PROVIDE_NAME_KWARG, None)\n    trace_id = f\"provide-id-{tag.id} ({name_kwarg})\" if name_kwarg else f\"fill-id-{tag.id}\"\n\n    trace_msg(\"PARSE\", \"PROVIDE\", trace_id, tag.id)\n\n    body = tag.parse_body()\n    provide_node = ProvideNode(\n        nodelist=body,\n        node_id=tag.id,\n        kwargs=tag.kwargs,\n        trace_id=trace_id,\n    )\n\n    trace_msg(\"PARSE\", \"PROVIDE\", trace_id, tag.id, \"...Done!\")\n    return provide_node\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.slot","title":"slot","text":"<pre><code>slot(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; SlotNode\n</code></pre> <p>Slot tag marks a place inside a component where content can be inserted from outside.</p> <p>Learn more about using slots.</p> <p>This is similar to slots as seen in Web components, Vue or React's <code>children</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Registered name of the component to render</li> <li><code>default</code>: Optional flag. If there is a default slot, you can pass the component slot content     without using the <code>{% fill %}</code> tag. See     Default slot</li> <li><code>required</code>: Optional flag. Will raise an error if a slot is required but not given.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the slot data.</li> </ul> <p>Example:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" default %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n      &lt;aside&gt;\n        {% slot \"sidebar\" required / %}\n      &lt;/aside&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% component \"child\" %}\n          {% fill \"content\" %}\n            \ud83d\uddde\ufe0f\ud83d\udcf0\n          {% endfill %}\n\n          {% fill \"sidebar\" %}\n            \ud83c\udf77\ud83e\uddc9\ud83c\udf7e\n          {% endfill %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.slot--passing-data-to-slots","title":"Passing data to slots","text":"<p>Any extra kwargs will be considered as slot data, and will be accessible in the <code>{% fill %}</code> tag via fill's <code>data</code> kwarg:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {# Passing data to the slot #}\n        {% slot \"content\" user=user %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot data #}\n      {% component \"child\" %}\n        {% fill \"content\" data=\"data\" %}\n          &lt;div class=\"wrapper-class\"&gt;\n            {{ data.user }}\n          &lt;/div&gt;\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.slot--accessing-default-slot-content","title":"Accessing default slot content","text":"<p>The content between the <code>{% slot %}..{% endslot %}</code> tags is the default content that will be rendered if no fill is given for the slot.</p> <p>This default content can then be accessed from within the <code>{% fill %}</code> tag using the fill's <code>default</code> kwarg. This is useful if you need to wrap / prepend / append the original slot's content.</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" %}\n          This is default content!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot's default content #}\n      {% component \"child\" %}\n        {% fill \"content\" default=\"default\" %}\n          {{ default }}\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"slot\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"slot\",\n        end_tag=\"endslot\",\n        positional_only_args=[],\n        pos_or_keyword_args=[SLOT_NAME_KWARG],\n        keywordonly_args=True,\n        repeatable_kwargs=False,\n        flags=[SLOT_DEFAULT_KEYWORD, SLOT_REQUIRED_KEYWORD],\n    )\n)\ndef slot(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; SlotNode:\n    \"\"\"\n    Slot tag marks a place inside a component where content can be inserted\n    from outside.\n\n    [Learn more](../../concepts/fundamentals/slots) about using slots.\n\n    This is similar to slots as seen in\n    [Web components](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot),\n    [Vue](https://vuejs.org/guide/components/slots.html)\n    or [React's `children`](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children).\n\n    **Args:**\n\n    - `name` (str, required): Registered name of the component to render\n    - `default`: Optional flag. If there is a default slot, you can pass the component slot content\n        without using the [`{% fill %}`](#fill) tag. See\n        [Default slot](../../concepts/fundamentals/slots#default-slot)\n    - `required`: Optional flag. Will raise an error if a slot is required but not given.\n    - `**kwargs`: Any extra kwargs will be passed as the slot data.\n\n    **Example:**\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% slot \"content\" default %}\n              This is shown if not overriden!\n            {% endslot %}\n          &lt;/div&gt;\n          &lt;aside&gt;\n            {% slot \"sidebar\" required / %}\n          &lt;/aside&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% component \"child\" %}\n              {% fill \"content\" %}\n                \ud83d\uddde\ufe0f\ud83d\udcf0\n              {% endfill %}\n\n              {% fill \"sidebar\" %}\n                \ud83c\udf77\ud83e\uddc9\ud83c\udf7e\n              {% endfill %}\n            {% endcomponent %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ### Passing data to slots\n\n    Any extra kwargs will be considered as slot data, and will be accessible in the [`{% fill %}`](#fill)\n    tag via fill's `data` kwarg:\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {# Passing data to the slot #}\n            {% slot \"content\" user=user %}\n              This is shown if not overriden!\n            {% endslot %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          {# Parent can access the slot data #}\n          {% component \"child\" %}\n            {% fill \"content\" data=\"data\" %}\n              &lt;div class=\"wrapper-class\"&gt;\n                {{ data.user }}\n              &lt;/div&gt;\n            {% endfill %}\n          {% endcomponent %}\n        \\\"\\\"\\\"\n    ```\n\n    ### Accessing default slot content\n\n    The content between the `{% slot %}..{% endslot %}` tags is the default content that\n    will be rendered if no fill is given for the slot.\n\n    This default content can then be accessed from within the [`{% fill %}`](#fill) tag using\n    the fill's `default` kwarg.\n    This is useful if you need to wrap / prepend / append the original slot's content.\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% slot \"content\" %}\n              This is default content!\n            {% endslot %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          {# Parent can access the slot's default content #}\n          {% component \"child\" %}\n            {% fill \"content\" default=\"default\" %}\n              {{ default }}\n            {% endfill %}\n          {% endcomponent %}\n        \\\"\\\"\\\"\n    ```\n    \"\"\"\n    tag = _parse_tag(parser, token, tag_spec)\n\n    slot_name_kwarg = tag.kwargs.kwargs.get(SLOT_NAME_KWARG, None)\n    trace_id = f\"slot-id-{tag.id} ({slot_name_kwarg})\" if slot_name_kwarg else f\"slot-id-{tag.id}\"\n\n    trace_msg(\"PARSE\", \"SLOT\", trace_id, tag.id)\n\n    body = tag.parse_body()\n    slot_node = SlotNode(\n        nodelist=body,\n        node_id=tag.id,\n        kwargs=tag.kwargs,\n        is_required=tag.flags[SLOT_REQUIRED_KEYWORD],\n        is_default=tag.flags[SLOT_DEFAULT_KEYWORD],\n        trace_id=trace_id,\n    )\n\n    trace_msg(\"PARSE\", \"SLOT\", trace_id, tag.id, \"...Done!\")\n    return slot_node\n</code></pre>"},{"location":"reference/django_components/#django_components.templatetags.component_tags.with_tag_spec","title":"with_tag_spec","text":"<pre><code>with_tag_spec(tag_spec: TagSpec) -&gt; Callable\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def with_tag_spec(tag_spec: TagSpec) -&gt; Callable:\n    \"\"\"\"\"\"\n\n    def decorator(fn: Callable) -&gt; Any:\n        fn._tag_spec = tag_spec  # type: ignore[attr-defined]\n\n        @functools.wraps(fn)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            return fn(*args, **kwargs, tag_spec=tag_spec)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/#django_components.types","title":"types","text":"<p>Helper types for IDEs.</p>"},{"location":"reference/django_components/#django_components.util","title":"util","text":"<p>Modules:</p> <ul> <li> <code>cache</code>           \u2013            </li> <li> <code>html</code>           \u2013            </li> <li> <code>loader</code>           \u2013            </li> <li> <code>logger</code>           \u2013            </li> <li> <code>misc</code>           \u2013            </li> <li> <code>tag_parser</code>           \u2013            </li> <li> <code>types</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/#django_components.util.cache","title":"cache","text":"<p>Functions:</p> <ul> <li> <code>lazy_cache</code>             \u2013              <p>Decorator that caches the given function similarly to <code>functools.lru_cache</code>.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.util.cache.lazy_cache","title":"lazy_cache","text":"<pre><code>lazy_cache(make_cache: Callable[[], Callable[[Callable], Callable]]) -&gt; Callable[[TFunc], TFunc]\n</code></pre> <p>Decorator that caches the given function similarly to <code>functools.lru_cache</code>. But the cache is instantiated only at first invocation.</p> <p><code>cache</code> argument is a function that generates the cache function, e.g. <code>functools.lru_cache()</code>.</p> Source code in <code>src/django_components/util/cache.py</code> <pre><code>def lazy_cache(\n    make_cache: Callable[[], Callable[[Callable], Callable]],\n) -&gt; Callable[[TFunc], TFunc]:\n    \"\"\"\n    Decorator that caches the given function similarly to `functools.lru_cache`.\n    But the cache is instantiated only at first invocation.\n\n    `cache` argument is a function that generates the cache function,\n    e.g. `functools.lru_cache()`.\n    \"\"\"\n    _cached_fn = None\n\n    def decorator(fn: TFunc) -&gt; TFunc:\n        @functools.wraps(fn)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            # Lazily initialize the cache\n            nonlocal _cached_fn\n            if not _cached_fn:\n                # E.g. `lambda: functools.lru_cache(maxsize=app_settings.TEMPLATE_CACHE_SIZE)`\n                cache = make_cache()\n                _cached_fn = cache(fn)\n\n            return _cached_fn(*args, **kwargs)\n\n        # Allow to access the LRU cache methods\n        # See https://stackoverflow.com/a/37654201/9788634\n        wrapper.cache_info = lambda: _cached_fn.cache_info()  # type: ignore\n        wrapper.cache_clear = lambda: _cached_fn.cache_clear()  # type: ignore\n\n        # And allow to remove the cache instance (mostly for tests)\n        def cache_remove() -&gt; None:\n            nonlocal _cached_fn\n            _cached_fn = None\n\n        wrapper.cache_remove = cache_remove  # type: ignore\n\n        return cast(TFunc, wrapper)\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/#django_components.util.html","title":"html","text":"<p>Functions:</p> <ul> <li> <code>parse_document_or_nodes</code>             \u2013              <p>Use this if you do NOT know whether the given HTML is a full document</p> </li> <li> <code>parse_multiroot_html</code>             \u2013              <p>Use this when you know the given HTML is a multiple nodes like</p> </li> <li> <code>parse_node</code>             \u2013              <p>Use this when you know the given HTML is a single node like</p> </li> </ul>"},{"location":"reference/django_components/#django_components.util.html.parse_document_or_nodes","title":"parse_document_or_nodes","text":"<pre><code>parse_document_or_nodes(html: str) -&gt; Union[List[LexborNode], LexborHTMLParser]\n</code></pre> <p>Use this if you do NOT know whether the given HTML is a full document with <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, and <code>&lt;body&gt;</code> tags, or an HTML fragment.</p> Source code in <code>src/django_components/util/html.py</code> <pre><code>def parse_document_or_nodes(html: str) -&gt; Union[List[LexborNode], LexborHTMLParser]:\n    \"\"\"\n    Use this if you do NOT know whether the given HTML is a full document\n    with `&lt;html&gt;`, `&lt;head&gt;`, and `&lt;body&gt;` tags, or an HTML fragment.\n    \"\"\"\n    html = html.strip()\n    tree = LexborHTMLParser(html)\n    is_fragment = is_html_parser_fragment(html, tree)\n\n    if is_fragment:\n        nodes = parse_multiroot_html(html)\n        return nodes\n    else:\n        return tree\n</code></pre>"},{"location":"reference/django_components/#django_components.util.html.parse_multiroot_html","title":"parse_multiroot_html","text":"<pre><code>parse_multiroot_html(html: str) -&gt; List[LexborNode]\n</code></pre> <p>Use this when you know the given HTML is a multiple nodes like</p> <p><code>&lt;div&gt; Hi &lt;/div&gt; &lt;span&gt; Hello &lt;/span&gt;</code></p> Source code in <code>src/django_components/util/html.py</code> <pre><code>def parse_multiroot_html(html: str) -&gt; List[LexborNode]:\n    \"\"\"\n    Use this when you know the given HTML is a multiple nodes like\n\n    `&lt;div&gt; Hi &lt;/div&gt; &lt;span&gt; Hello &lt;/span&gt;`\n    \"\"\"\n    # NOTE: HTML / XML MUST have a single root. So, to support multiple\n    # top-level elements, we wrap them in a dummy singular root.\n    parser = LexborHTMLParser(f\"&lt;root&gt;{html}&lt;/root&gt;\")\n\n    # Get all contents of the root\n    root_elem = parser.css_first(\"root\")\n    elems = [*root_elem.iter()] if root_elem else []\n    return elems\n</code></pre>"},{"location":"reference/django_components/#django_components.util.html.parse_node","title":"parse_node","text":"<pre><code>parse_node(html: str) -&gt; LexborNode\n</code></pre> <p>Use this when you know the given HTML is a single node like</p> <p><code>&lt;div&gt; Hi &lt;/div&gt;</code></p> Source code in <code>src/django_components/util/html.py</code> <pre><code>def parse_node(html: str) -&gt; LexborNode:\n    \"\"\"\n    Use this when you know the given HTML is a single node like\n\n    `&lt;div&gt; Hi &lt;/div&gt;`\n    \"\"\"\n    tree = LexborHTMLParser(html)\n    # NOTE: The parser automatically places &lt;style&gt; tags inside &lt;head&gt;\n    # while &lt;script&gt; tags are inside &lt;body&gt;.\n    return tree.body.child or tree.head.child  # type: ignore[union-attr, return-value]\n</code></pre>"},{"location":"reference/django_components/#django_components.util.loader","title":"loader","text":"<p>Classes:</p> <ul> <li> <code>ComponentFileEntry</code>           \u2013            <p>Result returned by <code>get_component_files()</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_component_dirs</code>             \u2013              <p>Get directories that may contain component files.</p> </li> <li> <code>get_component_files</code>             \u2013              <p>Search for files within the component directories (as defined in</p> </li> </ul>"},{"location":"reference/django_components/#django_components.util.loader.ComponentFileEntry","title":"ComponentFileEntry","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Result returned by <code>get_component_files()</code>.</p> <p>Attributes:</p> <ul> <li> <code>dot_path</code>               (<code>str</code>)           \u2013            <p>The python import path for the module. E.g. <code>app.components.mycomp</code></p> </li> <li> <code>filepath</code>               (<code>Path</code>)           \u2013            <p>The filesystem path to the module. E.g. <code>/path/to/project/app/components/mycomp.py</code></p> </li> </ul>"},{"location":"reference/django_components/#django_components.util.loader.ComponentFileEntry.dot_path","title":"dot_path  <code>instance-attribute</code>","text":"<pre><code>dot_path: str\n</code></pre> <p>The python import path for the module. E.g. <code>app.components.mycomp</code></p>"},{"location":"reference/django_components/#django_components.util.loader.ComponentFileEntry.filepath","title":"filepath  <code>instance-attribute</code>","text":"<pre><code>filepath: Path\n</code></pre> <p>The filesystem path to the module. E.g. <code>/path/to/project/app/components/mycomp.py</code></p>"},{"location":"reference/django_components/#django_components.util.loader.get_component_dirs","title":"get_component_dirs","text":"<pre><code>get_component_dirs(include_apps: bool = True) -&gt; List[Path]\n</code></pre> <p>Get directories that may contain component files.</p> <p>This is the heart of all features that deal with filesystem and file lookup. Autodiscovery, Django template resolution, static file resolution - They all use this.</p> <p>Parameters:</p> <ul> <li> <code>include_apps</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Include directories from installed Django apps.            Defaults to <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Path]</code>           \u2013            <p>List[Path]: A list of directories that may contain component files.</p> </li> </ul> <p><code>get_component_dirs()</code> searches for dirs set in <code>COMPONENTS.dirs</code> settings. If none set, defaults to searching for a <code>\"components\"</code> app.</p> <p>In addition to that, also all installed Django apps are checked whether they contain directories as set in <code>COMPONENTS.app_dirs</code> (e.g. <code>[app]/components</code>).</p> <p>Notes:</p> <ul> <li> <p>Paths that do not point to directories are ignored.</p> </li> <li> <p><code>BASE_DIR</code> setting is required.</p> </li> <li> <p>The paths in <code>COMPONENTS.dirs</code>     must be absolute paths.</p> </li> </ul> Source code in <code>src/django_components/util/loader.py</code> <pre><code>def get_component_dirs(include_apps: bool = True) -&gt; List[Path]:\n    \"\"\"\n    Get directories that may contain component files.\n\n    This is the heart of all features that deal with filesystem and file lookup.\n    Autodiscovery, Django template resolution, static file resolution - They all use this.\n\n    Args:\n        include_apps (bool, optional): Include directories from installed Django apps.\\\n            Defaults to `True`.\n\n    Returns:\n        List[Path]: A list of directories that may contain component files.\n\n    `get_component_dirs()` searches for dirs set in\n    [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n    settings. If none set, defaults to searching for a `\"components\"` app.\n\n    In addition to that, also all installed Django apps are checked whether they contain\n    directories as set in\n    [`COMPONENTS.app_dirs`](../settings#django_components.app_settings.ComponentsSettings.app_dirs)\n    (e.g. `[app]/components`).\n\n    **Notes:**\n\n    - Paths that do not point to directories are ignored.\n\n    - `BASE_DIR` setting is required.\n\n    - The paths in [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n        must be absolute paths.\n    \"\"\"\n    # Allow to configure from settings which dirs should be checked for components\n    component_dirs = app_settings.DIRS\n\n    # TODO_REMOVE_IN_V1\n    raw_component_settings = getattr(settings, \"COMPONENTS\", {})\n    if isinstance(raw_component_settings, dict):\n        raw_dirs_value = raw_component_settings.get(\"dirs\", None)\n    elif isinstance(raw_component_settings, ComponentsSettings):\n        raw_dirs_value = raw_component_settings.dirs\n    else:\n        raw_dirs_value = None\n    is_component_dirs_set = raw_dirs_value is not None\n    is_legacy_paths = (\n        # Use value of `STATICFILES_DIRS` ONLY if `COMPONENT.dirs` not set\n        not is_component_dirs_set\n        and hasattr(settings, \"STATICFILES_DIRS\")\n        and settings.STATICFILES_DIRS\n    )\n    if is_legacy_paths:\n        # NOTE: For STATICFILES_DIRS, we use the defaults even for empty list.\n        # We don't do this for COMPONENTS.dirs, so user can explicitly specify \"NO dirs\".\n        component_dirs = settings.STATICFILES_DIRS or [settings.BASE_DIR / \"components\"]\n    # END TODO_REMOVE_IN_V1\n\n    source = \"STATICFILES_DIRS\" if is_legacy_paths else \"COMPONENTS.dirs\"\n\n    logger.debug(\n        \"get_component_dirs will search for valid dirs from following options:\\n\"\n        + \"\\n\".join([f\" - {str(d)}\" for d in component_dirs])\n    )\n\n    # Add `[app]/[APP_DIR]` to the directories. This is, by default `[app]/components`\n    app_paths: List[Path] = []\n    if include_apps:\n        for conf in apps.get_app_configs():\n            for app_dir in app_settings.APP_DIRS:\n                comps_path = Path(conf.path).joinpath(app_dir)\n                if comps_path.exists():\n                    app_paths.append(comps_path)\n\n    directories: Set[Path] = set(app_paths)\n\n    # Validate and add other values from the config\n    for component_dir in component_dirs:\n        # Consider tuples for STATICFILES_DIRS (See #489)\n        # See https://docs.djangoproject.com/en/5.0/ref/settings/#prefixes-optional\n        if isinstance(component_dir, (tuple, list)):\n            component_dir = component_dir[1]\n        try:\n            Path(component_dir)\n        except TypeError:\n            logger.warning(\n                f\"{source} expected str, bytes or os.PathLike object, or tuple/list of length 2. \"\n                f\"See Django documentation for STATICFILES_DIRS. Got {type(component_dir)} : {component_dir}\"\n            )\n            continue\n\n        if not Path(component_dir).is_absolute():\n            raise ValueError(f\"{source} must contain absolute paths, got '{component_dir}'\")\n        else:\n            directories.add(Path(component_dir).resolve())\n\n    logger.debug(\n        \"get_component_dirs matched following template dirs:\\n\" + \"\\n\".join([f\" - {str(d)}\" for d in directories])\n    )\n    return list(directories)\n</code></pre>"},{"location":"reference/django_components/#django_components.util.loader.get_component_files","title":"get_component_files","text":"<pre><code>get_component_files(suffix: Optional[str] = None) -&gt; List[ComponentFileEntry]\n</code></pre> <p>Search for files within the component directories (as defined in <code>get_component_dirs()</code>).</p> <p>Requires <code>BASE_DIR</code> setting to be set.</p> <p>Parameters:</p> <ul> <li> <code>suffix</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The suffix to search for. E.g. <code>.py</code>, <code>.js</code>, <code>.css</code>.            Defaults to <code>None</code>, which will search for all files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[ComponentFileEntry]</code>           \u2013            <p>List[ComponentFileEntry] A list of entries that contain both the filesystem path and             the python import path (dot path).</p> </li> </ul> <p>Example:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre> Source code in <code>src/django_components/util/loader.py</code> <pre><code>def get_component_files(suffix: Optional[str] = None) -&gt; List[ComponentFileEntry]:\n    \"\"\"\n    Search for files within the component directories (as defined in\n    [`get_component_dirs()`](../api#django_components.get_component_dirs)).\n\n    Requires `BASE_DIR` setting to be set.\n\n    Args:\n        suffix (Optional[str], optional): The suffix to search for. E.g. `.py`, `.js`, `.css`.\\\n            Defaults to `None`, which will search for all files.\n\n    Returns:\n        List[ComponentFileEntry] A list of entries that contain both the filesystem path and \\\n            the python import path (dot path).\n\n    **Example:**\n\n    ```python\n    from django_components import get_component_files\n\n    modules = get_component_files(\".py\")\n    ```\n    \"\"\"\n    search_glob = f\"**/*{suffix}\" if suffix else \"**/*\"\n\n    dirs = get_component_dirs(include_apps=False)\n    component_filepaths = _search_dirs(dirs, search_glob)\n\n    if hasattr(settings, \"BASE_DIR\") and settings.BASE_DIR:\n        project_root = str(settings.BASE_DIR)\n    else:\n        # Fallback for getting the root dir, see https://stackoverflow.com/a/16413955/9788634\n        project_root = os.path.abspath(os.path.dirname(__name__))\n\n    # NOTE: We handle dirs from `COMPONENTS.dirs` and from individual apps separately.\n    modules: List[ComponentFileEntry] = []\n\n    # First let's handle the dirs from `COMPONENTS.dirs`\n    #\n    # Because for dirs in `COMPONENTS.dirs`, we assume they will be nested under `BASE_DIR`,\n    # and that `BASE_DIR` is the current working dir (CWD). So the path relatively to `BASE_DIR`\n    # is ALSO the python import path.\n    for filepath in component_filepaths:\n        module_path = _filepath_to_python_module(filepath, project_root, None)\n        # Ignore files starting with dot `.` or files in dirs that start with dot.\n        #\n        # If any of the parts of the path start with a dot, e.g. the filesystem path\n        # is `./abc/.def`, then this gets converted to python module as `abc..def`\n        #\n        # NOTE: This approach also ignores files:\n        #   - with two dots in the middle (ab..cd.py)\n        #   - an extra dot at the end (abcd..py)\n        #   - files outside of the parent component (../abcd.py).\n        # But all these are NOT valid python modules so that's fine.\n        if \"..\" in module_path:\n            continue\n\n        entry = ComponentFileEntry(dot_path=module_path, filepath=filepath)\n        modules.append(entry)\n\n    # For for apps, the directories may be outside of the project, e.g. in case of third party\n    # apps. So we have to resolve the python import path relative to the package name / the root\n    # import path for the app.\n    # See https://github.com/EmilStenstrom/django-components/issues/669\n    for conf in apps.get_app_configs():\n        for app_dir in app_settings.APP_DIRS:\n            comps_path = Path(conf.path).joinpath(app_dir)\n            if not comps_path.exists():\n                continue\n            app_component_filepaths = _search_dirs([comps_path], search_glob)\n            for filepath in app_component_filepaths:\n                app_component_module = _filepath_to_python_module(filepath, conf.path, conf.name)\n                entry = ComponentFileEntry(dot_path=app_component_module, filepath=filepath)\n                modules.append(entry)\n\n    return modules\n</code></pre>"},{"location":"reference/django_components/#django_components.util.logger","title":"logger","text":"<p>Functions:</p> <ul> <li> <code>trace</code>             \u2013              <p>TRACE level logger.</p> </li> <li> <code>trace_msg</code>             \u2013              <p>TRACE level logger with opinionated format for tracing interaction of components,</p> </li> </ul>"},{"location":"reference/django_components/#django_components.util.logger.trace","title":"trace","text":"<pre><code>trace(logger: Logger, message: str, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>TRACE level logger.</p> <p>To display TRACE logs, set the logging level to 5.</p> <p>Example: <pre><code>LOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": sys.stdout,\n        },\n    },\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": 5,\n            \"handlers\": [\"console\"],\n        },\n    },\n}\n</code></pre></p> Source code in <code>src/django_components/util/logger.py</code> <pre><code>def trace(logger: logging.Logger, message: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    TRACE level logger.\n\n    To display TRACE logs, set the logging level to 5.\n\n    Example:\n    ```py\n    LOGGING = {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"handlers\": {\n            \"console\": {\n                \"class\": \"logging.StreamHandler\",\n                \"stream\": sys.stdout,\n            },\n        },\n        \"loggers\": {\n            \"django_components\": {\n                \"level\": 5,\n                \"handlers\": [\"console\"],\n            },\n        },\n    }\n    ```\n    \"\"\"\n    if actual_trace_level_num == -1:\n        setup_logging()\n    if logger.isEnabledFor(actual_trace_level_num):\n        logger.log(actual_trace_level_num, message, *args, **kwargs)\n</code></pre>"},{"location":"reference/django_components/#django_components.util.logger.trace_msg","title":"trace_msg","text":"<pre><code>trace_msg(\n    action: Literal[\"PARSE\", \"RENDR\", \"GET\", \"SET\"],\n    node_type: Literal[\"COMP\", \"FILL\", \"SLOT\", \"PROVIDE\", \"N/A\"],\n    node_name: str,\n    node_id: str,\n    msg: str = \"\",\n    component_id: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>TRACE level logger with opinionated format for tracing interaction of components, nodes, and slots. Formats messages like so:</p> <p><code>\"ASSOC SLOT test_slot ID 0088 TO COMP 0087\"</code></p> Source code in <code>src/django_components/util/logger.py</code> <pre><code>def trace_msg(\n    action: Literal[\"PARSE\", \"RENDR\", \"GET\", \"SET\"],\n    node_type: Literal[\"COMP\", \"FILL\", \"SLOT\", \"PROVIDE\", \"N/A\"],\n    node_name: str,\n    node_id: str,\n    msg: str = \"\",\n    component_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    TRACE level logger with opinionated format for tracing interaction of components,\n    nodes, and slots. Formats messages like so:\n\n    `\"ASSOC SLOT test_slot ID 0088 TO COMP 0087\"`\n    \"\"\"\n    msg_prefix = \"\"\n    if action == \"RENDR\" and node_type == \"FILL\":\n        if not component_id:\n            raise ValueError(\"component_id must be set for the RENDER action\")\n        msg_prefix = f\"FOR COMP {component_id}\"\n\n    msg_parts = [f\"{action} {node_type} {node_name} ID {node_id}\", *([msg_prefix] if msg_prefix else []), msg]\n    full_msg = \" \".join(msg_parts)\n\n    # NOTE: When debugging tests during development, it may be easier to change\n    # this to `print()`\n    trace(logger, full_msg)\n</code></pre>"},{"location":"reference/django_components/#django_components.util.misc","title":"misc","text":"<p>Functions:</p> <ul> <li> <code>gen_id</code>             \u2013              <p>Generate a unique ID that can be associated with a Node</p> </li> <li> <code>get_import_path</code>             \u2013              <p>Get the full import path for a class or a function, e.g. <code>\"path.to.MyClass\"</code></p> </li> </ul>"},{"location":"reference/django_components/#django_components.util.misc.gen_id","title":"gen_id","text":"<pre><code>gen_id() -&gt; str\n</code></pre> <p>Generate a unique ID that can be associated with a Node</p> Source code in <code>src/django_components/util/misc.py</code> <pre><code>def gen_id() -&gt; str:\n    \"\"\"Generate a unique ID that can be associated with a Node\"\"\"\n    # Alphabet is only alphanumeric. Compared to the default alphabet used by nanoid,\n    # we've omitted `-` and `_`.\n    # With this alphabet, at 6 chars, the chance of collision is 1 in 3.3M.\n    # See https://zelark.github.io/nano-id-cc/\n    return generate(\n        \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n        size=6,\n    )\n</code></pre>"},{"location":"reference/django_components/#django_components.util.misc.get_import_path","title":"get_import_path","text":"<pre><code>get_import_path(cls_or_fn: Type[Any]) -&gt; str\n</code></pre> <p>Get the full import path for a class or a function, e.g. <code>\"path.to.MyClass\"</code></p> Source code in <code>src/django_components/util/misc.py</code> <pre><code>def get_import_path(cls_or_fn: Type[Any]) -&gt; str:\n    \"\"\"\n    Get the full import path for a class or a function, e.g. `\"path.to.MyClass\"`\n    \"\"\"\n    module = cls_or_fn.__module__\n    if module == \"builtins\":\n        return cls_or_fn.__qualname__  # avoid outputs like 'builtins.str'\n    return module + \".\" + cls_or_fn.__qualname__\n</code></pre>"},{"location":"reference/django_components/#django_components.util.tag_parser","title":"tag_parser","text":"<p>Classes:</p> <ul> <li> <code>TagAttr</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/#django_components.util.tag_parser.TagAttr","title":"TagAttr  <code>dataclass</code>","text":"<pre><code>TagAttr(key: Optional[str], value: str, start_index: int, quoted: bool)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>quoted</code>               (<code>bool</code>)           \u2013            <p>Whether the value is quoted (either with single or double quotes)</p> </li> <li> <code>start_index</code>               (<code>int</code>)           \u2013            <p>Start index of the attribute (include both key and value),</p> </li> </ul>"},{"location":"reference/django_components/#django_components.util.tag_parser.TagAttr.quoted","title":"quoted  <code>instance-attribute</code>","text":"<pre><code>quoted: bool\n</code></pre> <p>Whether the value is quoted (either with single or double quotes)</p>"},{"location":"reference/django_components/#django_components.util.tag_parser.TagAttr.start_index","title":"start_index  <code>instance-attribute</code>","text":"<pre><code>start_index: int\n</code></pre> <p>Start index of the attribute (include both key and value), relative to the start of the owner Tag.</p>"},{"location":"reference/django_components/#django_components.util.types","title":"types","text":"<p>Classes:</p> <ul> <li> <code>EmptyDict</code>           \u2013            <p>TypedDict with no members.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>EmptyTuple</code>           \u2013            <p>Tuple with no members.</p> </li> </ul>"},{"location":"reference/django_components/#django_components.util.types.EmptyTuple","title":"EmptyTuple  <code>module-attribute</code>","text":"<pre><code>EmptyTuple = Tuple[]\n</code></pre> <p>Tuple with no members.</p> <p>You can use this to define a Component that accepts NO positional arguments:</p> <pre><code>from django_components import Component, EmptyTuple\n\nclass Table(Component(EmptyTuple, Any, Any, Any, Any, Any))\n    ...\n</code></pre> <p>After that, when you call <code>Component.render()</code> or <code>Component.render_to_response()</code>, the <code>args</code> parameter will raise type error if <code>args</code> is anything else than an empty tuple.</p> <pre><code>Table.render(\n    args: (),\n)\n</code></pre> <p>Omitting <code>args</code> is also fine:</p> <pre><code>Table.render()\n</code></pre> <p>Other values are not allowed. This will raise an error with MyPy:</p> <pre><code>Table.render(\n    args: (\"one\", 2, \"three\"),\n)\n</code></pre>"},{"location":"reference/django_components/#django_components.util.types.EmptyDict","title":"EmptyDict","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict with no members.</p> <p>You can use this to define a Component that accepts NO kwargs, or NO slots, or returns NO data from <code>Component.get_context_data()</code> / <code>Component.get_js_data()</code> / <code>Component.get_css_data()</code>:</p> <p>Accepts NO kwargs:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, EmptyDict, Any, Any, Any, Any))\n    ...\n</code></pre> <p>Accepts NO slots:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, Any, EmptyDict, Any, Any, Any))\n    ...\n</code></pre> <p>Returns NO data from <code>get_context_data()</code>:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, Any, Any, EmptyDict, Any, Any))\n    ...\n</code></pre> <p>Going back to the example with NO kwargs, when you then call <code>Component.render()</code> or <code>Component.render_to_response()</code>, the <code>kwargs</code> parameter will raise type error if <code>kwargs</code> is anything else than an empty dict.</p> <pre><code>Table.render(\n    kwargs: {},\n)\n</code></pre> <p>Omitting <code>kwargs</code> is also fine:</p> <pre><code>Table.render()\n</code></pre> <p>Other values are not allowed. This will raise an error with MyPy:</p> <pre><code>Table.render(\n    kwargs: {\n        \"one\": 2,\n        \"three\": 4,\n    },\n)\n</code></pre>"},{"location":"reference/django_components/app_settings/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> app_settings","text":""},{"location":"reference/django_components/app_settings/#django_components.app_settings","title":"app_settings","text":"<p>Classes:</p> <ul> <li> <code>ComponentsSettings</code>           \u2013            <p>Settings available for django_components.</p> </li> <li> <code>ContextBehavior</code>           \u2013            <p>Configure how (and whether) the context is passed to the component fills</p> </li> </ul>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings","title":"ComponentsSettings","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Settings available for django_components.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n    dirs = [BASE_DIR / \"components\"],\n)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>app_dirs</code>               (<code>Optional[Sequence[str]]</code>)           \u2013            <p>Specify the app-level directories that contain your components.</p> </li> <li> <code>autodiscover</code>               (<code>Optional[bool]</code>)           \u2013            <p>Toggle whether to run autodiscovery at the Django server startup.</p> </li> <li> <code>context_behavior</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            <p>Configure whether, inside a component template, you can use variables from the outside</p> </li> <li> <code>dirs</code>               (<code>Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]]</code>)           \u2013            <p>Specify the directories that contain your components.</p> </li> <li> <code>dynamic_component_name</code>               (<code>Optional[str]</code>)           \u2013            <p>By default, the dynamic component</p> </li> <li> <code>forbidden_static_files</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            <p>Deprecated. Use</p> </li> <li> <code>libraries</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Configure extra python modules that should be loaded.</p> </li> <li> <code>multiline_tags</code>               (<code>Optional[bool]</code>)           \u2013            <p>Enable / disable</p> </li> <li> <code>reload_on_file_change</code>               (<code>Optional[bool]</code>)           \u2013            <p>This is relevant if you are using the project structure where</p> </li> <li> <code>reload_on_template_change</code>               (<code>Optional[bool]</code>)           \u2013            <p>Deprecated. Use</p> </li> <li> <code>static_files_allowed</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            <p>A list of file extensions (including the leading dot) that define which files within</p> </li> <li> <code>static_files_forbidden</code>               (<code>Optional[List[Union[str, Pattern]]]</code>)           \u2013            <p>A list of file extensions (including the leading dot) that define which files within</p> </li> <li> <code>tag_formatter</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            <p>Configure what syntax is used inside Django templates to render components.</p> </li> <li> <code>template_cache_size</code>               (<code>Optional[int]</code>)           \u2013            <p>Configure the maximum amount of Django templates to be cached.</p> </li> </ul>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.app_dirs","title":"app_dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>app_dirs: Optional[Sequence[str]] = None\n</code></pre> <p>Specify the app-level directories that contain your components.</p> <p>Defaults to <code>[\"components\"]</code>. That is, for each Django app, we search <code>&lt;app&gt;/components/</code> for components.</p> <p>The paths must be relative to app, e.g.:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[\"my_comps\"],\n)\n</code></pre> <p>To search for <code>&lt;app&gt;/my_comps/</code>.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <p>Set to empty list to disable app-level components:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    app_dirs=[],\n)\n</code></pre>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.autodiscover","title":"autodiscover  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>autodiscover: Optional[bool] = None\n</code></pre> <p>Toggle whether to run autodiscovery at the Django server startup.</p> <p>Defaults to <code>True</code></p> <pre><code>COMPONENTS = ComponentsSettings(\n    autodiscover=False,\n)\n</code></pre>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.context_behavior","title":"context_behavior  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>Configure whether, inside a component template, you can use variables from the outside (<code>\"django\"</code>) or not (<code>\"isolated\"</code>). This also affects what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Defaults to <code>\"django\"</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    context_behavior=\"isolated\",\n)\n</code></pre> <p>NOTE: <code>context_behavior</code> and <code>slot_context_behavior</code> options were merged in v0.70.</p> <p>If you are migrating from BEFORE v0.67, set <code>context_behavior</code> to <code>\"django\"</code>. From v0.67 to v0.78 (incl) the default value was <code>\"isolated\"</code>.</p> <p>For v0.79 and later, the default is again <code>\"django\"</code>. See the rationale for change here.</p>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.dirs","title":"dirs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dirs: Optional[Sequence[Union[str, PathLike, Tuple[str, str], Tuple[str, PathLike]]]] = None\n</code></pre> <p>Specify the directories that contain your components.</p> <p>Defaults to <code>[Path(settings.BASE_DIR) / \"components\"]</code>. That is, the root <code>components/</code> app.</p> <p>Directories must be full paths, same as with STATICFILES_DIRS.</p> <p>These locations are searched during autodiscovery, or when you define HTML, JS, or CSS as separate files.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[BASE_DIR / \"components\"],\n)\n</code></pre> <p>Set to empty list to disable global components directories:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    dirs=[],\n)\n</code></pre>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.dynamic_component_name","title":"dynamic_component_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dynamic_component_name: Optional[str] = None\n</code></pre> <p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>.</p> <p>In case of a conflict, you can use this setting to change the component name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name:</p> <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.forbidden_static_files","title":"forbidden_static_files  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>forbidden_static_files: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>Deprecated. Use <code>COMPONENTS.static_files_forbidden</code> instead.</p>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.libraries","title":"libraries  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>libraries: Optional[List[str]] = None\n</code></pre> <p>Configure extra python modules that should be loaded.</p> <p>This may be useful if you are not using the autodiscovery feature, or you need to load components from non-standard locations. Thus you can have a structure of components that is independent from your apps.</p> <p>Expects a list of python module paths. Defaults to empty list.</p> <p>Example:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    libraries=[\n        \"mysite.components.forms\",\n        \"mysite.components.buttons\",\n        \"mysite.components.cards\",\n    ],\n)\n</code></pre> <p>This would be the equivalent of importing these modules from within Django's <code>AppConfig.ready()</code>:</p> <pre><code>class MyAppConfig(AppConfig):\n    def ready(self):\n        import \"mysite.components.forms\"\n        import \"mysite.components.buttons\"\n        import \"mysite.components.cards\"\n</code></pre>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.libraries--manually-loading-libraries","title":"Manually loading libraries","text":"<p>In the rare case that you need to manually trigger the import of libraries, you can use the <code>import_libraries()</code> function:</p> <pre><code>from django_components import import_libraries\n\nimport_libraries()\n</code></pre>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.multiline_tags","title":"multiline_tags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>multiline_tags: Optional[bool] = None\n</code></pre> <p>Enable / disable multiline support for template tags. If <code>True</code>, template tags like <code>{% component %}</code> or <code>{{ my_var }}</code> can span multiple lines.</p> <p>Defaults to <code>True</code>.</p> <p>Disable this setting if you are making custom modifications to Django's regular expression for parsing templates at <code>django.template.base.tag_re</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    multiline_tags=False,\n)\n</code></pre>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.reload_on_file_change","title":"reload_on_file_change  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reload_on_file_change: Optional[bool] = None\n</code></pre> <p>This is relevant if you are using the project structure where HTML, JS, CSS and Python are in separate files and nested in a directory.</p> <p>In this case you may notice that when you are running a development server, the server sometimes does not reload when you change component files.</p> <p>Django's native live reload logic handles only Python files and HTML template files. It does NOT reload when other file types change or when template files are nested more than one level deep.</p> <p>The setting <code>reload_on_file_change</code> fixes this, reloading the dev server even when your component's HTML, JS, or CSS changes.</p> <p>If <code>True</code>, django_components configures Django to reload when files inside <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> change.</p> <p>See Reload dev server on component file changes.</p> <p>Defaults to <code>False</code>.</p> <p>Warning</p> <p>This setting should be enabled only for the dev environment!</p>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.reload_on_template_change","title":"reload_on_template_change  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reload_on_template_change: Optional[bool] = None\n</code></pre> <p>Deprecated. Use <code>COMPONENTS.reload_on_file_change</code> instead.</p>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.static_files_allowed","title":"static_files_allowed  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>static_files_allowed: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> are treated as static files.</p> <p>If a file is matched against any of the patterns, it's considered a static file. Such files are collected when running <code>collectstatic</code>, and can be accessed under the static file endpoint.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, JS, CSS, and common image and font file formats are considered static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_allowed=[\n        \".css\",\n        \".js\", \".jsx\", \".ts\", \".tsx\",\n        # Images\n        \".apng\", \".png\", \".avif\", \".gif\", \".jpg\",\n        \".jpeg\",  \".jfif\", \".pjpeg\", \".pjp\", \".svg\",\n        \".webp\", \".bmp\", \".ico\", \".cur\", \".tif\", \".tiff\",\n        # Fonts\n        \".eot\", \".ttf\", \".woff\", \".otf\", \".svg\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.static_files_forbidden","title":"static_files_forbidden  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>static_files_forbidden: Optional[List[Union[str, Pattern]]] = None\n</code></pre> <p>A list of file extensions (including the leading dot) that define which files within <code>COMPONENTS.dirs</code> or <code>COMPONENTS.app_dirs</code> will NEVER be treated as static files.</p> <p>If a file is matched against any of the patterns, it will never be considered a static file, even if the file matches a pattern in <code>static_files_allowed</code>.</p> <p>Use this setting together with <code>static_files_allowed</code> for a fine control over what file types will be exposed.</p> <p>You can also pass in compiled regexes (<code>re.Pattern</code>) for more advanced patterns.</p> <p>By default, any HTML and Python are considered NOT static files:</p> <pre><code>COMPONENTS = ComponentsSettings(\n    static_files_forbidden=[\n        \".html\", \".django\", \".dj\", \".tpl\",\n        # Python files\n        \".py\", \".pyc\",\n    ],\n)\n</code></pre> <p>Warning</p> <p>Exposing your Python files can be a security vulnerability. See Security notes.</p>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.tag_formatter","title":"tag_formatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>Configure what syntax is used inside Django templates to render components. See the available tag formatters.</p> <p>Defaults to <code>\"django_components.component_formatter\"</code>.</p> <p>Learn more about Customizing component tags with TagFormatter.</p> <p>Can be set either as direct reference:</p> <pre><code>from django_components import component_formatter\n\nCOMPONENTS = ComponentsSettings(\n    \"tag_formatter\": component_formatter\n)\n</code></pre> <p>Or as an import string;</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>Examples:</p> <ul> <li> <p><code>\"django_components.component_formatter\"</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% component \"button\" href=\"...\" %}\n    Click me!\n{% endcomponent %}\n</code></pre> </li> <li> <p><code>django_components.component_shorthand_formatter</code></p> <p>Set</p> <pre><code>COMPONENTS = ComponentsSettings(\n    \"tag_formatter\": \"django_components.component_shorthand_formatter\"\n)\n</code></pre> <p>To write components like this:</p> <pre><code>{% button href=\"...\" %}\n    Click me!\n{% endbutton %}\n</code></pre> </li> </ul>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ComponentsSettings.template_cache_size","title":"template_cache_size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_cache_size: Optional[int] = None\n</code></pre> <p>Configure the maximum amount of Django templates to be cached.</p> <p>Defaults to <code>128</code>.</p> <p>Each time a Django template is rendered, it is cached to a global in-memory cache (using Python's <code>lru_cache</code> decorator). This speeds up the next render of the component. As the same component is often used many times on the same page, these savings add up.</p> <p>By default the cache holds 128 component templates in memory, which should be enough for most sites. But if you have a lot of components, or if you are overriding <code>Component.get_template()</code> to render many dynamic templates, you can increase this number.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=256,\n)\n</code></pre> <p>To remove the cache limit altogether and cache everything, set <code>template_cache_size</code> to <code>None</code>.</p> <pre><code>COMPONENTS = ComponentsSettings(\n    template_cache_size=None,\n)\n</code></pre> <p>If you want to add templates to the cache yourself, you can use <code>cached_template()</code>:</p> <pre><code>from django_components import cached_template\n\ncached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ncached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ContextBehavior","title":"ContextBehavior","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Configure how (and whether) the context is passed to the component fills and what variables are available inside the <code>{% fill %}</code> tags.</p> <p>Also see Component context and scope.</p> <p>Options:</p> <ul> <li><code>django</code>: With this setting, component fills behave as usual Django tags.</li> <li><code>isolated</code>: This setting makes the component fills behave similar to Vue or React.</li> </ul> <p>Attributes:</p> <ul> <li> <code>DJANGO</code>           \u2013            <p>With this setting, component fills behave as usual Django tags.</p> </li> <li> <code>ISOLATED</code>           \u2013            <p>This setting makes the component fills behave similar to Vue or React, where</p> </li> </ul>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ContextBehavior.DJANGO","title":"DJANGO  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>DJANGO = 'django'\n</code></pre> <p>With this setting, component fills behave as usual Django tags. That is, they enrich the context, and pass it along.</p> <ol> <li>Component fills use the context of the component they are within.</li> <li>Variables from <code>Component.get_context_data()</code> are available to the component fill.</li> </ol> <p>Example:</p> <p>Given this template <pre><code>{% with cheese=\"feta\" %}\n  {% component 'my_comp' %}\n    {{ my_var }}  # my_var\n    {{ cheese }}  # cheese\n  {% endcomponent %}\n{% endwith %}\n</code></pre></p> <p>and this context returned from the <code>Component.get_context_data()</code> method <pre><code>{ \"my_var\": 123 }\n</code></pre></p> <p>Then if component \"my_comp\" defines context <pre><code>{ \"my_var\": 456 }\n</code></pre></p> <p>Then this will render: <pre><code>456   # my_var\nfeta  # cheese\n</code></pre></p> <p>Because \"my_comp\" overrides the variable \"my_var\", so <code>{{ my_var }}</code> equals <code>456</code>.</p> <p>And variable \"cheese\" will equal <code>feta</code>, because the fill CAN access the current context.</p>"},{"location":"reference/django_components/app_settings/#django_components.app_settings.ContextBehavior.ISOLATED","title":"ISOLATED  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ISOLATED = 'isolated'\n</code></pre> <p>This setting makes the component fills behave similar to Vue or React, where the fills use EXCLUSIVELY the context variables defined in <code>Component.get_context_data()</code>.</p> <p>Example:</p> <p>Given this template <pre><code>{% with cheese=\"feta\" %}\n  {% component 'my_comp' %}\n    {{ my_var }}  # my_var\n    {{ cheese }}  # cheese\n  {% endcomponent %}\n{% endwith %}\n</code></pre></p> <p>and this context returned from the <code>get_context_data()</code> method <pre><code>{ \"my_var\": 123 }\n</code></pre></p> <p>Then if component \"my_comp\" defines context <pre><code>{ \"my_var\": 456 }\n</code></pre></p> <p>Then this will render: <pre><code>123   # my_var\n      # cheese\n</code></pre></p> <p>Because both variables \"my_var\" and \"cheese\" are taken from the root context. Since \"cheese\" is not defined in root context, it's empty.</p>"},{"location":"reference/django_components/apps/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> apps","text":""},{"location":"reference/django_components/apps/#django_components.apps","title":"apps","text":""},{"location":"reference/django_components/attributes/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> attributes","text":""},{"location":"reference/django_components/attributes/#django_components.attributes","title":"attributes","text":"<p>Functions:</p> <ul> <li> <code>append_attributes</code>             \u2013              <p>Merges the key-value pairs and returns a new dictionary.</p> </li> <li> <code>attributes_to_string</code>             \u2013              <p>Convert a dict of attributes to a string.</p> </li> </ul>"},{"location":"reference/django_components/attributes/#django_components.attributes.append_attributes","title":"append_attributes","text":"<pre><code>append_attributes(*args: Tuple[str, Any]) -&gt; Dict\n</code></pre> <p>Merges the key-value pairs and returns a new dictionary.</p> <p>If a key is present multiple times, its values are concatenated with a space character as separator in the final dictionary.</p> Source code in <code>src/django_components/attributes.py</code> <pre><code>def append_attributes(*args: Tuple[str, Any]) -&gt; Dict:\n    \"\"\"\n    Merges the key-value pairs and returns a new dictionary.\n\n    If a key is present multiple times, its values are concatenated with a space\n    character as separator in the final dictionary.\n    \"\"\"\n    result: Dict = {}\n\n    for key, value in args:\n        if key in result:\n            result[key] += \" \" + value\n        else:\n            result[key] = value\n\n    return result\n</code></pre>"},{"location":"reference/django_components/attributes/#django_components.attributes.attributes_to_string","title":"attributes_to_string","text":"<pre><code>attributes_to_string(attributes: Mapping[str, Any]) -&gt; str\n</code></pre> <p>Convert a dict of attributes to a string.</p> Source code in <code>src/django_components/attributes.py</code> <pre><code>def attributes_to_string(attributes: Mapping[str, Any]) -&gt; str:\n    \"\"\"Convert a dict of attributes to a string.\"\"\"\n    attr_list = []\n\n    for key, value in attributes.items():\n        if value is None or value is False:\n            continue\n        if value is True:\n            attr_list.append(conditional_escape(key))\n        else:\n            attr_list.append(format_html('{}=\"{}\"', key, value))\n\n    return mark_safe(SafeString(\" \").join(attr_list))\n</code></pre>"},{"location":"reference/django_components/autodiscovery/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> autodiscovery","text":""},{"location":"reference/django_components/autodiscovery/#django_components.autodiscovery","title":"autodiscovery","text":"<p>Functions:</p> <ul> <li> <code>autodiscover</code>             \u2013              <p>Search for all python files in</p> </li> <li> <code>import_libraries</code>             \u2013              <p>Import modules set in</p> </li> </ul>"},{"location":"reference/django_components/autodiscovery/#django_components.autodiscovery.autodiscover","title":"autodiscover","text":"<pre><code>autodiscover(map_module: Optional[Callable[[str], str]] = None) -&gt; List[str]\n</code></pre> <p>Search for all python files in <code>COMPONENTS.dirs</code> and <code>COMPONENTS.app_dirs</code> and import them.</p> <p>See Autodiscovery.</p> <p>Parameters:</p> <ul> <li> <code>map_module</code>               (<code>Callable[[str], str]</code>, default:                   <code>None</code> )           \u2013            <p>Map the module paths with <code>map_module</code> function.        This serves as an escape hatch for when you need to use this function in tests.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of module paths of imported files.</p> </li> </ul> <p>To get the same list of modules that <code>autodiscover()</code> would return, but without importing them, use <code>get_component_files()</code>:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre> Source code in <code>src/django_components/autodiscovery.py</code> <pre><code>def autodiscover(\n    map_module: Optional[Callable[[str], str]] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Search for all python files in\n    [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n    and\n    [`COMPONENTS.app_dirs`](../settings#django_components.app_settings.ComponentsSettings.app_dirs)\n    and import them.\n\n    See [Autodiscovery](../../concepts/fundamentals/autodiscovery).\n\n    Args:\n        map_module (Callable[[str], str], optional): Map the module paths with `map_module` function.\\\n        This serves as an escape hatch for when you need to use this function in tests.\n\n    Returns:\n        List[str]: A list of module paths of imported files.\n\n    To get the same list of modules that `autodiscover()` would return, but without importing them, use\n    [`get_component_files()`](../api#django_components.get_component_files):\n\n    ```python\n    from django_components import get_component_files\n\n    modules = get_component_files(\".py\")\n    ```\n    \"\"\"\n    modules = get_component_files(\".py\")\n    logger.debug(f\"Autodiscover found {len(modules)} files in component directories.\")\n    return _import_modules([entry.dot_path for entry in modules], map_module)\n</code></pre>"},{"location":"reference/django_components/autodiscovery/#django_components.autodiscovery.import_libraries","title":"import_libraries","text":"<pre><code>import_libraries(map_module: Optional[Callable[[str], str]] = None) -&gt; List[str]\n</code></pre> <p>Import modules set in <code>COMPONENTS.libraries</code> setting.</p> <p>See Autodiscovery.</p> <p>Parameters:</p> <ul> <li> <code>map_module</code>               (<code>Callable[[str], str]</code>, default:                   <code>None</code> )           \u2013            <p>Map the module paths with <code>map_module</code> function.        This serves as an escape hatch for when you need to use this function in tests.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[str]</code>           \u2013            <p>List[str]: A list of module paths of imported files.</p> </li> </ul> <p>Examples:</p> <p>Normal usage - load libraries after Django has loaded <pre><code>from django_components import import_libraries\n\nclass MyAppConfig(AppConfig):\n    def ready(self):\n        import_libraries()\n</code></pre></p> <p>Potential usage in tests <pre><code>from django_components import import_libraries\n\nimport_libraries(lambda path: path.replace(\"tests.\", \"myapp.\"))\n</code></pre></p> Source code in <code>src/django_components/autodiscovery.py</code> <pre><code>def import_libraries(\n    map_module: Optional[Callable[[str], str]] = None,\n) -&gt; List[str]:\n    \"\"\"\n    Import modules set in\n    [`COMPONENTS.libraries`](../settings#django_components.app_settings.ComponentsSettings.libraries)\n    setting.\n\n    See [Autodiscovery](../../concepts/fundamentals/autodiscovery).\n\n    Args:\n        map_module (Callable[[str], str], optional): Map the module paths with `map_module` function.\\\n        This serves as an escape hatch for when you need to use this function in tests.\n\n    Returns:\n        List[str]: A list of module paths of imported files.\n\n    **Examples:**\n\n    Normal usage - load libraries after Django has loaded\n    ```python\n    from django_components import import_libraries\n\n    class MyAppConfig(AppConfig):\n        def ready(self):\n            import_libraries()\n    ```\n\n    Potential usage in tests\n    ```python\n    from django_components import import_libraries\n\n    import_libraries(lambda path: path.replace(\"tests.\", \"myapp.\"))\n    ```\n    \"\"\"\n    from django_components.app_settings import app_settings\n\n    return _import_modules(app_settings.LIBRARIES, map_module)\n</code></pre>"},{"location":"reference/django_components/component/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> component","text":""},{"location":"reference/django_components/component/#django_components.component","title":"component","text":"<p>Classes:</p> <ul> <li> <code>Component</code>           \u2013            </li> <li> <code>ComponentNode</code>           \u2013            <p>Django.template.Node subclass that renders a django-components component</p> </li> <li> <code>ComponentVars</code>           \u2013            <p>Type for the variables available inside the component templates.</p> </li> <li> <code>ComponentView</code>           \u2013            <p>Subclass of <code>django.views.View</code> where the <code>Component</code> instance is available</p> </li> </ul>"},{"location":"reference/django_components/component/#django_components.component.Component","title":"Component","text":"<pre><code>Component(\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,\n)\n</code></pre> <p>               Bases: <code>Generic[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]</code></p> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> </li> <li> <code>get_template</code>             \u2013              <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>get_template_name</code>             \u2013              <p>Filepath to the Django template associated with this component.</p> </li> <li> <code>inject</code>             \u2013              <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag</p> </li> <li> <code>on_render_after</code>             \u2013              <p>Hook that runs just after the component's template was rendered.</p> </li> <li> <code>on_render_before</code>             \u2013              <p>Hook that runs just before the component's template is rendered.</p> </li> <li> <code>render</code>             \u2013              <p>Render the component into a string.</p> </li> <li> <code>render_to_response</code>             \u2013              <p>Render the component and wrap the content in the response class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Media</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined CSS associated with this component.</p> </li> <li> <code>input</code>               (<code>RenderInput[ArgsType, KwargsType, SlotsType]</code>)           \u2013            <p>Input holds the data (like arg, kwargs, slots) that were passsed to</p> </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            <p>Dictionary describing which slots have or have not been filled.</p> </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined JS associated with this component.</p> </li> <li> <code>media</code>               (<code>Media</code>)           \u2013            <p>Normalized definition of JS and CSS media files associated with this component.</p> </li> <li> <code>response_class</code>           \u2013            <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p> </li> <li> <code>template</code>               (<code>Optional[Union[str, Template]]</code>)           \u2013            <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Filepath to the Django template associated with this component.</p> </li> </ul> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,  # noqa F811\n):\n    # When user first instantiates the component class before calling\n    # `render` or `render_to_response`, then we want to allow the render\n    # function to make use of the instantiated object.\n    #\n    # So while `MyComp.render()` creates a new instance of MyComp internally,\n    # if we do `MyComp(registered_name=\"abc\").render()`, then we use the\n    # already-instantiated object.\n    #\n    # To achieve that, we want to re-assign the class methods as instance methods.\n    # For that we have to \"unwrap\" the class methods via __func__.\n    # See https://stackoverflow.com/a/76706399/9788634\n    self.render_to_response = types.MethodType(self.__class__.render_to_response.__func__, self)  # type: ignore\n    self.render = types.MethodType(self.__class__.render.__func__, self)  # type: ignore\n    self.as_view = types.MethodType(self.__class__.as_view.__func__, self)  # type: ignore\n\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.component_id = component_id or gen_id()\n    self.registry = registry or registry_\n    self._render_stack: Deque[RenderStackItem[ArgsType, KwargsType, SlotsType]] = deque()\n    # None == uninitialized, False == No types, Tuple == types\n    self._types: Optional[Union[Tuple[Any, Any, Any, Any, Any, Any], Literal[False]]] = None\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.Media","title":"Media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Media = ComponentMediaInput\n</code></pre> <p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/component/#django_components.component.Component.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>Inlined CSS associated with this component.</p>"},{"location":"reference/django_components/component/#django_components.component.Component.input","title":"input  <code>property</code>","text":"<pre><code>input: RenderInput[ArgsType, KwargsType, SlotsType]\n</code></pre> <p>Input holds the data (like arg, kwargs, slots) that were passsed to the current execution of the <code>render</code> method.</p>"},{"location":"reference/django_components/component/#django_components.component.Component.is_filled","title":"is_filled  <code>property</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within the template as <code>{{ component_vars.is_filled.slot_name }}</code>, and within <code>on_render_before</code> and <code>on_render_after</code> hooks.</p>"},{"location":"reference/django_components/component/#django_components.component.Component.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>Inlined JS associated with this component.</p>"},{"location":"reference/django_components/component/#django_components.component.Component.media","title":"media  <code>instance-attribute</code>","text":"<pre><code>media: Media\n</code></pre> <p>Normalized definition of JS and CSS media files associated with this component.</p> <p>NOTE: This field is generated from Component.Media class.</p>"},{"location":"reference/django_components/component/#django_components.component.Component.response_class","title":"response_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>response_class = HttpResponse\n</code></pre> <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p>"},{"location":"reference/django_components/component/#django_components.component.Component.template","title":"template  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template: Optional[Union[str, Template]] = None\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/component/#django_components.component.Component.template_name","title":"template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = None\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/component/#django_components.component.Component.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef as_view(cls, **initkwargs: Any) -&gt; ViewFn:\n    \"\"\"\n    Shortcut for calling `Component.View.as_view` and passing component instance to it.\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    # Allow the View class to access this component via `self.component`\n    return comp.View.as_view(**initkwargs, component=comp)\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template(self, context: Context) -&gt; Optional[Union[str, Template]]:\n    \"\"\"\n    Inlined Django template associated with this component. Can be a plain string or a Template instance.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template_name(self, context: Context) -&gt; Optional[str]:\n    \"\"\"\n    Filepath to the Django template associated with this component.\n\n    The filepath must be relative to either the file where the component class was defined,\n    or one of the roots of `STATIFILES_DIRS`.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>provide</code> tag with given key was NOT found.</p> <p>This method mut be used inside the <code>get_context_data()</code> method and raises an error if called elsewhere.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"provider\" hello=\"world\" %}\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ data.hello }}!\"\n    def get_context_data(self):\n        data = self.inject(\"provider\")\n        return {\"data\": data}\n</code></pre></p> <p>This renders into: <pre><code>hi world!\n</code></pre></p> <p>As the <code>{{ data.hello }}</code> is taken from the \"provider\".</p> Source code in <code>src/django_components/component.py</code> <pre><code>def inject(self, key: str, default: Optional[Any] = None) -&gt; Any:\n    \"\"\"\n    Use this method to retrieve the data that was passed to a `{% provide %}` tag\n    with the corresponding key.\n\n    To retrieve the data, `inject()` must be called inside a component that's\n    inside the `{% provide %}` tag.\n\n    You may also pass a default that will be used if the `provide` tag with given\n    key was NOT found.\n\n    This method mut be used inside the `get_context_data()` method and raises\n    an error if called elsewhere.\n\n    Example:\n\n    Given this template:\n    ```django\n    {% provide \"provider\" hello=\"world\" %}\n        {% component \"my_comp\" %}\n        {% endcomponent %}\n    {% endprovide %}\n    ```\n\n    And given this definition of \"my_comp\" component:\n    ```py\n    from django_components import Component, register\n\n    @register(\"my_comp\")\n    class MyComp(Component):\n        template = \"hi {{ data.hello }}!\"\n        def get_context_data(self):\n            data = self.inject(\"provider\")\n            return {\"data\": data}\n    ```\n\n    This renders into:\n    ```\n    hi world!\n    ```\n\n    As the `{{ data.hello }}` is taken from the \"provider\".\n    \"\"\"\n    if self.input is None:\n        raise RuntimeError(\n            f\"Method 'inject()' of component '{self.name}' was called outside of 'get_context_data()'\"\n        )\n\n    return get_injected_context_var(self.name, self.input.context, key, default)\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Template, content: str) -&gt; Optional[SlotResult]\n</code></pre> <p>Hook that runs just after the component's template was rendered. It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_after(self, context: Context, template: Template, content: str) -&gt; Optional[SlotResult]:\n    \"\"\"\n    Hook that runs just after the component's template was rendered.\n    It receives the rendered output as the last argument.\n\n    You can use this hook to access the context or the template, but modifying\n    them won't have any effect.\n\n    To override the content that gets rendered, you can return a string or SafeString\n    from this hook.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Template) -&gt; None\n</code></pre> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_before(self, context: Context, template: Template) -&gt; None:\n    \"\"\"\n    Hook that runs just before the component's template is rendered.\n\n    You can use this hook to access or modify the context or the template.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str\n</code></pre> <p>Render the component into a string.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag. - <code>render_dependencies</code> - Set this to <code>False</code> if you want to insert the resulting HTML into another component.</p> <p>Example: <pre><code>MyComponent.render(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str:\n    \"\"\"\n    Render the component into a string.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n    - `render_dependencies` - Set this to `False` if you want to insert the resulting HTML into another component.\n\n    Example:\n    ```py\n    MyComponent.render(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n    )\n    ```\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    return comp._render(context, args, kwargs, slots, escape_slots_content, type, render_dependencies)\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.Component.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and wrap the content in the response class.</p> <p>The response class is taken from <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <p>This is the interface for the <code>django.views.View</code> class which allows us to use components as Django views with <code>component.as_view()</code>.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag.</p> <p>Any additional args and kwargs are passed to the <code>response_class</code>.</p> <p>Example: <pre><code>MyComponent.render_to_response(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n    # HttpResponse input\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render_to_response(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"\n    Render the component and wrap the content in the response class.\n\n    The response class is taken from `Component.response_class`. Defaults to `django.http.HttpResponse`.\n\n    This is the interface for the `django.views.View` class which allows us to\n    use components as Django views with `component.as_view()`.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n\n    Any additional args and kwargs are passed to the `response_class`.\n\n    Example:\n    ```py\n    MyComponent.render_to_response(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n        # HttpResponse input\n        status=201,\n        headers={...},\n    )\n    # HttpResponse(content=..., status=201, headers=...)\n    ```\n    \"\"\"\n    content = cls.render(\n        args=args,\n        kwargs=kwargs,\n        context=context,\n        slots=slots,\n        escape_slots_content=escape_slots_content,\n        type=type,\n        render_dependencies=True,\n    )\n    return cls.response_class(content, *response_args, **response_kwargs)\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.ComponentNode","title":"ComponentNode","text":"<pre><code>ComponentNode(\n    name: str,\n    args: List[Expression],\n    kwargs: RuntimeKwargs,\n    registry: ComponentRegistry,\n    isolated_context: bool = False,\n    nodelist: Optional[NodeList] = None,\n    node_id: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>BaseNode</code></p> <p>Django.template.Node subclass that renders a django-components component</p> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    args: List[Expression],\n    kwargs: RuntimeKwargs,\n    registry: ComponentRegistry,  # noqa F811\n    isolated_context: bool = False,\n    nodelist: Optional[NodeList] = None,\n    node_id: Optional[str] = None,\n) -&gt; None:\n    super().__init__(nodelist=nodelist or NodeList(), args=args, kwargs=kwargs, node_id=node_id)\n\n    self.name = name\n    self.isolated_context = isolated_context\n    self.registry = registry\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.ComponentVars","title":"ComponentVars","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Type for the variables available inside the component templates.</p> <p>All variables here are scoped under <code>component_vars.</code>, so e.g. attribute <code>is_filled</code> on this class is accessible inside the template as:</p> <pre><code>{{ component_vars.is_filled }}\n</code></pre> <p>Attributes:</p> <ul> <li> <code>is_filled</code>               (<code>Dict[str, bool]</code>)           \u2013            <p>Dictonary describing which component slots are filled (<code>True</code>) or are not (<code>False</code>).</p> </li> </ul>"},{"location":"reference/django_components/component/#django_components.component.ComponentVars.is_filled","title":"is_filled  <code>instance-attribute</code>","text":"<pre><code>is_filled: Dict[str, bool]\n</code></pre> <p>Dictonary describing which component slots are filled (<code>True</code>) or are not (<code>False</code>).</p> <p>New in version 0.70</p> <p>Use as <code>{{ component_vars.is_filled }}</code></p> <p>Example:</p> <pre><code>{# Render wrapping HTML only if the slot is defined #}\n{% if component_vars.is_filled.my_slot %}\n    &lt;div class=\"slot-wrapper\"&gt;\n        {% slot \"my_slot\" / %}\n    &lt;/div&gt;\n{% endif %}\n</code></pre>"},{"location":"reference/django_components/component/#django_components.component.ComponentView","title":"ComponentView","text":"<pre><code>ComponentView(component: Component, **kwargs: Any)\n</code></pre> <p>               Bases: <code>View</code></p> <p>Subclass of <code>django.views.View</code> where the <code>Component</code> instance is available via <code>self.component</code>.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(self, component: \"Component\", **kwargs: Any) -&gt; None:\n    super().__init__(**kwargs)\n    self.component = component\n</code></pre>"},{"location":"reference/django_components/component_media/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> component_media","text":""},{"location":"reference/django_components/component_media/#django_components.component_media","title":"component_media","text":"<p>Classes:</p> <ul> <li> <code>ComponentMediaInput</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>MediaMeta</code>           \u2013            <p>Metaclass for handling media files for components.</p> </li> </ul>"},{"location":"reference/django_components/component_media/#django_components.component_media.ComponentMediaInput","title":"ComponentMediaInput","text":"<p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/component_media/#django_components.component_media.MediaMeta","title":"MediaMeta","text":"<p>               Bases: <code>MediaDefiningClass</code></p> <p>Metaclass for handling media files for components.</p> <p>Similar to <code>MediaDefiningClass</code>, this class supports the use of <code>Media</code> attribute to define associated JS/CSS files, which are then available under <code>media</code> attribute as a instance of <code>Media</code> class.</p> <p>This subclass has following changes:</p>"},{"location":"reference/django_components/component_media/#django_components.component_media.MediaMeta--1-support-for-multiple-interfaces-of-jscss","title":"1. Support for multiple interfaces of JS/CSS","text":"<ol> <li> <p>As plain strings     <pre><code>class MyComponent(Component):\n    class Media:\n        js = \"path/to/script.js\"\n        css = \"path/to/style.css\"\n</code></pre></p> </li> <li> <p>As lists     <pre><code>class MyComponent(Component):\n    class Media:\n        js = [\"path/to/script1.js\", \"path/to/script2.js\"]\n        css = [\"path/to/style1.css\", \"path/to/style2.css\"]\n</code></pre></p> </li> <li> <p>[CSS ONLY] Dicts of strings     <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": \"path/to/style1.css\",\n            \"print\": \"path/to/style2.css\",\n        }\n</code></pre></p> </li> <li> <p>[CSS ONLY] Dicts of lists     <pre><code>class MyComponent(Component):\n    class Media:\n        css = {\n            \"all\": [\"path/to/style1.css\"],\n            \"print\": [\"path/to/style2.css\"],\n        }\n</code></pre></p> </li> </ol>"},{"location":"reference/django_components/component_media/#django_components.component_media.MediaMeta--2-media-are-first-resolved-relative-to-class-definition-file","title":"2. Media are first resolved relative to class definition file","text":"<p>E.g. if in a directory <code>my_comp</code> you have <code>script.js</code> and <code>my_comp.py</code>, and <code>my_comp.py</code> looks like this:</p> <pre><code>class MyComponent(Component):\n    class Media:\n        js = \"script.js\"\n</code></pre> <p>Then <code>script.js</code> will be resolved as <code>my_comp/script.js</code>.</p>"},{"location":"reference/django_components/component_media/#django_components.component_media.MediaMeta--3-media-can-be-defined-as-str-bytes-pathlike-safestring-or-function-of-thereof","title":"3. Media can be defined as str, bytes, PathLike, SafeString, or function of thereof","text":"<p>E.g.:</p> <pre><code>def lazy_eval_css():\n    # do something\n    return path\n\nclass MyComponent(Component):\n    class Media:\n        js = b\"script.js\"\n        css = lazy_eval_css\n</code></pre>"},{"location":"reference/django_components/component_media/#django_components.component_media.MediaMeta--4-subclass-media-class-with-media_class","title":"4. Subclass <code>Media</code> class with <code>media_class</code>","text":"<p>Normal <code>MediaDefiningClass</code> creates an instance of <code>Media</code> class under the <code>media</code> attribute. This class allows to override which class will be instantiated with <code>media_class</code> attribute:</p> <pre><code>class MyMedia(Media):\n    def render_js(self):\n        ...\n\nclass MyComponent(Component):\n    media_class = MyMedia\n    def get_context_data(self):\n        assert isinstance(self.media, MyMedia)\n</code></pre>"},{"location":"reference/django_components/component_registry/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> component_registry","text":""},{"location":"reference/django_components/component_registry/#django_components.component_registry","title":"component_registry","text":"<p>Classes:</p> <ul> <li> <code>AlreadyRegistered</code>           \u2013            <p>Raised when you try to register a Component,</p> </li> <li> <code>ComponentRegistry</code>           \u2013            <p>Manages components and makes them available</p> </li> <li> <code>NotRegistered</code>           \u2013            <p>Raised when you try to access a Component,</p> </li> <li> <code>RegistrySettings</code>           \u2013            <p>Configuration for a <code>ComponentRegistry</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>register</code>             \u2013              <p>Class decorator for registering a component</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>registry</code>               (<code>ComponentRegistry</code>)           \u2013            <p>The default and global component registry.</p> </li> </ul>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.registry","title":"registry  <code>module-attribute</code>","text":"<pre><code>registry: ComponentRegistry = ComponentRegistry()\n</code></pre> <p>The default and global component registry. Use this instance to directly register or remove components:</p> <p>See Registering components.</p> <pre><code># Register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n\n# Get single\nregistry.get(\"button\")\n\n# Get all\nregistry.all()\n\n# Unregister single\nregistry.unregister(\"button\")\n\n# Unregister all\nregistry.clear()\n</code></pre>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.AlreadyRegistered","title":"AlreadyRegistered","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when you try to register a Component, but it's already registered with given ComponentRegistry.</p>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.ComponentRegistry","title":"ComponentRegistry","text":"<pre><code>ComponentRegistry(\n    library: Optional[Library] = None, settings: Optional[Union[RegistrySettings, Callable[[ComponentRegistry], RegistrySettings]]] = None\n)\n</code></pre> <p>Manages components and makes them available in the template, by default as <code>{% component %}</code> tags.</p> <pre><code>{% component \"my_comp\" key=value %}\n{% endcomponent %}\n</code></pre> <p>To enable a component to be used in a template, the component must be registered with a component registry.</p> <p>When you register a component to a registry, behind the scenes the registry automatically adds the component's template tag (e.g. <code>{% component %}</code> to the <code>Library</code>. And the opposite happens when you unregister a component - the tag is removed.</p> <p>See Registering components.</p> <p>Parameters:</p> <ul> <li> <code>library</code>               (<code>Library</code>, default:                   <code>None</code> )           \u2013            <p>Django            <code>Library</code>            associated with this registry. If omitted, the default Library instance from django_components is used.</p> </li> <li> <code>settings</code>               (<code>Union[RegistrySettings, Callable[[ComponentRegistry], RegistrySettings]]</code>, default:                   <code>None</code> )           \u2013            <p>Configure            how the components registered with this registry will behave when rendered.            See <code>RegistrySettings</code>. Can be either            a static value or a callable that returns the settings. If omitted, the settings from            <code>COMPONENTS</code> are used.</p> </li> </ul> <p>Notes:</p> <ul> <li>The default registry is available as <code>django_components.registry</code>.</li> <li>The default registry is used when registering components with <code>@register</code> decorator.</li> </ul> <p>Example:</p> <pre><code># Use with default Library\nregistry = ComponentRegistry()\n\n# Or a custom one\nmy_lib = Library()\nregistry = ComponentRegistry(library=my_lib)\n\n# Usage\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\nregistry.all()\nregistry.clear()\nregistry.get()\n</code></pre>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.ComponentRegistry--using-registry-to-share-components","title":"Using registry to share components","text":"<p>You can use component registry for isolating or \"packaging\" components:</p> <ol> <li> <p>Create new instance of <code>ComponentRegistry</code> and Library:     <pre><code>my_comps = Library()\nmy_comps_reg = ComponentRegistry(library=my_comps)\n</code></pre></p> </li> <li> <p>Register components to the registry:     <pre><code>my_comps_reg.register(\"my_button\", ButtonComponent)\nmy_comps_reg.register(\"my_card\", CardComponent)\n</code></pre></p> </li> <li> <p>In your target project, load the Library associated with the registry:     <pre><code>{% load my_comps %}\n</code></pre></p> </li> <li> <p>Use the registered components in your templates:     <pre><code>{% component \"button\" %}\n{% endcomponent %}\n</code></pre></p> </li> </ol> <p>Methods:</p> <ul> <li> <code>all</code>             \u2013              <p>Retrieve all registered <code>Component</code> classes.</p> </li> <li> <code>clear</code>             \u2013              <p>Clears the registry, unregistering all components.</p> </li> <li> <code>get</code>             \u2013              <p>Retrieve a <code>Component</code></p> </li> <li> <code>register</code>             \u2013              <p>Register a <code>Component</code> class</p> </li> <li> <code>unregister</code>             \u2013              <p>Unregister the <code>Component</code> class</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>library</code>               (<code>Library</code>)           \u2013            <p>The template tag <code>Library</code></p> </li> <li> <code>settings</code>               (<code>InternalRegistrySettings</code>)           \u2013            <p>Registry settings configured for this registry.</p> </li> </ul> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def __init__(\n    self,\n    library: Optional[Library] = None,\n    settings: Optional[Union[RegistrySettings, Callable[[\"ComponentRegistry\"], RegistrySettings]]] = None,\n) -&gt; None:\n    self._registry: Dict[str, ComponentRegistryEntry] = {}  # component name -&gt; component_entry mapping\n    self._tags: Dict[str, Set[str]] = {}  # tag -&gt; list[component names]\n    self._library = library\n    self._settings_input = settings\n    self._settings: Optional[Callable[[], InternalRegistrySettings]] = None\n\n    all_registries.append(self)\n</code></pre>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.ComponentRegistry.library","title":"library  <code>property</code>","text":"<pre><code>library: Library\n</code></pre> <p>The template tag <code>Library</code> that is associated with the registry.</p>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.ComponentRegistry.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: InternalRegistrySettings\n</code></pre> <p>Registry settings configured for this registry.</p>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.ComponentRegistry.all","title":"all","text":"<pre><code>all() -&gt; Dict[str, Type[Component]]\n</code></pre> <p>Retrieve all registered <code>Component</code> classes.</p> <p>Returns:</p> <ul> <li> <code>Dict[str, Type[Component]]</code>           \u2013            <p>Dict[str, Type[Component]]: A dictionary of component names to component classes</p> </li> </ul> <p>Example:</p> <pre><code># First register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n# Then get all\nregistry.all()\n# &gt; {\n# &gt;   \"button\": ButtonComponent,\n# &gt;   \"card\": CardComponent,\n# &gt; }\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def all(self) -&gt; Dict[str, Type[\"Component\"]]:\n    \"\"\"\n    Retrieve all registered [`Component`](../api#django_components.Component) classes.\n\n    Returns:\n        Dict[str, Type[Component]]: A dictionary of component names to component classes\n\n    **Example:**\n\n    ```python\n    # First register components\n    registry.register(\"button\", ButtonComponent)\n    registry.register(\"card\", CardComponent)\n    # Then get all\n    registry.all()\n    # &gt; {\n    # &gt;   \"button\": ButtonComponent,\n    # &gt;   \"card\": CardComponent,\n    # &gt; }\n    ```\n    \"\"\"\n    comps = {key: entry.cls for key, entry in self._registry.items()}\n    return comps\n</code></pre>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.ComponentRegistry.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clears the registry, unregistering all components.</p> <p>Example:</p> <pre><code># First register components\nregistry.register(\"button\", ButtonComponent)\nregistry.register(\"card\", CardComponent)\n# Then clear\nregistry.clear()\n# Then get all\nregistry.all()\n# &gt; {}\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Clears the registry, unregistering all components.\n\n    Example:\n\n    ```python\n    # First register components\n    registry.register(\"button\", ButtonComponent)\n    registry.register(\"card\", CardComponent)\n    # Then clear\n    registry.clear()\n    # Then get all\n    registry.all()\n    # &gt; {}\n    ```\n    \"\"\"\n    all_comp_names = list(self._registry.keys())\n    for comp_name in all_comp_names:\n        self.unregister(comp_name)\n\n    self._registry = {}\n    self._tags = {}\n</code></pre>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.ComponentRegistry.get","title":"get","text":"<pre><code>get(name: str) -&gt; Type[Component]\n</code></pre> <p>Retrieve a <code>Component</code> class registered under the given name.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component was registered. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Type[Component]</code>           \u2013            <p>Type[Component]: The component class registered under the given name.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>NotRegistered</code>   if the given name is not registered.</li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then get\nregistry.get(\"button\")\n# &gt; ButtonComponent\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def get(self, name: str) -&gt; Type[\"Component\"]:\n    \"\"\"\n    Retrieve a [`Component`](../api#django_components.Component)\n    class registered under the given name.\n\n    Args:\n        name (str): The name under which the component was registered. Required.\n\n    Returns:\n        Type[Component]: The component class registered under the given name.\n\n    **Raises:**\n\n    - [`NotRegistered`](../exceptions#django_components.NotRegistered)\n      if the given name is not registered.\n\n    **Example:**\n\n    ```python\n    # First register component\n    registry.register(\"button\", ButtonComponent)\n    # Then get\n    registry.get(\"button\")\n    # &gt; ButtonComponent\n    ```\n    \"\"\"\n    if name not in self._registry:\n        raise NotRegistered('The component \"%s\" is not registered' % name)\n\n    return self._registry[name].cls\n</code></pre>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.ComponentRegistry.register","title":"register","text":"<pre><code>register(name: str, component: Type[Component]) -&gt; None\n</code></pre> <p>Register a <code>Component</code> class with this registry under the given name.</p> <p>A component MUST be registered before it can be used in a template such as: <pre><code>{% component \"my_comp\" %}\n{% endcomponent %}\n</code></pre></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component will be registered. Required.</p> </li> <li> <code>component</code>               (<code>Type[Component]</code>)           \u2013            <p>The component class to register. Required.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>AlreadyRegistered</code> if a different component was already registered under the same name.</li> </ul> <p>Example:</p> <pre><code>registry.register(\"button\", ButtonComponent)\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def register(self, name: str, component: Type[\"Component\"]) -&gt; None:\n    \"\"\"\n    Register a [`Component`](../api#django_components.Component) class\n    with this registry under the given name.\n\n    A component MUST be registered before it can be used in a template such as:\n    ```django\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n    ```\n\n    Args:\n        name (str): The name under which the component will be registered. Required.\n        component (Type[Component]): The component class to register. Required.\n\n    **Raises:**\n\n    - [`AlreadyRegistered`](../exceptions#django_components.AlreadyRegistered)\n    if a different component was already registered under the same name.\n\n    **Example:**\n\n    ```python\n    registry.register(\"button\", ButtonComponent)\n    ```\n    \"\"\"\n    existing_component = self._registry.get(name)\n    if existing_component and existing_component.cls._class_hash != component._class_hash:\n        raise AlreadyRegistered('The component \"%s\" has already been registered' % name)\n\n    entry = self._register_to_library(name, component)\n\n    # Keep track of which components use which tags, because multiple components may\n    # use the same tag.\n    tag = entry.tag\n    if tag not in self._tags:\n        self._tags[tag] = set()\n    self._tags[tag].add(name)\n\n    self._registry[name] = entry\n</code></pre>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.ComponentRegistry.unregister","title":"unregister","text":"<pre><code>unregister(name: str) -&gt; None\n</code></pre> <p>Unregister the <code>Component</code> class that was registered under the given name.</p> <p>Once a component is unregistered, it is no longer available in the templates.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>The name under which the component is registered. Required.</p> </li> </ul> <p>Raises:</p> <ul> <li><code>NotRegistered</code> if the given name is not registered.</li> </ul> <p>Example:</p> <pre><code># First register component\nregistry.register(\"button\", ButtonComponent)\n# Then unregister\nregistry.unregister(\"button\")\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def unregister(self, name: str) -&gt; None:\n    \"\"\"\n    Unregister the [`Component`](../api#django_components.Component) class\n    that was registered under the given name.\n\n    Once a component is unregistered, it is no longer available in the templates.\n\n    Args:\n        name (str): The name under which the component is registered. Required.\n\n    **Raises:**\n\n    - [`NotRegistered`](../exceptions#django_components.NotRegistered)\n    if the given name is not registered.\n\n    **Example:**\n\n    ```python\n    # First register component\n    registry.register(\"button\", ButtonComponent)\n    # Then unregister\n    registry.unregister(\"button\")\n    ```\n    \"\"\"\n    # Validate\n    self.get(name)\n\n    entry = self._registry[name]\n    tag = entry.tag\n\n    # Unregister the tag from library if this was the last component using this tag\n    # Unlink component from tag\n    self._tags[tag].remove(name)\n\n    # Cleanup\n    is_tag_empty = not len(self._tags[tag])\n    if is_tag_empty:\n        del self._tags[tag]\n\n    # Only unregister a tag if it's NOT protected\n    is_protected = is_tag_protected(self.library, tag)\n    if not is_protected:\n        # Unregister the tag from library if this was the last component using this tag\n        if is_tag_empty and tag in self.library.tags:\n            del self.library.tags[tag]\n\n    del self._registry[name]\n</code></pre>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.NotRegistered","title":"NotRegistered","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when you try to access a Component, but it's NOT registered with given ComponentRegistry.</p>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.RegistrySettings","title":"RegistrySettings","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Configuration for a <code>ComponentRegistry</code>.</p> <p>These settings define how the components registered with this registry will behave when rendered.</p> <pre><code>from django_components import ComponentRegistry, RegistrySettings\n\nregistry_settings = RegistrySettings(\n    context_behavior=\"django\",\n    tag_formatter=\"django_components.component_shorthand_formatter\",\n)\n\nregistry = ComponentRegistry(settings=registry_settings)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>CONTEXT_BEHAVIOR</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            <p>Deprecated. Use <code>context_behavior</code> instead. Will be removed in v1.</p> </li> <li> <code>TAG_FORMATTER</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            <p>Deprecated. Use <code>tag_formatter</code> instead. Will be removed in v1.</p> </li> <li> <code>context_behavior</code>               (<code>Optional[ContextBehaviorType]</code>)           \u2013            <p>Same as the global</p> </li> <li> <code>tag_formatter</code>               (<code>Optional[Union[TagFormatterABC, str]]</code>)           \u2013            <p>Same as the global</p> </li> </ul>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.RegistrySettings.CONTEXT_BEHAVIOR","title":"CONTEXT_BEHAVIOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CONTEXT_BEHAVIOR: Optional[ContextBehaviorType] = None\n</code></pre> <p>Deprecated. Use <code>context_behavior</code> instead. Will be removed in v1.</p> <p>Same as the global <code>COMPONENTS.context_behavior</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.context_behavior</code> setting.</p>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.RegistrySettings.TAG_FORMATTER","title":"TAG_FORMATTER  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>TAG_FORMATTER: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>Deprecated. Use <code>tag_formatter</code> instead. Will be removed in v1.</p> <p>Same as the global <code>COMPONENTS.tag_formatter</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.tag_formatter</code> setting.</p>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.RegistrySettings.context_behavior","title":"context_behavior  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>context_behavior: Optional[ContextBehaviorType] = None\n</code></pre> <p>Same as the global <code>COMPONENTS.context_behavior</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.context_behavior</code> setting.</p>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.RegistrySettings.tag_formatter","title":"tag_formatter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tag_formatter: Optional[Union[TagFormatterABC, str]] = None\n</code></pre> <p>Same as the global <code>COMPONENTS.tag_formatter</code> setting, but for this registry.</p> <p>If omitted, defaults to the global <code>COMPONENTS.tag_formatter</code> setting.</p>"},{"location":"reference/django_components/component_registry/#django_components.component_registry.register","title":"register","text":"<pre><code>register(name: str, registry: Optional[ComponentRegistry] = None) -&gt; Callable[\n    [Type[Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]]],\n    Type[Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]],\n]\n</code></pre> <p>Class decorator for registering a component to a component registry.</p> <p>See Registering components.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Registered name. This is the name by which the component will be accessed            from within a template when using the <code>{% component %}</code> tag. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to which to register this component. If omitted, component is registered to the default registry.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AlreadyRegistered</code>             \u2013            <p>If there is already a component registered under the same name.</p> </li> </ul> <p>Examples:</p> <pre><code>from django_components import Component, register\n\n@register(\"my_component\")\nclass MyComponent(Component):\n    ...\n</code></pre> <p>Specifing <code>ComponentRegistry</code> the component should be registered to by setting the <code>registry</code> kwarg:</p> <pre><code>from django.template import Library\nfrom django_components import Component, ComponentRegistry, register\n\nmy_lib = Library()\nmy_reg = ComponentRegistry(library=my_lib)\n\n@register(\"my_component\", registry=my_reg)\nclass MyComponent(Component):\n    ...\n</code></pre> Source code in <code>src/django_components/component_registry.py</code> <pre><code>def register(name: str, registry: Optional[ComponentRegistry] = None) -&gt; Callable[\n    [Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"]],\n    Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"],\n]:\n    \"\"\"\n    Class decorator for registering a [component](./#django_components.Component)\n    to a [component registry](./#django_components.ComponentRegistry).\n\n    See [Registering components](../../concepts/advanced/component_registry).\n\n    Args:\n        name (str): Registered name. This is the name by which the component will be accessed\\\n            from within a template when using the [`{% component %}`](../template_tags#component) tag. Required.\n        registry (ComponentRegistry, optional): Specify the [registry](./#django_components.ComponentRegistry)\\\n            to which to register this component. If omitted, component is registered to the default registry.\n\n    Raises:\n        AlreadyRegistered: If there is already a component registered under the same name.\n\n    **Examples**:\n\n    ```python\n    from django_components import Component, register\n\n    @register(\"my_component\")\n    class MyComponent(Component):\n        ...\n    ```\n\n    Specifing [`ComponentRegistry`](./#django_components.ComponentRegistry) the component\n    should be registered to by setting the `registry` kwarg:\n\n    ```python\n    from django.template import Library\n    from django_components import Component, ComponentRegistry, register\n\n    my_lib = Library()\n    my_reg = ComponentRegistry(library=my_lib)\n\n    @register(\"my_component\", registry=my_reg)\n    class MyComponent(Component):\n        ...\n    ```\n    \"\"\"\n    if registry is None:\n        registry = _the_registry\n\n    def decorator(\n        component: Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"],\n    ) -&gt; Type[\"Component[ArgsType, KwargsType, SlotsType, DataType, JsDataType, CssDataType]\"]:\n        registry.register(name=name, component=component)\n        return component\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/components/","title":"Index","text":""},{"location":"reference/django_components/components/#django_components.components","title":"components","text":"<p>Modules:</p> <ul> <li> <code>dynamic</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>DynamicComponent</code>           \u2013            <p>This component is given a registered name or a reference to another component,</p> </li> </ul>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent","title":"DynamicComponent","text":"<pre><code>DynamicComponent(\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>This component is given a registered name or a reference to another component, and behaves as if the other component was in its place.</p> <p>The args, kwargs, and slot fills are all passed down to the underlying component.</p> <p>Parameters:</p> <ul> <li> <code>is</code>               (<code>str | Type[Component]</code>)           \u2013            <p>Component that should be rendered. Either a registered name of a component, or a Component class directly. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to search for the registered name. If omitted, all registries are searched until the first match.</p> </li> <li> <code>*args</code>           \u2013            <p>Additional data passed to the component.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional data passed to the component.</p> </li> </ul> <p>Slots:</p> <ul> <li>Any slots, depending on the actual component.</li> </ul> <p>Examples:</p> <p>Django <pre><code>{% component \"dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Python <pre><code>from django_components import DynamicComponent\n\nDynamicComponent.render(\n    kwargs={\n        \"is\": table_comp,\n        \"data\": table_data,\n        \"headers\": table_headers,\n    },\n    slots={\n        \"pagination\": PaginationComponent.render(\n            render_dependencies=False,\n        ),\n    },\n)\n</code></pre></p>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent--use-cases","title":"Use cases","text":"<p>Dynamic components are suitable if you are writing something like a form component. You may design it such that users give you a list of input types, and you render components depending on the input types.</p> <p>While you could handle this with a series of if / else statements, that's not an extensible approach. Instead, you can use the dynamic component in place of normal components.</p>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent--component-name","title":"Component name","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can set the <code>COMPONENTS.dynamic_component_name</code> setting to change the name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name: <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> </li> <li> <code>get_template</code>             \u2013              <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>get_template_name</code>             \u2013              <p>Filepath to the Django template associated with this component.</p> </li> <li> <code>inject</code>             \u2013              <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag</p> </li> <li> <code>on_render_after</code>             \u2013              <p>Hook that runs just after the component's template was rendered.</p> </li> <li> <code>on_render_before</code>             \u2013              <p>Hook that runs just before the component's template is rendered.</p> </li> <li> <code>render</code>             \u2013              <p>Render the component into a string.</p> </li> <li> <code>render_to_response</code>             \u2013              <p>Render the component and wrap the content in the response class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Media</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined CSS associated with this component.</p> </li> <li> <code>input</code>               (<code>RenderInput[ArgsType, KwargsType, SlotsType]</code>)           \u2013            <p>Input holds the data (like arg, kwargs, slots) that were passsed to</p> </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            <p>Dictionary describing which slots have or have not been filled.</p> </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined JS associated with this component.</p> </li> <li> <code>media</code>               (<code>Media</code>)           \u2013            <p>Normalized definition of JS and CSS media files associated with this component.</p> </li> <li> <code>response_class</code>           \u2013            <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p> </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Filepath to the Django template associated with this component.</p> </li> </ul> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,  # noqa F811\n):\n    # When user first instantiates the component class before calling\n    # `render` or `render_to_response`, then we want to allow the render\n    # function to make use of the instantiated object.\n    #\n    # So while `MyComp.render()` creates a new instance of MyComp internally,\n    # if we do `MyComp(registered_name=\"abc\").render()`, then we use the\n    # already-instantiated object.\n    #\n    # To achieve that, we want to re-assign the class methods as instance methods.\n    # For that we have to \"unwrap\" the class methods via __func__.\n    # See https://stackoverflow.com/a/76706399/9788634\n    self.render_to_response = types.MethodType(self.__class__.render_to_response.__func__, self)  # type: ignore\n    self.render = types.MethodType(self.__class__.render.__func__, self)  # type: ignore\n    self.as_view = types.MethodType(self.__class__.as_view.__func__, self)  # type: ignore\n\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.component_id = component_id or gen_id()\n    self.registry = registry or registry_\n    self._render_stack: Deque[RenderStackItem[ArgsType, KwargsType, SlotsType]] = deque()\n    # None == uninitialized, False == No types, Tuple == types\n    self._types: Optional[Union[Tuple[Any, Any, Any, Any, Any, Any], Literal[False]]] = None\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.Media","title":"Media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Media = ComponentMediaInput\n</code></pre> <p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>Inlined CSS associated with this component.</p>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.input","title":"input  <code>property</code>","text":"<pre><code>input: RenderInput[ArgsType, KwargsType, SlotsType]\n</code></pre> <p>Input holds the data (like arg, kwargs, slots) that were passsed to the current execution of the <code>render</code> method.</p>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.is_filled","title":"is_filled  <code>property</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within the template as <code>{{ component_vars.is_filled.slot_name }}</code>, and within <code>on_render_before</code> and <code>on_render_after</code> hooks.</p>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>Inlined JS associated with this component.</p>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.media","title":"media  <code>instance-attribute</code>","text":"<pre><code>media: Media\n</code></pre> <p>Normalized definition of JS and CSS media files associated with this component.</p> <p>NOTE: This field is generated from Component.Media class.</p>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.response_class","title":"response_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>response_class = HttpResponse\n</code></pre> <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.template_name","title":"template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = None\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef as_view(cls, **initkwargs: Any) -&gt; ViewFn:\n    \"\"\"\n    Shortcut for calling `Component.View.as_view` and passing component instance to it.\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    # Allow the View class to access this component via `self.component`\n    return comp.View.as_view(**initkwargs, component=comp)\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template(self, context: Context) -&gt; Optional[Union[str, Template]]:\n    \"\"\"\n    Inlined Django template associated with this component. Can be a plain string or a Template instance.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template_name(self, context: Context) -&gt; Optional[str]:\n    \"\"\"\n    Filepath to the Django template associated with this component.\n\n    The filepath must be relative to either the file where the component class was defined,\n    or one of the roots of `STATIFILES_DIRS`.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>provide</code> tag with given key was NOT found.</p> <p>This method mut be used inside the <code>get_context_data()</code> method and raises an error if called elsewhere.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"provider\" hello=\"world\" %}\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ data.hello }}!\"\n    def get_context_data(self):\n        data = self.inject(\"provider\")\n        return {\"data\": data}\n</code></pre></p> <p>This renders into: <pre><code>hi world!\n</code></pre></p> <p>As the <code>{{ data.hello }}</code> is taken from the \"provider\".</p> Source code in <code>src/django_components/component.py</code> <pre><code>def inject(self, key: str, default: Optional[Any] = None) -&gt; Any:\n    \"\"\"\n    Use this method to retrieve the data that was passed to a `{% provide %}` tag\n    with the corresponding key.\n\n    To retrieve the data, `inject()` must be called inside a component that's\n    inside the `{% provide %}` tag.\n\n    You may also pass a default that will be used if the `provide` tag with given\n    key was NOT found.\n\n    This method mut be used inside the `get_context_data()` method and raises\n    an error if called elsewhere.\n\n    Example:\n\n    Given this template:\n    ```django\n    {% provide \"provider\" hello=\"world\" %}\n        {% component \"my_comp\" %}\n        {% endcomponent %}\n    {% endprovide %}\n    ```\n\n    And given this definition of \"my_comp\" component:\n    ```py\n    from django_components import Component, register\n\n    @register(\"my_comp\")\n    class MyComp(Component):\n        template = \"hi {{ data.hello }}!\"\n        def get_context_data(self):\n            data = self.inject(\"provider\")\n            return {\"data\": data}\n    ```\n\n    This renders into:\n    ```\n    hi world!\n    ```\n\n    As the `{{ data.hello }}` is taken from the \"provider\".\n    \"\"\"\n    if self.input is None:\n        raise RuntimeError(\n            f\"Method 'inject()' of component '{self.name}' was called outside of 'get_context_data()'\"\n        )\n\n    return get_injected_context_var(self.name, self.input.context, key, default)\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Template, content: str) -&gt; Optional[SlotResult]\n</code></pre> <p>Hook that runs just after the component's template was rendered. It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_after(self, context: Context, template: Template, content: str) -&gt; Optional[SlotResult]:\n    \"\"\"\n    Hook that runs just after the component's template was rendered.\n    It receives the rendered output as the last argument.\n\n    You can use this hook to access the context or the template, but modifying\n    them won't have any effect.\n\n    To override the content that gets rendered, you can return a string or SafeString\n    from this hook.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Template) -&gt; None\n</code></pre> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_before(self, context: Context, template: Template) -&gt; None:\n    \"\"\"\n    Hook that runs just before the component's template is rendered.\n\n    You can use this hook to access or modify the context or the template.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str\n</code></pre> <p>Render the component into a string.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag. - <code>render_dependencies</code> - Set this to <code>False</code> if you want to insert the resulting HTML into another component.</p> <p>Example: <pre><code>MyComponent.render(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str:\n    \"\"\"\n    Render the component into a string.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n    - `render_dependencies` - Set this to `False` if you want to insert the resulting HTML into another component.\n\n    Example:\n    ```py\n    MyComponent.render(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n    )\n    ```\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    return comp._render(context, args, kwargs, slots, escape_slots_content, type, render_dependencies)\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.DynamicComponent.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and wrap the content in the response class.</p> <p>The response class is taken from <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <p>This is the interface for the <code>django.views.View</code> class which allows us to use components as Django views with <code>component.as_view()</code>.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag.</p> <p>Any additional args and kwargs are passed to the <code>response_class</code>.</p> <p>Example: <pre><code>MyComponent.render_to_response(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n    # HttpResponse input\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render_to_response(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"\n    Render the component and wrap the content in the response class.\n\n    The response class is taken from `Component.response_class`. Defaults to `django.http.HttpResponse`.\n\n    This is the interface for the `django.views.View` class which allows us to\n    use components as Django views with `component.as_view()`.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n\n    Any additional args and kwargs are passed to the `response_class`.\n\n    Example:\n    ```py\n    MyComponent.render_to_response(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n        # HttpResponse input\n        status=201,\n        headers={...},\n    )\n    # HttpResponse(content=..., status=201, headers=...)\n    ```\n    \"\"\"\n    content = cls.render(\n        args=args,\n        kwargs=kwargs,\n        context=context,\n        slots=slots,\n        escape_slots_content=escape_slots_content,\n        type=type,\n        render_dependencies=True,\n    )\n    return cls.response_class(content, *response_args, **response_kwargs)\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.dynamic","title":"dynamic","text":"<p>Modules:</p> <ul> <li> <code>types</code>           \u2013            <p>Helper types for IDEs.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DynamicComponent</code>           \u2013            <p>This component is given a registered name or a reference to another component,</p> </li> </ul>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent","title":"DynamicComponent","text":"<pre><code>DynamicComponent(\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>This component is given a registered name or a reference to another component, and behaves as if the other component was in its place.</p> <p>The args, kwargs, and slot fills are all passed down to the underlying component.</p> <p>Parameters:</p> <ul> <li> <code>is</code>               (<code>str | Type[Component]</code>)           \u2013            <p>Component that should be rendered. Either a registered name of a component, or a Component class directly. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to search for the registered name. If omitted, all registries are searched until the first match.</p> </li> <li> <code>*args</code>           \u2013            <p>Additional data passed to the component.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional data passed to the component.</p> </li> </ul> <p>Slots:</p> <ul> <li>Any slots, depending on the actual component.</li> </ul> <p>Examples:</p> <p>Django <pre><code>{% component \"dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Python <pre><code>from django_components import DynamicComponent\n\nDynamicComponent.render(\n    kwargs={\n        \"is\": table_comp,\n        \"data\": table_data,\n        \"headers\": table_headers,\n    },\n    slots={\n        \"pagination\": PaginationComponent.render(\n            render_dependencies=False,\n        ),\n    },\n)\n</code></pre></p>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent--use-cases","title":"Use cases","text":"<p>Dynamic components are suitable if you are writing something like a form component. You may design it such that users give you a list of input types, and you render components depending on the input types.</p> <p>While you could handle this with a series of if / else statements, that's not an extensible approach. Instead, you can use the dynamic component in place of normal components.</p>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent--component-name","title":"Component name","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can set the <code>COMPONENTS.dynamic_component_name</code> setting to change the name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name: <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> </li> <li> <code>get_template</code>             \u2013              <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>get_template_name</code>             \u2013              <p>Filepath to the Django template associated with this component.</p> </li> <li> <code>inject</code>             \u2013              <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag</p> </li> <li> <code>on_render_after</code>             \u2013              <p>Hook that runs just after the component's template was rendered.</p> </li> <li> <code>on_render_before</code>             \u2013              <p>Hook that runs just before the component's template is rendered.</p> </li> <li> <code>render</code>             \u2013              <p>Render the component into a string.</p> </li> <li> <code>render_to_response</code>             \u2013              <p>Render the component and wrap the content in the response class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Media</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined CSS associated with this component.</p> </li> <li> <code>input</code>               (<code>RenderInput[ArgsType, KwargsType, SlotsType]</code>)           \u2013            <p>Input holds the data (like arg, kwargs, slots) that were passsed to</p> </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            <p>Dictionary describing which slots have or have not been filled.</p> </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined JS associated with this component.</p> </li> <li> <code>media</code>               (<code>Media</code>)           \u2013            <p>Normalized definition of JS and CSS media files associated with this component.</p> </li> <li> <code>response_class</code>           \u2013            <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p> </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Filepath to the Django template associated with this component.</p> </li> </ul> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,  # noqa F811\n):\n    # When user first instantiates the component class before calling\n    # `render` or `render_to_response`, then we want to allow the render\n    # function to make use of the instantiated object.\n    #\n    # So while `MyComp.render()` creates a new instance of MyComp internally,\n    # if we do `MyComp(registered_name=\"abc\").render()`, then we use the\n    # already-instantiated object.\n    #\n    # To achieve that, we want to re-assign the class methods as instance methods.\n    # For that we have to \"unwrap\" the class methods via __func__.\n    # See https://stackoverflow.com/a/76706399/9788634\n    self.render_to_response = types.MethodType(self.__class__.render_to_response.__func__, self)  # type: ignore\n    self.render = types.MethodType(self.__class__.render.__func__, self)  # type: ignore\n    self.as_view = types.MethodType(self.__class__.as_view.__func__, self)  # type: ignore\n\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.component_id = component_id or gen_id()\n    self.registry = registry or registry_\n    self._render_stack: Deque[RenderStackItem[ArgsType, KwargsType, SlotsType]] = deque()\n    # None == uninitialized, False == No types, Tuple == types\n    self._types: Optional[Union[Tuple[Any, Any, Any, Any, Any, Any], Literal[False]]] = None\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.Media","title":"Media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Media = ComponentMediaInput\n</code></pre> <p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>Inlined CSS associated with this component.</p>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.input","title":"input  <code>property</code>","text":"<pre><code>input: RenderInput[ArgsType, KwargsType, SlotsType]\n</code></pre> <p>Input holds the data (like arg, kwargs, slots) that were passsed to the current execution of the <code>render</code> method.</p>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.is_filled","title":"is_filled  <code>property</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within the template as <code>{{ component_vars.is_filled.slot_name }}</code>, and within <code>on_render_before</code> and <code>on_render_after</code> hooks.</p>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>Inlined JS associated with this component.</p>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.media","title":"media  <code>instance-attribute</code>","text":"<pre><code>media: Media\n</code></pre> <p>Normalized definition of JS and CSS media files associated with this component.</p> <p>NOTE: This field is generated from Component.Media class.</p>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.response_class","title":"response_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>response_class = HttpResponse\n</code></pre> <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.template_name","title":"template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = None\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef as_view(cls, **initkwargs: Any) -&gt; ViewFn:\n    \"\"\"\n    Shortcut for calling `Component.View.as_view` and passing component instance to it.\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    # Allow the View class to access this component via `self.component`\n    return comp.View.as_view(**initkwargs, component=comp)\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template(self, context: Context) -&gt; Optional[Union[str, Template]]:\n    \"\"\"\n    Inlined Django template associated with this component. Can be a plain string or a Template instance.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template_name(self, context: Context) -&gt; Optional[str]:\n    \"\"\"\n    Filepath to the Django template associated with this component.\n\n    The filepath must be relative to either the file where the component class was defined,\n    or one of the roots of `STATIFILES_DIRS`.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>provide</code> tag with given key was NOT found.</p> <p>This method mut be used inside the <code>get_context_data()</code> method and raises an error if called elsewhere.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"provider\" hello=\"world\" %}\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ data.hello }}!\"\n    def get_context_data(self):\n        data = self.inject(\"provider\")\n        return {\"data\": data}\n</code></pre></p> <p>This renders into: <pre><code>hi world!\n</code></pre></p> <p>As the <code>{{ data.hello }}</code> is taken from the \"provider\".</p> Source code in <code>src/django_components/component.py</code> <pre><code>def inject(self, key: str, default: Optional[Any] = None) -&gt; Any:\n    \"\"\"\n    Use this method to retrieve the data that was passed to a `{% provide %}` tag\n    with the corresponding key.\n\n    To retrieve the data, `inject()` must be called inside a component that's\n    inside the `{% provide %}` tag.\n\n    You may also pass a default that will be used if the `provide` tag with given\n    key was NOT found.\n\n    This method mut be used inside the `get_context_data()` method and raises\n    an error if called elsewhere.\n\n    Example:\n\n    Given this template:\n    ```django\n    {% provide \"provider\" hello=\"world\" %}\n        {% component \"my_comp\" %}\n        {% endcomponent %}\n    {% endprovide %}\n    ```\n\n    And given this definition of \"my_comp\" component:\n    ```py\n    from django_components import Component, register\n\n    @register(\"my_comp\")\n    class MyComp(Component):\n        template = \"hi {{ data.hello }}!\"\n        def get_context_data(self):\n            data = self.inject(\"provider\")\n            return {\"data\": data}\n    ```\n\n    This renders into:\n    ```\n    hi world!\n    ```\n\n    As the `{{ data.hello }}` is taken from the \"provider\".\n    \"\"\"\n    if self.input is None:\n        raise RuntimeError(\n            f\"Method 'inject()' of component '{self.name}' was called outside of 'get_context_data()'\"\n        )\n\n    return get_injected_context_var(self.name, self.input.context, key, default)\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Template, content: str) -&gt; Optional[SlotResult]\n</code></pre> <p>Hook that runs just after the component's template was rendered. It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_after(self, context: Context, template: Template, content: str) -&gt; Optional[SlotResult]:\n    \"\"\"\n    Hook that runs just after the component's template was rendered.\n    It receives the rendered output as the last argument.\n\n    You can use this hook to access the context or the template, but modifying\n    them won't have any effect.\n\n    To override the content that gets rendered, you can return a string or SafeString\n    from this hook.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Template) -&gt; None\n</code></pre> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_before(self, context: Context, template: Template) -&gt; None:\n    \"\"\"\n    Hook that runs just before the component's template is rendered.\n\n    You can use this hook to access or modify the context or the template.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str\n</code></pre> <p>Render the component into a string.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag. - <code>render_dependencies</code> - Set this to <code>False</code> if you want to insert the resulting HTML into another component.</p> <p>Example: <pre><code>MyComponent.render(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str:\n    \"\"\"\n    Render the component into a string.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n    - `render_dependencies` - Set this to `False` if you want to insert the resulting HTML into another component.\n\n    Example:\n    ```py\n    MyComponent.render(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n    )\n    ```\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    return comp._render(context, args, kwargs, slots, escape_slots_content, type, render_dependencies)\n</code></pre>"},{"location":"reference/django_components/components/#django_components.components.dynamic.DynamicComponent.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and wrap the content in the response class.</p> <p>The response class is taken from <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <p>This is the interface for the <code>django.views.View</code> class which allows us to use components as Django views with <code>component.as_view()</code>.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag.</p> <p>Any additional args and kwargs are passed to the <code>response_class</code>.</p> <p>Example: <pre><code>MyComponent.render_to_response(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n    # HttpResponse input\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render_to_response(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"\n    Render the component and wrap the content in the response class.\n\n    The response class is taken from `Component.response_class`. Defaults to `django.http.HttpResponse`.\n\n    This is the interface for the `django.views.View` class which allows us to\n    use components as Django views with `component.as_view()`.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n\n    Any additional args and kwargs are passed to the `response_class`.\n\n    Example:\n    ```py\n    MyComponent.render_to_response(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n        # HttpResponse input\n        status=201,\n        headers={...},\n    )\n    # HttpResponse(content=..., status=201, headers=...)\n    ```\n    \"\"\"\n    content = cls.render(\n        args=args,\n        kwargs=kwargs,\n        context=context,\n        slots=slots,\n        escape_slots_content=escape_slots_content,\n        type=type,\n        render_dependencies=True,\n    )\n    return cls.response_class(content, *response_args, **response_kwargs)\n</code></pre>"},{"location":"reference/django_components/components/dynamic/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> dynamic","text":""},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic","title":"dynamic","text":"<p>Modules:</p> <ul> <li> <code>types</code>           \u2013            <p>Helper types for IDEs.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DynamicComponent</code>           \u2013            <p>This component is given a registered name or a reference to another component,</p> </li> </ul>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent","title":"DynamicComponent","text":"<pre><code>DynamicComponent(\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,\n)\n</code></pre> <p>               Bases: <code>Component</code></p> <p>This component is given a registered name or a reference to another component, and behaves as if the other component was in its place.</p> <p>The args, kwargs, and slot fills are all passed down to the underlying component.</p> <p>Parameters:</p> <ul> <li> <code>is</code>               (<code>str | Type[Component]</code>)           \u2013            <p>Component that should be rendered. Either a registered name of a component, or a Component class directly. Required.</p> </li> <li> <code>registry</code>               (<code>ComponentRegistry</code>, default:                   <code>None</code> )           \u2013            <p>Specify the registry            to search for the registered name. If omitted, all registries are searched until the first match.</p> </li> <li> <code>*args</code>           \u2013            <p>Additional data passed to the component.</p> </li> <li> <code>**kwargs</code>           \u2013            <p>Additional data passed to the component.</p> </li> </ul> <p>Slots:</p> <ul> <li>Any slots, depending on the actual component.</li> </ul> <p>Examples:</p> <p>Django <pre><code>{% component \"dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Python <pre><code>from django_components import DynamicComponent\n\nDynamicComponent.render(\n    kwargs={\n        \"is\": table_comp,\n        \"data\": table_data,\n        \"headers\": table_headers,\n    },\n    slots={\n        \"pagination\": PaginationComponent.render(\n            render_dependencies=False,\n        ),\n    },\n)\n</code></pre></p>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent--use-cases","title":"Use cases","text":"<p>Dynamic components are suitable if you are writing something like a form component. You may design it such that users give you a list of input types, and you render components depending on the input types.</p> <p>While you could handle this with a series of if / else statements, that's not an extensible approach. Instead, you can use the dynamic component in place of normal components.</p>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent--component-name","title":"Component name","text":"<p>By default, the dynamic component is registered under the name <code>\"dynamic\"</code>. In case of a conflict, you can set the <code>COMPONENTS.dynamic_component_name</code> setting to change the name used for the dynamic components.</p> <pre><code># settings.py\nCOMPONENTS = ComponentsSettings(\n    dynamic_component_name=\"my_dynamic\",\n)\n</code></pre> <p>After which you will be able to use the dynamic component with the new name: <pre><code>{% component \"my_dynamic\" is=table_comp data=table_data headers=table_headers %}\n    {% fill \"pagination\" %}\n        {% component \"pagination\" / %}\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Methods:</p> <ul> <li> <code>as_view</code>             \u2013              <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> </li> <li> <code>get_template</code>             \u2013              <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> </li> <li> <code>get_template_name</code>             \u2013              <p>Filepath to the Django template associated with this component.</p> </li> <li> <code>inject</code>             \u2013              <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag</p> </li> <li> <code>on_render_after</code>             \u2013              <p>Hook that runs just after the component's template was rendered.</p> </li> <li> <code>on_render_before</code>             \u2013              <p>Hook that runs just before the component's template is rendered.</p> </li> <li> <code>render</code>             \u2013              <p>Render the component into a string.</p> </li> <li> <code>render_to_response</code>             \u2013              <p>Render the component and wrap the content in the response class.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>Media</code>           \u2013            <p>Defines JS and CSS media files associated with this component.</p> </li> <li> <code>css</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined CSS associated with this component.</p> </li> <li> <code>input</code>               (<code>RenderInput[ArgsType, KwargsType, SlotsType]</code>)           \u2013            <p>Input holds the data (like arg, kwargs, slots) that were passsed to</p> </li> <li> <code>is_filled</code>               (<code>SlotIsFilled</code>)           \u2013            <p>Dictionary describing which slots have or have not been filled.</p> </li> <li> <code>js</code>               (<code>Optional[str]</code>)           \u2013            <p>Inlined JS associated with this component.</p> </li> <li> <code>media</code>               (<code>Media</code>)           \u2013            <p>Normalized definition of JS and CSS media files associated with this component.</p> </li> <li> <code>response_class</code>           \u2013            <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p> </li> <li> <code>template_name</code>               (<code>Optional[str]</code>)           \u2013            <p>Filepath to the Django template associated with this component.</p> </li> </ul> Source code in <code>src/django_components/component.py</code> <pre><code>def __init__(\n    self,\n    registered_name: Optional[str] = None,\n    component_id: Optional[str] = None,\n    outer_context: Optional[Context] = None,\n    registry: Optional[ComponentRegistry] = None,  # noqa F811\n):\n    # When user first instantiates the component class before calling\n    # `render` or `render_to_response`, then we want to allow the render\n    # function to make use of the instantiated object.\n    #\n    # So while `MyComp.render()` creates a new instance of MyComp internally,\n    # if we do `MyComp(registered_name=\"abc\").render()`, then we use the\n    # already-instantiated object.\n    #\n    # To achieve that, we want to re-assign the class methods as instance methods.\n    # For that we have to \"unwrap\" the class methods via __func__.\n    # See https://stackoverflow.com/a/76706399/9788634\n    self.render_to_response = types.MethodType(self.__class__.render_to_response.__func__, self)  # type: ignore\n    self.render = types.MethodType(self.__class__.render.__func__, self)  # type: ignore\n    self.as_view = types.MethodType(self.__class__.as_view.__func__, self)  # type: ignore\n\n    self.registered_name: Optional[str] = registered_name\n    self.outer_context: Context = outer_context or Context()\n    self.component_id = component_id or gen_id()\n    self.registry = registry or registry_\n    self._render_stack: Deque[RenderStackItem[ArgsType, KwargsType, SlotsType]] = deque()\n    # None == uninitialized, False == No types, Tuple == types\n    self._types: Optional[Union[Tuple[Any, Any, Any, Any, Any, Any], Literal[False]]] = None\n</code></pre>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.Media","title":"Media  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Media = ComponentMediaInput\n</code></pre> <p>Defines JS and CSS media files associated with this component.</p>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.css","title":"css  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>css: Optional[str] = None\n</code></pre> <p>Inlined CSS associated with this component.</p>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.input","title":"input  <code>property</code>","text":"<pre><code>input: RenderInput[ArgsType, KwargsType, SlotsType]\n</code></pre> <p>Input holds the data (like arg, kwargs, slots) that were passsed to the current execution of the <code>render</code> method.</p>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.is_filled","title":"is_filled  <code>property</code>","text":"<pre><code>is_filled: SlotIsFilled\n</code></pre> <p>Dictionary describing which slots have or have not been filled.</p> <p>This attribute is available for use only within the template as <code>{{ component_vars.is_filled.slot_name }}</code>, and within <code>on_render_before</code> and <code>on_render_after</code> hooks.</p>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.js","title":"js  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>js: Optional[str] = None\n</code></pre> <p>Inlined JS associated with this component.</p>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.media","title":"media  <code>instance-attribute</code>","text":"<pre><code>media: Media\n</code></pre> <p>Normalized definition of JS and CSS media files associated with this component.</p> <p>NOTE: This field is generated from Component.Media class.</p>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.response_class","title":"response_class  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>response_class = HttpResponse\n</code></pre> <p>This allows to configure what class is used to generate response from <code>render_to_response</code></p>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.template_name","title":"template_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>template_name: Optional[str] = None\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.as_view","title":"as_view  <code>classmethod</code>","text":"<pre><code>as_view(**initkwargs: Any) -&gt; ViewFn\n</code></pre> <p>Shortcut for calling <code>Component.View.as_view</code> and passing component instance to it.</p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef as_view(cls, **initkwargs: Any) -&gt; ViewFn:\n    \"\"\"\n    Shortcut for calling `Component.View.as_view` and passing component instance to it.\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    # Allow the View class to access this component via `self.component`\n    return comp.View.as_view(**initkwargs, component=comp)\n</code></pre>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.get_template","title":"get_template","text":"<pre><code>get_template(context: Context) -&gt; Optional[Union[str, Template]]\n</code></pre> <p>Inlined Django template associated with this component. Can be a plain string or a Template instance.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template(self, context: Context) -&gt; Optional[Union[str, Template]]:\n    \"\"\"\n    Inlined Django template associated with this component. Can be a plain string or a Template instance.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.get_template_name","title":"get_template_name","text":"<pre><code>get_template_name(context: Context) -&gt; Optional[str]\n</code></pre> <p>Filepath to the Django template associated with this component.</p> <p>The filepath must be relative to either the file where the component class was defined, or one of the roots of <code>STATIFILES_DIRS</code>.</p> <p>Only one of <code>template_name</code>, <code>get_template_name</code>, <code>template</code> or <code>get_template</code> must be defined.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def get_template_name(self, context: Context) -&gt; Optional[str]:\n    \"\"\"\n    Filepath to the Django template associated with this component.\n\n    The filepath must be relative to either the file where the component class was defined,\n    or one of the roots of `STATIFILES_DIRS`.\n\n    Only one of `template_name`, `get_template_name`, `template` or `get_template` must be defined.\n    \"\"\"\n    return None\n</code></pre>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.inject","title":"inject","text":"<pre><code>inject(key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Use this method to retrieve the data that was passed to a <code>{% provide %}</code> tag with the corresponding key.</p> <p>To retrieve the data, <code>inject()</code> must be called inside a component that's inside the <code>{% provide %}</code> tag.</p> <p>You may also pass a default that will be used if the <code>provide</code> tag with given key was NOT found.</p> <p>This method mut be used inside the <code>get_context_data()</code> method and raises an error if called elsewhere.</p> <p>Example:</p> <p>Given this template: <pre><code>{% provide \"provider\" hello=\"world\" %}\n    {% component \"my_comp\" %}\n    {% endcomponent %}\n{% endprovide %}\n</code></pre></p> <p>And given this definition of \"my_comp\" component: <pre><code>from django_components import Component, register\n\n@register(\"my_comp\")\nclass MyComp(Component):\n    template = \"hi {{ data.hello }}!\"\n    def get_context_data(self):\n        data = self.inject(\"provider\")\n        return {\"data\": data}\n</code></pre></p> <p>This renders into: <pre><code>hi world!\n</code></pre></p> <p>As the <code>{{ data.hello }}</code> is taken from the \"provider\".</p> Source code in <code>src/django_components/component.py</code> <pre><code>def inject(self, key: str, default: Optional[Any] = None) -&gt; Any:\n    \"\"\"\n    Use this method to retrieve the data that was passed to a `{% provide %}` tag\n    with the corresponding key.\n\n    To retrieve the data, `inject()` must be called inside a component that's\n    inside the `{% provide %}` tag.\n\n    You may also pass a default that will be used if the `provide` tag with given\n    key was NOT found.\n\n    This method mut be used inside the `get_context_data()` method and raises\n    an error if called elsewhere.\n\n    Example:\n\n    Given this template:\n    ```django\n    {% provide \"provider\" hello=\"world\" %}\n        {% component \"my_comp\" %}\n        {% endcomponent %}\n    {% endprovide %}\n    ```\n\n    And given this definition of \"my_comp\" component:\n    ```py\n    from django_components import Component, register\n\n    @register(\"my_comp\")\n    class MyComp(Component):\n        template = \"hi {{ data.hello }}!\"\n        def get_context_data(self):\n            data = self.inject(\"provider\")\n            return {\"data\": data}\n    ```\n\n    This renders into:\n    ```\n    hi world!\n    ```\n\n    As the `{{ data.hello }}` is taken from the \"provider\".\n    \"\"\"\n    if self.input is None:\n        raise RuntimeError(\n            f\"Method 'inject()' of component '{self.name}' was called outside of 'get_context_data()'\"\n        )\n\n    return get_injected_context_var(self.name, self.input.context, key, default)\n</code></pre>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.on_render_after","title":"on_render_after","text":"<pre><code>on_render_after(context: Context, template: Template, content: str) -&gt; Optional[SlotResult]\n</code></pre> <p>Hook that runs just after the component's template was rendered. It receives the rendered output as the last argument.</p> <p>You can use this hook to access the context or the template, but modifying them won't have any effect.</p> <p>To override the content that gets rendered, you can return a string or SafeString from this hook.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_after(self, context: Context, template: Template, content: str) -&gt; Optional[SlotResult]:\n    \"\"\"\n    Hook that runs just after the component's template was rendered.\n    It receives the rendered output as the last argument.\n\n    You can use this hook to access the context or the template, but modifying\n    them won't have any effect.\n\n    To override the content that gets rendered, you can return a string or SafeString\n    from this hook.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.on_render_before","title":"on_render_before","text":"<pre><code>on_render_before(context: Context, template: Template) -&gt; None\n</code></pre> <p>Hook that runs just before the component's template is rendered.</p> <p>You can use this hook to access or modify the context or the template.</p> Source code in <code>src/django_components/component.py</code> <pre><code>def on_render_before(self, context: Context, template: Template) -&gt; None:\n    \"\"\"\n    Hook that runs just before the component's template is rendered.\n\n    You can use this hook to access or modify the context or the template.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.render","title":"render  <code>classmethod</code>","text":"<pre><code>render(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str\n</code></pre> <p>Render the component into a string.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag. - <code>render_dependencies</code> - Set this to <code>False</code> if you want to insert the resulting HTML into another component.</p> <p>Example: <pre><code>MyComponent.render(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    type: RenderType = \"document\",\n    render_dependencies: bool = True,\n) -&gt; str:\n    \"\"\"\n    Render the component into a string.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n    - `render_dependencies` - Set this to `False` if you want to insert the resulting HTML into another component.\n\n    Example:\n    ```py\n    MyComponent.render(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n    )\n    ```\n    \"\"\"\n    # This method may be called as class method or as instance method.\n    # If called as class method, create a new instance.\n    if isinstance(cls, Component):\n        comp: Component = cls\n    else:\n        comp = cls()\n\n    return comp._render(context, args, kwargs, slots, escape_slots_content, type, render_dependencies)\n</code></pre>"},{"location":"reference/django_components/components/dynamic/#django_components.components.dynamic.DynamicComponent.render_to_response","title":"render_to_response  <code>classmethod</code>","text":"<pre><code>render_to_response(\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any\n) -&gt; HttpResponse\n</code></pre> <p>Render the component and wrap the content in the response class.</p> <p>The response class is taken from <code>Component.response_class</code>. Defaults to <code>django.http.HttpResponse</code>.</p> <p>This is the interface for the <code>django.views.View</code> class which allows us to use components as Django views with <code>component.as_view()</code>.</p> <p>Inputs: - <code>args</code> - Positional args for the component. This is the same as calling the component   as <code>{% component \"my_comp\" arg1 arg2 ... %}</code> - <code>kwargs</code> - Kwargs for the component. This is the same as calling the component   as <code>{% component \"my_comp\" key1=val1 key2=val2 ... %}</code> - <code>slots</code> - Component slot fills. This is the same as pasing <code>{% fill %}</code> tags to the component.     Accepts a dictionary of <code>{ slot_name: slot_content }</code> where <code>slot_content</code> can be a string     or render function. - <code>escape_slots_content</code> - Whether the content from <code>slots</code> should be escaped. - <code>context</code> - A context (dictionary or Django's Context) within which the component   is rendered. The keys on the context can be accessed from within the template.     - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via       component's args and kwargs. - <code>type</code> - Configure how to handle JS and CSS dependencies.     - <code>\"document\"</code> (default) - JS dependencies are inserted into <code>{% component_js_dependencies %}</code>,       or to the end of the <code>&lt;body&gt;</code> tag. CSS dependencies are inserted into       <code>{% component_css_dependencies %}</code>, or the end of the <code>&lt;head&gt;</code> tag.</p> <p>Any additional args and kwargs are passed to the <code>response_class</code>.</p> <p>Example: <pre><code>MyComponent.render_to_response(\n    args=[1, \"two\", {}],\n    kwargs={\n        \"key\": 123,\n    },\n    slots={\n        \"header\": 'STATIC TEXT HERE',\n        \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n    },\n    escape_slots_content=False,\n    # HttpResponse input\n    status=201,\n    headers={...},\n)\n# HttpResponse(content=..., status=201, headers=...)\n</code></pre></p> Source code in <code>src/django_components/component.py</code> <pre><code>@classmethod\ndef render_to_response(\n    cls,\n    context: Optional[Union[Dict[str, Any], Context]] = None,\n    slots: Optional[SlotsType] = None,\n    escape_slots_content: bool = True,\n    args: Optional[ArgsType] = None,\n    kwargs: Optional[KwargsType] = None,\n    type: RenderType = \"document\",\n    *response_args: Any,\n    **response_kwargs: Any,\n) -&gt; HttpResponse:\n    \"\"\"\n    Render the component and wrap the content in the response class.\n\n    The response class is taken from `Component.response_class`. Defaults to `django.http.HttpResponse`.\n\n    This is the interface for the `django.views.View` class which allows us to\n    use components as Django views with `component.as_view()`.\n\n    Inputs:\n    - `args` - Positional args for the component. This is the same as calling the component\n      as `{% component \"my_comp\" arg1 arg2 ... %}`\n    - `kwargs` - Kwargs for the component. This is the same as calling the component\n      as `{% component \"my_comp\" key1=val1 key2=val2 ... %}`\n    - `slots` - Component slot fills. This is the same as pasing `{% fill %}` tags to the component.\n        Accepts a dictionary of `{ slot_name: slot_content }` where `slot_content` can be a string\n        or render function.\n    - `escape_slots_content` - Whether the content from `slots` should be escaped.\n    - `context` - A context (dictionary or Django's Context) within which the component\n      is rendered. The keys on the context can be accessed from within the template.\n        - NOTE: In \"isolated\" mode, context is NOT accessible, and data MUST be passed via\n          component's args and kwargs.\n    - `type` - Configure how to handle JS and CSS dependencies.\n        - `\"document\"` (default) - JS dependencies are inserted into `{% component_js_dependencies %}`,\n          or to the end of the `&lt;body&gt;` tag. CSS dependencies are inserted into\n          `{% component_css_dependencies %}`, or the end of the `&lt;head&gt;` tag.\n\n    Any additional args and kwargs are passed to the `response_class`.\n\n    Example:\n    ```py\n    MyComponent.render_to_response(\n        args=[1, \"two\", {}],\n        kwargs={\n            \"key\": 123,\n        },\n        slots={\n            \"header\": 'STATIC TEXT HERE',\n            \"footer\": lambda ctx, slot_kwargs, slot_ref: f'CTX: {ctx['hello']} SLOT_DATA: {slot_kwargs['abc']}',\n        },\n        escape_slots_content=False,\n        # HttpResponse input\n        status=201,\n        headers={...},\n    )\n    # HttpResponse(content=..., status=201, headers=...)\n    ```\n    \"\"\"\n    content = cls.render(\n        args=args,\n        kwargs=kwargs,\n        context=context,\n        slots=slots,\n        escape_slots_content=escape_slots_content,\n        type=type,\n        render_dependencies=True,\n    )\n    return cls.response_class(content, *response_args, **response_kwargs)\n</code></pre>"},{"location":"reference/django_components/context/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> context","text":""},{"location":"reference/django_components/context/#django_components.context","title":"context","text":"<p>This file centralizes various ways we use Django's Context class pass data across components, nodes, slots, and contexts.</p> <p>You can think of the Context as our storage system.</p> <p>Functions:</p> <ul> <li> <code>copy_forloop_context</code>             \u2013              <p>Forward the info about the current loop</p> </li> <li> <code>get_injected_context_var</code>             \u2013              <p>Retrieve a 'provided' field. The field MUST have been previously 'provided'</p> </li> <li> <code>set_provided_context_var</code>             \u2013              <p>'Provide' given data under given key. In other words, this data can be retrieved</p> </li> </ul>"},{"location":"reference/django_components/context/#django_components.context.copy_forloop_context","title":"copy_forloop_context","text":"<pre><code>copy_forloop_context(from_context: Context, to_context: Context) -&gt; None\n</code></pre> <p>Forward the info about the current loop</p> Source code in <code>src/django_components/context.py</code> <pre><code>def copy_forloop_context(from_context: Context, to_context: Context) -&gt; None:\n    \"\"\"Forward the info about the current loop\"\"\"\n    # Note that the ForNode (which implements for loop behavior) does not\n    # only add the `forloop` key, but also keys corresponding to the loop elements\n    # So if the loop syntax is `{% for my_val in my_lists %}`, then ForNode also\n    # sets a `my_val` key.\n    # For this reason, instead of copying individual keys, we copy the whole stack layer\n    # set by ForNode.\n    if \"forloop\" in from_context:\n        forloop_dict_index = find_last_index(from_context.dicts, lambda d: \"forloop\" in d)\n        to_context.update(from_context.dicts[forloop_dict_index])\n</code></pre>"},{"location":"reference/django_components/context/#django_components.context.get_injected_context_var","title":"get_injected_context_var","text":"<pre><code>get_injected_context_var(component_name: str, context: Context, key: str, default: Optional[Any] = None) -&gt; Any\n</code></pre> <p>Retrieve a 'provided' field. The field MUST have been previously 'provided' by the component's ancestors using the <code>{% provide %}</code> template tag.</p> Source code in <code>src/django_components/context.py</code> <pre><code>def get_injected_context_var(\n    component_name: str,\n    context: Context,\n    key: str,\n    default: Optional[Any] = None,\n) -&gt; Any:\n    \"\"\"\n    Retrieve a 'provided' field. The field MUST have been previously 'provided'\n    by the component's ancestors using the `{% provide %}` template tag.\n    \"\"\"\n    # NOTE: For simplicity, we keep the provided values directly on the context.\n    # This plays nicely with Django's Context, which behaves like a stack, so \"newer\"\n    # values overshadow the \"older\" ones.\n    internal_key = _INJECT_CONTEXT_KEY_PREFIX + key\n\n    # Return provided value if found\n    if internal_key in context:\n        return context[internal_key]\n\n    # If a default was given, return that\n    if default is not None:\n        return default\n\n    # Otherwise raise error\n    raise KeyError(\n        f\"Component '{component_name}' tried to inject a variable '{key}' before it was provided.\"\n        f\" To fix this, make sure that at least one ancestor of component '{component_name}' has\"\n        f\" the variable '{key}' in their 'provide' attribute.\"\n    )\n</code></pre>"},{"location":"reference/django_components/context/#django_components.context.set_provided_context_var","title":"set_provided_context_var","text":"<pre><code>set_provided_context_var(context: Context, key: str, provided_kwargs: Dict[str, Any]) -&gt; None\n</code></pre> <p>'Provide' given data under given key. In other words, this data can be retrieved using <code>self.inject(key)</code> inside of <code>get_context_data()</code> method of components that are nested inside the <code>{% provide %}</code> tag.</p> Source code in <code>src/django_components/context.py</code> <pre><code>def set_provided_context_var(\n    context: Context,\n    key: str,\n    provided_kwargs: Dict[str, Any],\n) -&gt; None:\n    \"\"\"\n    'Provide' given data under given key. In other words, this data can be retrieved\n    using `self.inject(key)` inside of `get_context_data()` method of components that\n    are nested inside the `{% provide %}` tag.\n    \"\"\"\n    # NOTE: We raise TemplateSyntaxError since this func should be called only from\n    # within template.\n    if not key:\n        raise TemplateSyntaxError(\n            \"Provide tag received an empty string. Key must be non-empty and a valid identifier.\"\n        )\n    if not key.isidentifier():\n        raise TemplateSyntaxError(\n            \"Provide tag received a non-identifier string. Key must be non-empty and a valid identifier.\"\n        )\n\n    # We turn the kwargs into a NamedTuple so that the object that's \"provided\"\n    # is immutable. This ensures that the data returned from `inject` will always\n    # have all the keys that were passed to the `provide` tag.\n    tpl_cls = namedtuple(\"DepInject\", provided_kwargs.keys())  # type: ignore[misc]\n    payload = tpl_cls(**provided_kwargs)\n\n    internal_key = _INJECT_CONTEXT_KEY_PREFIX + key\n    context[internal_key] = payload\n</code></pre>"},{"location":"reference/django_components/dependencies/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> dependencies","text":""},{"location":"reference/django_components/dependencies/#django_components.dependencies","title":"dependencies","text":"<p>All code related to management of component dependencies (JS and CSS scripts)</p> <p>Modules:</p> <ul> <li> <code>types</code>           \u2013            <p>Helper types for IDEs.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>ComponentDependencyMiddleware</code>           \u2013            <p>Middleware that inserts CSS/JS dependencies for all rendered</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>render_dependencies</code>             \u2013              <p>Given a string that contains parts that were rendered by components,</p> </li> </ul>"},{"location":"reference/django_components/dependencies/#django_components.dependencies.ComponentDependencyMiddleware","title":"ComponentDependencyMiddleware","text":"<pre><code>ComponentDependencyMiddleware(get_response: Callable[[HttpRequest], HttpResponse])\n</code></pre> <p>Middleware that inserts CSS/JS dependencies for all rendered components at points marked with template tags.</p> Source code in <code>src/django_components/dependencies.py</code> <pre><code>def __init__(self, get_response: \"Callable[[HttpRequest], HttpResponse]\") -&gt; None:\n    self.get_response = get_response\n\n    # NOTE: Required to work with async\n    if iscoroutinefunction(self.get_response):\n        markcoroutinefunction(self)\n</code></pre>"},{"location":"reference/django_components/dependencies/#django_components.dependencies.render_dependencies","title":"render_dependencies","text":"<pre><code>render_dependencies(content: TContent, type: RenderType = 'document') -&gt; TContent\n</code></pre> <p>Given a string that contains parts that were rendered by components, this function inserts all used JS and CSS.</p> <p>By default, the string is parsed as an HTML and: - CSS is inserted at the end of <code>&lt;head&gt;</code> (if present) - JS is inserted at the end of <code>&lt;body&gt;</code> (if present)</p> <p>If you used <code>{% component_js_dependencies %}</code> or <code>{% component_css_dependencies %}</code>, then the JS and CSS will be inserted only at these locations.</p> <p>Example: <pre><code>def my_view(request):\n    template = Template('''\n        {% load components %}\n        &lt;!doctype html&gt;\n        &lt;html&gt;\n            &lt;head&gt;&lt;/head&gt;\n            &lt;body&gt;\n                &lt;h1&gt;{{ table_name }}&lt;/h1&gt;\n                {% component \"table\" name=table_name / %}\n            &lt;/body&gt;\n        &lt;/html&gt;\n    ''')\n\n    html = template.render(\n        Context({\n            \"table_name\": request.GET[\"name\"],\n        })\n    )\n\n    # This inserts components' JS and CSS\n    processed_html = render_dependencies(html)\n\n    return HttpResponse(processed_html)\n</code></pre></p> Source code in <code>src/django_components/dependencies.py</code> <pre><code>def render_dependencies(content: TContent, type: RenderType = \"document\") -&gt; TContent:\n    \"\"\"\n    Given a string that contains parts that were rendered by components,\n    this function inserts all used JS and CSS.\n\n    By default, the string is parsed as an HTML and:\n    - CSS is inserted at the end of `&lt;head&gt;` (if present)\n    - JS is inserted at the end of `&lt;body&gt;` (if present)\n\n    If you used `{% component_js_dependencies %}` or `{% component_css_dependencies %}`,\n    then the JS and CSS will be inserted only at these locations.\n\n    Example:\n    ```python\n    def my_view(request):\n        template = Template('''\n            {% load components %}\n            &lt;!doctype html&gt;\n            &lt;html&gt;\n                &lt;head&gt;&lt;/head&gt;\n                &lt;body&gt;\n                    &lt;h1&gt;{{ table_name }}&lt;/h1&gt;\n                    {% component \"table\" name=table_name / %}\n                &lt;/body&gt;\n            &lt;/html&gt;\n        ''')\n\n        html = template.render(\n            Context({\n                \"table_name\": request.GET[\"name\"],\n            })\n        )\n\n        # This inserts components' JS and CSS\n        processed_html = render_dependencies(html)\n\n        return HttpResponse(processed_html)\n    ```\n    \"\"\"\n    is_safestring = isinstance(content, SafeString)\n\n    if isinstance(content, str):\n        content_ = content.encode()\n    else:\n        content_ = cast(bytes, content)\n\n    content_, js_dependencies, css_dependencies = _process_dep_declarations(content_, type)\n\n    # Replace the placeholders with the actual content\n    did_find_js_placeholder = False\n    did_find_css_placeholder = False\n\n    def on_replace_match(match: \"re.Match[bytes]\") -&gt; bytes:\n        nonlocal did_find_css_placeholder\n        nonlocal did_find_js_placeholder\n\n        if match[0] == CSS_PLACEHOLDER_BYTES:\n            replacement = css_dependencies\n            did_find_css_placeholder = True\n        elif match[0] == JS_PLACEHOLDER_BYTES:\n            replacement = js_dependencies\n            did_find_js_placeholder = True\n        else:\n            raise RuntimeError(\n                \"Unexpected error: Regex for component dependencies processing\"\n                f\" matched unknown string '{match[0].decode()}'\"\n            )\n        return replacement\n\n    content_ = PLACEHOLDER_REGEX.sub(on_replace_match, content_)\n\n    # By default, if user didn't specify any `{% component_dependencies %}`,\n    # then try to insert the JS scripts at the end of &lt;body&gt; and CSS sheets at the end\n    # of &lt;head&gt;\n    if type == \"document\" and (not did_find_js_placeholder or not did_find_css_placeholder):\n        tree = parse_document_or_nodes(content_.decode())\n\n        if isinstance(tree, LexborHTMLParser):\n            did_modify_html = False\n\n            if not did_find_css_placeholder and tree.head:\n                css_elems = parse_multiroot_html(css_dependencies.decode())\n                for css_elem in css_elems:\n                    tree.head.insert_child(css_elem)  # type: ignore # TODO: Update to selectolax 0.3.25\n                did_modify_html = True\n\n            if not did_find_js_placeholder and tree.body:\n                js_elems = parse_multiroot_html(js_dependencies.decode())\n                for js_elem in js_elems:\n                    tree.body.insert_child(js_elem)  # type: ignore # TODO: Update to selectolax 0.3.25\n                did_modify_html = True\n\n            transformed = cast(str, tree.html)\n            if did_modify_html:\n                content_ = transformed.encode()\n\n    # Return the same type as we were given\n    output = content_.decode() if isinstance(content, str) else content_\n    output = mark_safe(output) if is_safestring else output\n    return cast(TContent, output)\n</code></pre>"},{"location":"reference/django_components/expression/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> expression","text":""},{"location":"reference/django_components/expression/#django_components.expression","title":"expression","text":"<p>Classes:</p> <ul> <li> <code>Operator</code>           \u2013            <p>Operator describes something that somehow changes the inputs</p> </li> <li> <code>SpreadOperator</code>           \u2013            <p>Operator that inserts one or more kwargs at the specified location.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>process_aggregate_kwargs</code>             \u2013              <p>This function aggregates \"prefixed\" kwargs into dicts. \"Prefixed\" kwargs</p> </li> </ul>"},{"location":"reference/django_components/expression/#django_components.expression.Operator","title":"Operator","text":"<p>               Bases: <code>ABC</code></p> <p>Operator describes something that somehow changes the inputs to template tags (the <code>{% %}</code>).</p> <p>For example, a SpreadOperator inserts one or more kwargs at the specified location.</p>"},{"location":"reference/django_components/expression/#django_components.expression.SpreadOperator","title":"SpreadOperator","text":"<pre><code>SpreadOperator(expr: Expression)\n</code></pre> <p>               Bases: <code>Operator</code></p> <p>Operator that inserts one or more kwargs at the specified location.</p> Source code in <code>src/django_components/expression.py</code> <pre><code>def __init__(self, expr: Expression) -&gt; None:\n    self.expr = expr\n</code></pre>"},{"location":"reference/django_components/expression/#django_components.expression.process_aggregate_kwargs","title":"process_aggregate_kwargs","text":"<pre><code>process_aggregate_kwargs(kwargs: Mapping[str, Any]) -&gt; Dict[str, Any]\n</code></pre> <p>This function aggregates \"prefixed\" kwargs into dicts. \"Prefixed\" kwargs start with some prefix delimited with <code>:</code> (e.g. <code>attrs:</code>).</p> <p>Example: <pre><code>process_component_kwargs({\"abc:one\": 1, \"abc:two\": 2, \"def:three\": 3, \"four\": 4})\n# {\"abc\": {\"one\": 1, \"two\": 2}, \"def\": {\"three\": 3}, \"four\": 4}\n</code></pre></p> <p>We want to support a use case similar to Vue's fallthrough attributes. In other words, where a component author can designate a prop (input) which is a dict and which will be rendered as HTML attributes.</p> <p>This is useful for allowing component users to tweak styling or add event handling to the underlying HTML. E.g.:</p> <p><code>class=\"pa-4 d-flex text-black\"</code> or <code>@click.stop=\"alert('clicked!')\"</code></p> <p>So if the prop is <code>attrs</code>, and the component is called like so: <pre><code>{% component \"my_comp\" attrs=attrs %}\n</code></pre></p> <p>then, if <code>attrs</code> is: <pre><code>{\"class\": \"text-red pa-4\", \"@click\": \"dispatch('my_event', 123)\"}\n</code></pre></p> <p>and the component template is: <pre><code>&lt;div {% html_attrs attrs add:class=\"extra-class\" %}&gt;&lt;/div&gt;\n</code></pre></p> <p>Then this renders: <pre><code>&lt;div class=\"text-red pa-4 extra-class\" @click=\"dispatch('my_event', 123)\" &gt;&lt;/div&gt;\n</code></pre></p> <p>However, this way it is difficult for the component user to define the <code>attrs</code> variable, especially if they want to combine static and dynamic values. Because they will need to pre-process the <code>attrs</code> dict.</p> <p>So, instead, we allow to \"aggregate\" props into a dict. So all props that start with <code>attrs:</code>, like <code>attrs:class=\"text-red\"</code>, will be collected into a dict at key <code>attrs</code>.</p> <p>This provides sufficient flexiblity to make it easy for component users to provide \"fallthrough attributes\", and sufficiently easy for component authors to process that input while still being able to provide their own keys.</p> Source code in <code>src/django_components/expression.py</code> <pre><code>def process_aggregate_kwargs(kwargs: Mapping[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    This function aggregates \"prefixed\" kwargs into dicts. \"Prefixed\" kwargs\n    start with some prefix delimited with `:` (e.g. `attrs:`).\n\n    Example:\n    ```py\n    process_component_kwargs({\"abc:one\": 1, \"abc:two\": 2, \"def:three\": 3, \"four\": 4})\n    # {\"abc\": {\"one\": 1, \"two\": 2}, \"def\": {\"three\": 3}, \"four\": 4}\n    ```\n\n    ---\n\n    We want to support a use case similar to Vue's fallthrough attributes.\n    In other words, where a component author can designate a prop (input)\n    which is a dict and which will be rendered as HTML attributes.\n\n    This is useful for allowing component users to tweak styling or add\n    event handling to the underlying HTML. E.g.:\n\n    `class=\"pa-4 d-flex text-black\"` or `@click.stop=\"alert('clicked!')\"`\n\n    So if the prop is `attrs`, and the component is called like so:\n    ```django\n    {% component \"my_comp\" attrs=attrs %}\n    ```\n\n    then, if `attrs` is:\n    ```py\n    {\"class\": \"text-red pa-4\", \"@click\": \"dispatch('my_event', 123)\"}\n    ```\n\n    and the component template is:\n    ```django\n    &lt;div {% html_attrs attrs add:class=\"extra-class\" %}&gt;&lt;/div&gt;\n    ```\n\n    Then this renders:\n    ```html\n    &lt;div class=\"text-red pa-4 extra-class\" @click=\"dispatch('my_event', 123)\" &gt;&lt;/div&gt;\n    ```\n\n    However, this way it is difficult for the component user to define the `attrs`\n    variable, especially if they want to combine static and dynamic values. Because\n    they will need to pre-process the `attrs` dict.\n\n    So, instead, we allow to \"aggregate\" props into a dict. So all props that start\n    with `attrs:`, like `attrs:class=\"text-red\"`, will be collected into a dict\n    at key `attrs`.\n\n    This provides sufficient flexiblity to make it easy for component users to provide\n    \"fallthrough attributes\", and sufficiently easy for component authors to process\n    that input while still being able to provide their own keys.\n    \"\"\"\n    processed_kwargs = {}\n    nested_kwargs: Dict[str, Dict[str, Any]] = {}\n    for key, val in kwargs.items():\n        if not is_aggregate_key(key):\n            processed_kwargs[key] = val\n            continue\n\n        # NOTE: Trim off the prefix from keys\n        prefix, sub_key = key.split(\":\", 1)\n        if prefix not in nested_kwargs:\n            nested_kwargs[prefix] = {}\n        nested_kwargs[prefix][sub_key] = val\n\n    # Assign aggregated values into normal input\n    for key, val in nested_kwargs.items():\n        if key in processed_kwargs:\n            raise TemplateSyntaxError(\n                f\"Received argument '{key}' both as a regular input ({key}=...)\"\n                f\" and as an aggregate dict ('{key}:key=...'). Must be only one of the two\"\n            )\n        processed_kwargs[key] = val\n\n    return processed_kwargs\n</code></pre>"},{"location":"reference/django_components/finders/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> finders","text":""},{"location":"reference/django_components/finders/#django_components.finders","title":"finders","text":"<p>Classes:</p> <ul> <li> <code>ComponentsFileSystemFinder</code>           \u2013            <p>A static files finder based on <code>FileSystemFinder</code>.</p> </li> </ul>"},{"location":"reference/django_components/finders/#django_components.finders.ComponentsFileSystemFinder","title":"ComponentsFileSystemFinder","text":"<pre><code>ComponentsFileSystemFinder(app_names: Any = None, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>BaseFinder</code></p> <p>A static files finder based on <code>FileSystemFinder</code>.</p> <p>Differences: - This finder uses <code>COMPONENTS.dirs</code> setting to locate files instead of <code>STATICFILES_DIRS</code>. - Whether a file within <code>COMPONENTS.dirs</code> is considered a STATIC file is configured   by <code>COMPONENTS.static_files_allowed</code> and <code>COMPONENTS.static_files_forbidden</code>. - If <code>COMPONENTS.dirs</code> is not set, defaults to <code>settings.BASE_DIR / \"components\"</code></p> <p>Methods:</p> <ul> <li> <code>find</code>             \u2013              <p>Look for files in the extra locations as defined in COMPONENTS.dirs.</p> </li> <li> <code>find_location</code>             \u2013              <p>Find a requested static file in a location and return the found</p> </li> <li> <code>list</code>             \u2013              <p>List all files in all locations.</p> </li> </ul> Source code in <code>src/django_components/finders.py</code> <pre><code>def __init__(self, app_names: Any = None, *args: Any, **kwargs: Any) -&gt; None:\n    component_dirs = [str(p) for p in get_component_dirs()]\n\n    # NOTE: The rest of the __init__ is the same as `django.contrib.staticfiles.finders.FileSystemFinder`,\n    # but using our locations instead of STATICFILES_DIRS.\n\n    # List of locations with static files\n    self.locations: List[Tuple[str, str]] = []\n\n    # Maps dir paths to an appropriate storage instance\n    self.storages: Dict[str, FileSystemStorage] = {}\n    for root in component_dirs:\n        if isinstance(root, (list, tuple)):\n            prefix, root = root\n        else:\n            prefix = \"\"\n        if (prefix, root) not in self.locations:\n            self.locations.append((prefix, root))\n    for prefix, root in self.locations:\n        filesystem_storage = FileSystemStorage(location=root)\n        filesystem_storage.prefix = prefix\n        self.storages[root] = filesystem_storage\n\n    super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"reference/django_components/finders/#django_components.finders.ComponentsFileSystemFinder.find","title":"find","text":"<pre><code>find(path: str, all: bool = False) -&gt; Union[List[str], str]\n</code></pre> <p>Look for files in the extra locations as defined in COMPONENTS.dirs.</p> Source code in <code>src/django_components/finders.py</code> <pre><code>def find(self, path: str, all: bool = False) -&gt; Union[List[str], str]:\n    \"\"\"\n    Look for files in the extra locations as defined in COMPONENTS.dirs.\n    \"\"\"\n    matches: List[str] = []\n    for prefix, root in self.locations:\n        if root not in searched_locations:\n            searched_locations.append(root)\n        matched_path = self.find_location(root, path, prefix)\n        if matched_path:\n            if not all:\n                return matched_path\n            matches.append(matched_path)\n    return matches\n</code></pre>"},{"location":"reference/django_components/finders/#django_components.finders.ComponentsFileSystemFinder.find_location","title":"find_location","text":"<pre><code>find_location(root: str, path: str, prefix: Optional[str] = None) -&gt; Optional[str]\n</code></pre> <p>Find a requested static file in a location and return the found absolute path (or <code>None</code> if no match).</p> Source code in <code>src/django_components/finders.py</code> <pre><code>def find_location(self, root: str, path: str, prefix: Optional[str] = None) -&gt; Optional[str]:\n    \"\"\"\n    Find a requested static file in a location and return the found\n    absolute path (or ``None`` if no match).\n    \"\"\"\n    if prefix:\n        prefix = \"%s%s\" % (prefix, os.sep)\n        if not path.startswith(prefix):\n            return None\n        path = path.removeprefix(prefix)\n    path = safe_join(root, path)\n\n    if os.path.exists(path) and self._is_path_valid(path):\n        return path\n    return None\n</code></pre>"},{"location":"reference/django_components/finders/#django_components.finders.ComponentsFileSystemFinder.list","title":"list","text":"<pre><code>list(ignore_patterns: List[str]) -&gt; Iterable[Tuple[str, FileSystemStorage]]\n</code></pre> <p>List all files in all locations.</p> Source code in <code>src/django_components/finders.py</code> <pre><code>def list(self, ignore_patterns: List[str]) -&gt; Iterable[Tuple[str, FileSystemStorage]]:\n    \"\"\"\n    List all files in all locations.\n    \"\"\"\n    for prefix, root in self.locations:\n        # Skip nonexistent directories.\n        if os.path.isdir(root):\n            storage = self.storages[root]\n            for path in get_files(storage, ignore_patterns):\n                if self._is_path_valid(path):\n                    yield path, storage\n</code></pre>"},{"location":"reference/django_components/library/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> library","text":""},{"location":"reference/django_components/library/#django_components.library","title":"library","text":"<p>Module for interfacing with Django's Library (<code>django.template.library</code>)</p> <p>Classes:</p> <ul> <li> <code>TagProtectedError</code>           \u2013            <p>The way the <code>TagFormatter</code> works is that,</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>PROTECTED_TAGS</code>           \u2013            <p>These are the names that users cannot choose for their components,</p> </li> </ul>"},{"location":"reference/django_components/library/#django_components.library.PROTECTED_TAGS","title":"PROTECTED_TAGS  <code>module-attribute</code>","text":"<pre><code>PROTECTED_TAGS = ['component_css_dependencies', 'component_js_dependencies', 'fill', 'html_attrs', 'provide', 'slot']\n</code></pre> <p>These are the names that users cannot choose for their components, as they would conflict with other tags in the Library.</p>"},{"location":"reference/django_components/library/#django_components.library.TagProtectedError","title":"TagProtectedError","text":"<p>               Bases: <code>Exception</code></p> <p>The way the <code>TagFormatter</code> works is that, based on which start and end tags are used for rendering components, the <code>ComponentRegistry</code> behind the scenes un-/registers the template tags with the associated instance of Django's <code>Library</code>.</p> <p>In other words, if I have registered a component <code>\"table\"</code>, and I use the shorthand syntax:</p> <pre><code>{% table ... %}\n{% endtable %}\n</code></pre> <p>Then <code>ComponentRegistry</code> registers the tag <code>table</code> onto the Django's Library instance.</p> <p>However, that means that if we registered a component <code>\"slot\"</code>, then we would overwrite the <code>{% slot %}</code> tag from django_components.</p> <p>Thus, this exception is raised when a component is attempted to be registered under a forbidden name, such that it would overwrite one of django_component's own template tags.</p>"},{"location":"reference/django_components/management/","title":"Index","text":""},{"location":"reference/django_components/management/#django_components.management","title":"management","text":"<p>Modules:</p> <ul> <li> <code>commands</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/management/#django_components.management.commands","title":"commands","text":"<p>Modules:</p> <ul> <li> <code>startcomponent</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/management/#django_components.management.commands.startcomponent","title":"startcomponent","text":"<p>Classes:</p> <ul> <li> <code>Command</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/management/#django_components.management.commands.startcomponent--management-command-usage","title":"Management Command Usage","text":""},{"location":"reference/django_components/management/#django_components.management.commands.startcomponent.Command","title":"Command","text":"<p>               Bases: <code>BaseCommand</code></p>"},{"location":"reference/django_components/management/#django_components.management.commands.startcomponent.Command--management-command-usage","title":"Management Command Usage","text":"<p>To use the command, run the following command in your terminal:</p> <pre><code>python manage.py startcomponent &lt;name&gt; --path &lt;path&gt; --js &lt;js_filename&gt; --css &lt;css_filename&gt; --template &lt;template_filename&gt; --force --verbose --dry-run\n</code></pre> <p>Replace <code>&lt;name&gt;</code>, <code>&lt;path&gt;</code>, <code>&lt;js_filename&gt;</code>, <code>&lt;css_filename&gt;</code>, and <code>&lt;template_filename&gt;</code> with your desired values.</p>"},{"location":"reference/django_components/management/#django_components.management.commands.startcomponent.Command--management-command-examples","title":"Management Command Examples","text":"<p>Here are some examples of how you can use the command:</p>"},{"location":"reference/django_components/management/#django_components.management.commands.startcomponent.Command--creating-a-component-with-default-settings","title":"Creating a Component with Default Settings","text":"<p>To create a component with the default settings, you only need to provide the name of the component:</p> <pre><code>python manage.py startcomponent my_component\n</code></pre> <p>This will create a new component named <code>my_component</code> in the <code>components</code> directory of your Django project. The JavaScript, CSS, and template files will be named <code>script.js</code>, <code>style.css</code>, and <code>template.html</code>, respectively.</p>"},{"location":"reference/django_components/management/#django_components.management.commands.startcomponent.Command--creating-a-component-with-custom-settings","title":"Creating a Component with Custom Settings","text":"<p>You can also create a component with custom settings by providing additional arguments:</p> <pre><code>python manage.py startcomponent new_component --path my_components --js my_script.js --css my_style.css --template my_template.html\n</code></pre> <p>This will create a new component named <code>new_component</code> in the <code>my_components</code> directory. The JavaScript, CSS, and template files will be named <code>my_script.js</code>, <code>my_style.css</code>, and <code>my_template.html</code>, respectively.</p>"},{"location":"reference/django_components/management/#django_components.management.commands.startcomponent.Command--overwriting-an-existing-component","title":"Overwriting an Existing Component","text":"<p>If you want to overwrite an existing component, you can use the <code>--force</code> option:</p> <pre><code>python manage.py startcomponent my_component --force\n</code></pre> <p>This will overwrite the existing <code>my_component</code> if it exists.</p>"},{"location":"reference/django_components/management/#django_components.management.commands.startcomponent.Command--simulating-component-creation","title":"Simulating Component Creation","text":"<p>If you want to simulate the creation of a component without actually creating any files, you can use the <code>--dry-run</code> option:</p> <pre><code>python manage.py startcomponent my_component --dry-run\n</code></pre> <p>This will simulate the creation of <code>my_component</code> without creating any files.</p>"},{"location":"reference/django_components/management/commands/","title":"Index","text":""},{"location":"reference/django_components/management/commands/#django_components.management.commands","title":"commands","text":"<p>Modules:</p> <ul> <li> <code>startcomponent</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/management/commands/#django_components.management.commands.startcomponent","title":"startcomponent","text":"<p>Classes:</p> <ul> <li> <code>Command</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/management/commands/#django_components.management.commands.startcomponent--management-command-usage","title":"Management Command Usage","text":""},{"location":"reference/django_components/management/commands/#django_components.management.commands.startcomponent.Command","title":"Command","text":"<p>               Bases: <code>BaseCommand</code></p>"},{"location":"reference/django_components/management/commands/#django_components.management.commands.startcomponent.Command--management-command-usage","title":"Management Command Usage","text":"<p>To use the command, run the following command in your terminal:</p> <pre><code>python manage.py startcomponent &lt;name&gt; --path &lt;path&gt; --js &lt;js_filename&gt; --css &lt;css_filename&gt; --template &lt;template_filename&gt; --force --verbose --dry-run\n</code></pre> <p>Replace <code>&lt;name&gt;</code>, <code>&lt;path&gt;</code>, <code>&lt;js_filename&gt;</code>, <code>&lt;css_filename&gt;</code>, and <code>&lt;template_filename&gt;</code> with your desired values.</p>"},{"location":"reference/django_components/management/commands/#django_components.management.commands.startcomponent.Command--management-command-examples","title":"Management Command Examples","text":"<p>Here are some examples of how you can use the command:</p>"},{"location":"reference/django_components/management/commands/#django_components.management.commands.startcomponent.Command--creating-a-component-with-default-settings","title":"Creating a Component with Default Settings","text":"<p>To create a component with the default settings, you only need to provide the name of the component:</p> <pre><code>python manage.py startcomponent my_component\n</code></pre> <p>This will create a new component named <code>my_component</code> in the <code>components</code> directory of your Django project. The JavaScript, CSS, and template files will be named <code>script.js</code>, <code>style.css</code>, and <code>template.html</code>, respectively.</p>"},{"location":"reference/django_components/management/commands/#django_components.management.commands.startcomponent.Command--creating-a-component-with-custom-settings","title":"Creating a Component with Custom Settings","text":"<p>You can also create a component with custom settings by providing additional arguments:</p> <pre><code>python manage.py startcomponent new_component --path my_components --js my_script.js --css my_style.css --template my_template.html\n</code></pre> <p>This will create a new component named <code>new_component</code> in the <code>my_components</code> directory. The JavaScript, CSS, and template files will be named <code>my_script.js</code>, <code>my_style.css</code>, and <code>my_template.html</code>, respectively.</p>"},{"location":"reference/django_components/management/commands/#django_components.management.commands.startcomponent.Command--overwriting-an-existing-component","title":"Overwriting an Existing Component","text":"<p>If you want to overwrite an existing component, you can use the <code>--force</code> option:</p> <pre><code>python manage.py startcomponent my_component --force\n</code></pre> <p>This will overwrite the existing <code>my_component</code> if it exists.</p>"},{"location":"reference/django_components/management/commands/#django_components.management.commands.startcomponent.Command--simulating-component-creation","title":"Simulating Component Creation","text":"<p>If you want to simulate the creation of a component without actually creating any files, you can use the <code>--dry-run</code> option:</p> <pre><code>python manage.py startcomponent my_component --dry-run\n</code></pre> <p>This will simulate the creation of <code>my_component</code> without creating any files.</p>"},{"location":"reference/django_components/management/commands/startcomponent/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> startcomponent","text":""},{"location":"reference/django_components/management/commands/startcomponent/#django_components.management.commands.startcomponent","title":"startcomponent","text":"<p>Classes:</p> <ul> <li> <code>Command</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/management/commands/startcomponent/#django_components.management.commands.startcomponent--management-command-usage","title":"Management Command Usage","text":""},{"location":"reference/django_components/management/commands/startcomponent/#django_components.management.commands.startcomponent.Command","title":"Command","text":"<p>               Bases: <code>BaseCommand</code></p>"},{"location":"reference/django_components/management/commands/startcomponent/#django_components.management.commands.startcomponent.Command--management-command-usage","title":"Management Command Usage","text":"<p>To use the command, run the following command in your terminal:</p> <pre><code>python manage.py startcomponent &lt;name&gt; --path &lt;path&gt; --js &lt;js_filename&gt; --css &lt;css_filename&gt; --template &lt;template_filename&gt; --force --verbose --dry-run\n</code></pre> <p>Replace <code>&lt;name&gt;</code>, <code>&lt;path&gt;</code>, <code>&lt;js_filename&gt;</code>, <code>&lt;css_filename&gt;</code>, and <code>&lt;template_filename&gt;</code> with your desired values.</p>"},{"location":"reference/django_components/management/commands/startcomponent/#django_components.management.commands.startcomponent.Command--management-command-examples","title":"Management Command Examples","text":"<p>Here are some examples of how you can use the command:</p>"},{"location":"reference/django_components/management/commands/startcomponent/#django_components.management.commands.startcomponent.Command--creating-a-component-with-default-settings","title":"Creating a Component with Default Settings","text":"<p>To create a component with the default settings, you only need to provide the name of the component:</p> <pre><code>python manage.py startcomponent my_component\n</code></pre> <p>This will create a new component named <code>my_component</code> in the <code>components</code> directory of your Django project. The JavaScript, CSS, and template files will be named <code>script.js</code>, <code>style.css</code>, and <code>template.html</code>, respectively.</p>"},{"location":"reference/django_components/management/commands/startcomponent/#django_components.management.commands.startcomponent.Command--creating-a-component-with-custom-settings","title":"Creating a Component with Custom Settings","text":"<p>You can also create a component with custom settings by providing additional arguments:</p> <pre><code>python manage.py startcomponent new_component --path my_components --js my_script.js --css my_style.css --template my_template.html\n</code></pre> <p>This will create a new component named <code>new_component</code> in the <code>my_components</code> directory. The JavaScript, CSS, and template files will be named <code>my_script.js</code>, <code>my_style.css</code>, and <code>my_template.html</code>, respectively.</p>"},{"location":"reference/django_components/management/commands/startcomponent/#django_components.management.commands.startcomponent.Command--overwriting-an-existing-component","title":"Overwriting an Existing Component","text":"<p>If you want to overwrite an existing component, you can use the <code>--force</code> option:</p> <pre><code>python manage.py startcomponent my_component --force\n</code></pre> <p>This will overwrite the existing <code>my_component</code> if it exists.</p>"},{"location":"reference/django_components/management/commands/startcomponent/#django_components.management.commands.startcomponent.Command--simulating-component-creation","title":"Simulating Component Creation","text":"<p>If you want to simulate the creation of a component without actually creating any files, you can use the <code>--dry-run</code> option:</p> <pre><code>python manage.py startcomponent my_component --dry-run\n</code></pre> <p>This will simulate the creation of <code>my_component</code> without creating any files.</p>"},{"location":"reference/django_components/management/commands/upgradecomponent/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> upgradecomponent","text":""},{"location":"reference/django_components/management/commands/upgradecomponent/#django_components.management.commands.upgradecomponent","title":"upgradecomponent","text":""},{"location":"reference/django_components/middleware/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> middleware","text":""},{"location":"reference/django_components/middleware/#django_components.middleware","title":"middleware","text":"<p>Classes:</p> <ul> <li> <code>ComponentDependencyMiddleware</code>           \u2013            <p>Middleware that inserts CSS/JS dependencies for all rendered</p> </li> </ul>"},{"location":"reference/django_components/middleware/#django_components.middleware.ComponentDependencyMiddleware","title":"ComponentDependencyMiddleware","text":"<pre><code>ComponentDependencyMiddleware(get_response: Callable[[HttpRequest], HttpResponse])\n</code></pre> <p>Middleware that inserts CSS/JS dependencies for all rendered components at points marked with template tags.</p> Source code in <code>src/django_components/dependencies.py</code> <pre><code>def __init__(self, get_response: \"Callable[[HttpRequest], HttpResponse]\") -&gt; None:\n    self.get_response = get_response\n\n    # NOTE: Required to work with async\n    if iscoroutinefunction(self.get_response):\n        markcoroutinefunction(self)\n</code></pre>"},{"location":"reference/django_components/node/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> node","text":""},{"location":"reference/django_components/node/#django_components.node","title":"node","text":"<p>Classes:</p> <ul> <li> <code>BaseNode</code>           \u2013            <p>Shared behavior for our subclasses of Django's <code>Node</code></p> </li> </ul>"},{"location":"reference/django_components/node/#django_components.node.BaseNode","title":"BaseNode","text":"<pre><code>BaseNode(\n    nodelist: Optional[NodeList] = None,\n    node_id: Optional[str] = None,\n    args: Optional[List[Expression]] = None,\n    kwargs: Optional[RuntimeKwargs] = None,\n)\n</code></pre> <p>               Bases: <code>Node</code></p> <p>Shared behavior for our subclasses of Django's <code>Node</code></p> Source code in <code>src/django_components/node.py</code> <pre><code>def __init__(\n    self,\n    nodelist: Optional[NodeList] = None,\n    node_id: Optional[str] = None,\n    args: Optional[List[Expression]] = None,\n    kwargs: Optional[RuntimeKwargs] = None,\n):\n    self.nodelist = nodelist or NodeList()\n    self.node_id = node_id or gen_id()\n    self.args = args or []\n    self.kwargs = kwargs or RuntimeKwargs({})\n</code></pre>"},{"location":"reference/django_components/provide/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> provide","text":""},{"location":"reference/django_components/provide/#django_components.provide","title":"provide","text":"<p>Classes:</p> <ul> <li> <code>ProvideNode</code>           \u2013            <p>Implementation of the <code>{% provide %}</code> tag.</p> </li> </ul>"},{"location":"reference/django_components/provide/#django_components.provide.ProvideNode","title":"ProvideNode","text":"<pre><code>ProvideNode(nodelist: NodeList, trace_id: str, node_id: Optional[str] = None, kwargs: Optional[RuntimeKwargs] = None)\n</code></pre> <p>               Bases: <code>BaseNode</code></p> <p>Implementation of the <code>{% provide %}</code> tag. For more info see <code>Component.inject</code>.</p> Source code in <code>src/django_components/provide.py</code> <pre><code>def __init__(\n    self,\n    nodelist: NodeList,\n    trace_id: str,\n    node_id: Optional[str] = None,\n    kwargs: Optional[RuntimeKwargs] = None,\n):\n    super().__init__(nodelist=nodelist, args=None, kwargs=kwargs, node_id=node_id)\n\n    self.nodelist = nodelist\n    self.node_id = node_id or gen_id()\n    self.trace_id = trace_id\n    self.kwargs = kwargs or RuntimeKwargs({})\n</code></pre>"},{"location":"reference/django_components/slots/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> slots","text":""},{"location":"reference/django_components/slots/#django_components.slots","title":"slots","text":"<p>Classes:</p> <ul> <li> <code>FillNode</code>           \u2013            <p>Node corresponding to <code>{% fill %}</code></p> </li> <li> <code>Slot</code>           \u2013            <p>This class holds the slot content function along with related metadata.</p> </li> <li> <code>SlotFill</code>           \u2013            <p>SlotFill describes what WILL be rendered.</p> </li> <li> <code>SlotIsFilled</code>           \u2013            <p>Dictionary that returns <code>True</code> if the slot is filled (key is found), <code>False</code> otherwise.</p> </li> <li> <code>SlotNode</code>           \u2013            <p>Node corresponding to <code>{% slot %}</code></p> </li> <li> <code>SlotRef</code>           \u2013            <p>SlotRef allows to treat a slot as a variable. The slot is rendered only once</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>resolve_fills</code>             \u2013              <p>Given a component body (<code>django.template.NodeList</code>), find all slot fills,</p> </li> </ul>"},{"location":"reference/django_components/slots/#django_components.slots.FillNode","title":"FillNode","text":"<pre><code>FillNode(nodelist: NodeList, kwargs: RuntimeKwargs, trace_id: str, node_id: Optional[str] = None)\n</code></pre> <p>               Bases: <code>BaseNode</code></p> <p>Node corresponding to <code>{% fill %}</code></p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(\n    self,\n    nodelist: NodeList,\n    kwargs: RuntimeKwargs,\n    trace_id: str,\n    node_id: Optional[str] = None,\n):\n    super().__init__(nodelist=nodelist, args=None, kwargs=kwargs, node_id=node_id)\n\n    self.trace_id = trace_id\n</code></pre>"},{"location":"reference/django_components/slots/#django_components.slots.Slot","title":"Slot  <code>dataclass</code>","text":"<pre><code>Slot(content_func: SlotFunc[TSlotData])\n</code></pre> <p>               Bases: <code>Generic[TSlotData]</code></p> <p>This class holds the slot content function along with related metadata.</p>"},{"location":"reference/django_components/slots/#django_components.slots.SlotFill","title":"SlotFill  <code>dataclass</code>","text":"<pre><code>SlotFill(name: str, is_filled: bool, slot: Slot[TSlotData])\n</code></pre> <p>               Bases: <code>Generic[TSlotData]</code></p> <p>SlotFill describes what WILL be rendered.</p> <p>The fill may be provided by the user from the outside (<code>is_filled=True</code>), or it may be the default content of the slot (<code>is_filled=False</code>).</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the slot.</p> </li> </ul>"},{"location":"reference/django_components/slots/#django_components.slots.SlotFill.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Name of the slot.</p>"},{"location":"reference/django_components/slots/#django_components.slots.SlotIsFilled","title":"SlotIsFilled","text":"<pre><code>SlotIsFilled(fills: Dict, *args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>dict</code></p> <p>Dictionary that returns <code>True</code> if the slot is filled (key is found), <code>False</code> otherwise.</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(self, fills: Dict, *args: Any, **kwargs: Any) -&gt; None:\n    escaped_fill_names = {_escape_slot_name(fill_name): True for fill_name in fills.keys()}\n    super().__init__(escaped_fill_names, *args, **kwargs)\n</code></pre>"},{"location":"reference/django_components/slots/#django_components.slots.SlotNode","title":"SlotNode","text":"<pre><code>SlotNode(\n    nodelist: NodeList,\n    trace_id: str,\n    node_id: Optional[str] = None,\n    kwargs: Optional[RuntimeKwargs] = None,\n    is_required: bool = False,\n    is_default: bool = False,\n)\n</code></pre> <p>               Bases: <code>BaseNode</code></p> <p>Node corresponding to <code>{% slot %}</code></p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(\n    self,\n    nodelist: NodeList,\n    trace_id: str,\n    node_id: Optional[str] = None,\n    kwargs: Optional[RuntimeKwargs] = None,\n    is_required: bool = False,\n    is_default: bool = False,\n):\n    super().__init__(nodelist=nodelist, args=None, kwargs=kwargs, node_id=node_id)\n\n    self.is_required = is_required\n    self.is_default = is_default\n    self.trace_id = trace_id\n</code></pre>"},{"location":"reference/django_components/slots/#django_components.slots.SlotRef","title":"SlotRef","text":"<pre><code>SlotRef(slot: SlotNode, context: Context)\n</code></pre> <p>SlotRef allows to treat a slot as a variable. The slot is rendered only once the instance is coerced to string.</p> <p>This is used to access slots as variables inside the templates. When a SlotRef is rendered in the template with <code>{{ my_lazy_slot }}</code>, it will output the contents of the slot.</p> Source code in <code>src/django_components/slots.py</code> <pre><code>def __init__(self, slot: \"SlotNode\", context: Context):\n    self._slot = slot\n    self._context = context\n</code></pre>"},{"location":"reference/django_components/slots/#django_components.slots.resolve_fills","title":"resolve_fills","text":"<pre><code>resolve_fills(context: Context, nodelist: NodeList, component_name: str) -&gt; Dict[SlotName, Slot]\n</code></pre> <p>Given a component body (<code>django.template.NodeList</code>), find all slot fills, whether defined explicitly with <code>{% fill %}</code> or implicitly.</p> <p>So if we have a component body: <pre><code>{% component \"mycomponent\" %}\n    {% fill \"first_fill\" %}\n        Hello!\n    {% endfill %}\n    {% fill \"second_fill\" %}\n        Hello too!\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Then this function finds 2 fill nodes: \"first_fill\" and \"second_fill\", and formats them as slot functions, returning:</p> <pre><code>{\n    \"first_fill\": SlotFunc(...),\n    \"second_fill\": SlotFunc(...),\n}\n</code></pre> <p>If no fill nodes are found, then the content is treated as default slot content.</p> <pre><code>{\n    DEFAULT_SLOT_KEY: SlotFunc(...),\n}\n</code></pre> <p>This function also handles for-loops, if/else statements, or include tags to generate fill tags:</p> <pre><code>{% component \"mycomponent\" %}\n    {% for slot_name in slots %}\n        {% fill name=slot_name %}\n            {% slot name=slot_name / %}\n        {% endfill %}\n    {% endfor %}\n{% endcomponent %}\n</code></pre> Source code in <code>src/django_components/slots.py</code> <pre><code>def resolve_fills(\n    context: Context,\n    nodelist: NodeList,\n    component_name: str,\n) -&gt; Dict[SlotName, Slot]:\n    \"\"\"\n    Given a component body (`django.template.NodeList`), find all slot fills,\n    whether defined explicitly with `{% fill %}` or implicitly.\n\n    So if we have a component body:\n    ```django\n    {% component \"mycomponent\" %}\n        {% fill \"first_fill\" %}\n            Hello!\n        {% endfill %}\n        {% fill \"second_fill\" %}\n            Hello too!\n        {% endfill %}\n    {% endcomponent %}\n    ```\n\n    Then this function finds 2 fill nodes: \"first_fill\" and \"second_fill\",\n    and formats them as slot functions, returning:\n\n    ```python\n    {\n        \"first_fill\": SlotFunc(...),\n        \"second_fill\": SlotFunc(...),\n    }\n    ```\n\n    If no fill nodes are found, then the content is treated as default slot content.\n\n    ```python\n    {\n        DEFAULT_SLOT_KEY: SlotFunc(...),\n    }\n    ```\n\n    This function also handles for-loops, if/else statements, or include tags to generate fill tags:\n\n    ```django\n    {% component \"mycomponent\" %}\n        {% for slot_name in slots %}\n            {% fill name=slot_name %}\n                {% slot name=slot_name / %}\n            {% endfill %}\n        {% endfor %}\n    {% endcomponent %}\n    ```\n    \"\"\"\n    slots: Dict[SlotName, Slot] = {}\n\n    if not nodelist:\n        return slots\n\n    maybe_fills = _extract_fill_content(nodelist, context, component_name)\n\n    # The content has no fills, so treat it as default slot, e.g.:\n    # {% component \"mycomponent\" %}\n    #   Hello!\n    #   {% if True %} 123 {% endif %}\n    # {% endcomponent %}\n    if maybe_fills is False:\n        # Ignore empty content between `{% component %} ... {% endcomponent %}` tags\n        nodelist_is_empty = not len(nodelist) or all(\n            isinstance(node, TextNode) and not node.s.strip() for node in nodelist\n        )\n\n        if not nodelist_is_empty:\n            slots[DEFAULT_SLOT_KEY] = _nodelist_to_slot_render_func(\n                DEFAULT_SLOT_KEY,\n                nodelist,\n                data_var=None,\n                default_var=None,\n            )\n\n    # The content has fills\n    else:\n        # NOTE: If slot fills are explicitly defined, we use them even if they are empty (or only whitespace).\n        #       This is different from the default slot, where we ignore empty content.\n        for fill in maybe_fills:\n            slots[fill.name] = _nodelist_to_slot_render_func(\n                slot_name=fill.name,\n                nodelist=fill.fill.nodelist,\n                data_var=fill.data_var,\n                default_var=fill.default_var,\n                extra_context=fill.extra_context,\n            )\n\n    return slots\n</code></pre>"},{"location":"reference/django_components/tag_formatter/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> tag_formatter","text":""},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter","title":"tag_formatter","text":"<p>Classes:</p> <ul> <li> <code>ComponentFormatter</code>           \u2013            <p>The original django_component's component tag formatter, it uses the <code>{% component %}</code></p> </li> <li> <code>InternalTagFormatter</code>           \u2013            <p>Internal wrapper around user-provided TagFormatters, so that we validate the outputs.</p> </li> <li> <code>ShorthandComponentFormatter</code>           \u2013            <p>The component tag formatter that uses <code>{% &lt;name&gt; %}</code> / <code>{% end&lt;name&gt; %}</code> tags.</p> </li> <li> <code>TagFormatterABC</code>           \u2013            <p>Abstract base class for defining custom tag formatters.</p> </li> <li> <code>TagResult</code>           \u2013            <p>The return value from <code>TagFormatter.parse()</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_tag_formatter</code>             \u2013              <p>Returns an instance of the currently configured component tag formatter.</p> </li> </ul>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.ComponentFormatter","title":"ComponentFormatter","text":"<pre><code>ComponentFormatter(tag: str)\n</code></pre> <p>               Bases: <code>TagFormatterABC</code></p> <p>The original django_component's component tag formatter, it uses the <code>{% component %}</code> and <code>{% endcomponent %}</code> tags, and the component name is given as the first positional arg.</p> <p>Example as block: <pre><code>{% component \"mycomp\" abc=123 %}\n    {% fill \"myfill\" %}\n        ...\n    {% endfill %}\n{% endcomponent %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% component \"mycomp\" abc=123 / %}\n</code></pre></p> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>def __init__(self, tag: str):\n    self.tag = tag\n</code></pre>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.InternalTagFormatter","title":"InternalTagFormatter","text":"<pre><code>InternalTagFormatter(tag_formatter: TagFormatterABC)\n</code></pre> <p>Internal wrapper around user-provided TagFormatters, so that we validate the outputs.</p> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>def __init__(self, tag_formatter: TagFormatterABC):\n    self.tag_formatter = tag_formatter\n</code></pre>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.ShorthandComponentFormatter","title":"ShorthandComponentFormatter","text":"<p>               Bases: <code>TagFormatterABC</code></p> <p>The component tag formatter that uses <code>{% &lt;name&gt; %}</code> / <code>{% end&lt;name&gt; %}</code> tags.</p> <p>This is similar to django-web-components and django-slippers syntax.</p> <p>Example as block: <pre><code>{% mycomp abc=123 %}\n    {% fill \"myfill\" %}\n        ...\n    {% endfill %}\n{% endmycomp %}\n</code></pre></p> <p>Example as inlined tag: <pre><code>{% mycomp abc=123 / %}\n</code></pre></p>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.TagFormatterABC","title":"TagFormatterABC","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for defining custom tag formatters.</p> <p>Tag formatters define how the component tags are used in the template.</p> <p>Read more about Tag formatter.</p> <p>For example, with the default tag formatter (<code>ComponentFormatter</code>), components are written as:</p> <pre><code>{% component \"comp_name\" %}\n{% endcomponent %}\n</code></pre> <p>While with the shorthand tag formatter (<code>ShorthandComponentFormatter</code>), components are written as: <pre><code>{% comp_name %}\n{% endcomp_name %}\n</code></pre></p> <p>Example:</p> <p>Implementation for <code>ShorthandComponentFormatter</code>:</p> <pre><code>from djagno_components import TagFormatterABC, TagResult\n\nclass ShorthandComponentFormatter(TagFormatterABC):\n    def start_tag(self, name: str) -&gt; str:\n        return name\n\n    def end_tag(self, name: str) -&gt; str:\n        return f\"end{name}\"\n\n    def parse(self, tokens: List[str]) -&gt; TagResult:\n        tokens = [*tokens]\n        name = tokens.pop(0)\n        return TagResult(name, tokens)\n</code></pre> <p>Methods:</p> <ul> <li> <code>end_tag</code>             \u2013              <p>Formats the end tag of a block component.</p> </li> <li> <code>parse</code>             \u2013              <p>Given the tokens (words) passed to a component start tag, this function extracts</p> </li> <li> <code>start_tag</code>             \u2013              <p>Formats the start tag of a component.</p> </li> </ul>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.TagFormatterABC.end_tag","title":"end_tag  <code>abstractmethod</code>","text":"<pre><code>end_tag(name: str) -&gt; str\n</code></pre> <p>Formats the end tag of a block component.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component's registered name. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The formatted end tag.</p> </li> </ul> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>@abc.abstractmethod\ndef end_tag(self, name: str) -&gt; str:\n    \"\"\"\n    Formats the end tag of a block component.\n\n    Args:\n        name (str): Component's registered name. Required.\n\n    Returns:\n        str: The formatted end tag.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.TagFormatterABC.parse","title":"parse  <code>abstractmethod</code>","text":"<pre><code>parse(tokens: List[str]) -&gt; TagResult\n</code></pre> <p>Given the tokens (words) passed to a component start tag, this function extracts the component name from the tokens list, and returns <code>TagResult</code>, which is a tuple of <code>(component_name, remaining_tokens)</code>.</p> <p>Parameters:</p> <ul> <li> <code>tokens</code>               (<code>[List(str]</code>)           \u2013            <p>List of tokens passed to the component tag.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TagResult</code> (              <code>TagResult</code> )          \u2013            <p>Parsed component name and remaining tokens.</p> </li> </ul> <p>Example:</p> <p>Assuming we used a component in a template like this:</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n{% endcomponent %}\n</code></pre> <p>This function receives a list of tokens:</p> <pre><code>['component', '\"my_comp\"', 'key=val', 'key2=val2']\n</code></pre> <ul> <li><code>component</code> is the tag name, which we drop.</li> <li><code>\"my_comp\"</code> is the component name, but we must remove the extra quotes.</li> <li>The remaining tokens we pass unmodified, as that's the input to the component.</li> </ul> <p>So in the end, we return:</p> <pre><code>TagResult('my_comp', ['key=val', 'key2=val2'])\n</code></pre> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>@abc.abstractmethod\ndef parse(self, tokens: List[str]) -&gt; TagResult:\n    \"\"\"\n    Given the tokens (words) passed to a component start tag, this function extracts\n    the component name from the tokens list, and returns\n    [`TagResult`](../api#django_components.TagResult),\n    which is a tuple of `(component_name, remaining_tokens)`.\n\n    Args:\n        tokens [List(str]): List of tokens passed to the component tag.\n\n    Returns:\n        TagResult: Parsed component name and remaining tokens.\n\n    **Example:**\n\n    Assuming we used a component in a template like this:\n\n    ```django\n    {% component \"my_comp\" key=val key2=val2 %}\n    {% endcomponent %}\n    ```\n\n    This function receives a list of tokens:\n\n    ```python\n    ['component', '\"my_comp\"', 'key=val', 'key2=val2']\n    ```\n\n    - `component` is the tag name, which we drop.\n    - `\"my_comp\"` is the component name, but we must remove the extra quotes.\n    - The remaining tokens we pass unmodified, as that's the input to the component.\n\n    So in the end, we return:\n\n    ```python\n    TagResult('my_comp', ['key=val', 'key2=val2'])\n    ```\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.TagFormatterABC.start_tag","title":"start_tag  <code>abstractmethod</code>","text":"<pre><code>start_tag(name: str) -&gt; str\n</code></pre> <p>Formats the start tag of a component.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Component's registered name. Required.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The formatted start tag.</p> </li> </ul> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>@abc.abstractmethod\ndef start_tag(self, name: str) -&gt; str:\n    \"\"\"\n    Formats the start tag of a component.\n\n    Args:\n        name (str): Component's registered name. Required.\n\n    Returns:\n        str: The formatted start tag.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.TagResult","title":"TagResult","text":"<p>               Bases: <code>NamedTuple</code></p> <p>The return value from <code>TagFormatter.parse()</code>.</p> <p>Read more about Tag formatter.</p> <p>Attributes:</p> <ul> <li> <code>component_name</code>               (<code>str</code>)           \u2013            <p>Component name extracted from the template tag</p> </li> <li> <code>tokens</code>               (<code>List[str]</code>)           \u2013            <p>Remaining tokens (words) that were passed to the tag, with component name removed</p> </li> </ul>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.TagResult.component_name","title":"component_name  <code>instance-attribute</code>","text":"<pre><code>component_name: str\n</code></pre> <p>Component name extracted from the template tag</p> <p>For example, if we had tag</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n</code></pre> <p>Then <code>component_name</code> would be <code>my_comp</code>.</p>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.TagResult.tokens","title":"tokens  <code>instance-attribute</code>","text":"<pre><code>tokens: List[str]\n</code></pre> <p>Remaining tokens (words) that were passed to the tag, with component name removed</p> <p>For example, if we had tag</p> <pre><code>{% component \"my_comp\" key=val key2=val2 %}\n</code></pre> <p>Then <code>tokens</code> would be <code>['key=val', 'key2=val2']</code>.</p>"},{"location":"reference/django_components/tag_formatter/#django_components.tag_formatter.get_tag_formatter","title":"get_tag_formatter","text":"<pre><code>get_tag_formatter(registry: ComponentRegistry) -&gt; InternalTagFormatter\n</code></pre> <p>Returns an instance of the currently configured component tag formatter.</p> Source code in <code>src/django_components/tag_formatter.py</code> <pre><code>def get_tag_formatter(registry: \"ComponentRegistry\") -&gt; InternalTagFormatter:\n    \"\"\"Returns an instance of the currently configured component tag formatter.\"\"\"\n    # Allow users to configure the component TagFormatter\n    formatter_cls_or_str = registry.settings.tag_formatter\n\n    if isinstance(formatter_cls_or_str, str):\n        tag_formatter: TagFormatterABC = import_string(formatter_cls_or_str)\n    else:\n        tag_formatter = formatter_cls_or_str\n\n    return InternalTagFormatter(tag_formatter)\n</code></pre>"},{"location":"reference/django_components/template/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> template","text":""},{"location":"reference/django_components/template/#django_components.template","title":"template","text":"<p>Functions:</p> <ul> <li> <code>cached_template</code>             \u2013              <p>Create a Template instance that will be cached as per the</p> </li> </ul>"},{"location":"reference/django_components/template/#django_components.template.cached_template","title":"cached_template","text":"<pre><code>cached_template(\n    template_string: str,\n    template_cls: Optional[Type[Template]] = None,\n    origin: Optional[Origin] = None,\n    name: Optional[str] = None,\n    engine: Optional[Any] = None,\n) -&gt; Template\n</code></pre> <p>Create a Template instance that will be cached as per the <code>COMPONENTS.template_cache_size</code> setting.</p> <p>Parameters:</p> <ul> <li> <code>template_string</code>               (<code>str</code>)           \u2013            <p>Template as a string, same as the first argument to Django's            <code>Template</code>. Required.</p> </li> <li> <code>template_cls</code>               (<code>Type[Template]</code>, default:                   <code>None</code> )           \u2013            <p>Specify the Template class that should be instantiated.            Defaults to Django's <code>Template</code> class.</p> </li> <li> <code>origin</code>               (<code>Type[Origin]</code>, default:                   <code>None</code> )           \u2013            <p>Sets             <code>Template.Origin</code>.</p> </li> <li> <code>name</code>               (<code>Type[str]</code>, default:                   <code>None</code> )           \u2013            <p>Sets <code>Template.name</code></p> </li> <li> <code>engine</code>               (<code>Type[Any]</code>, default:                   <code>None</code> )           \u2013            <p>Sets <code>Template.engine</code></p> </li> </ul> <pre><code>from django_components import cached_template\n\ntemplate = cached_template(\"Variable: {{ variable }}\")\n\n# You can optionally specify Template class, and other Template inputs:\nclass MyTemplate(Template):\n    pass\n\ntemplate = cached_template(\n    \"Variable: {{ variable }}\",\n    template_cls=MyTemplate,\n    name=...\n    origin=...\n    engine=...\n)\n</code></pre> Source code in <code>src/django_components/template.py</code> <pre><code>def cached_template(\n    template_string: str,\n    template_cls: Optional[Type[Template]] = None,\n    origin: Optional[Origin] = None,\n    name: Optional[str] = None,\n    engine: Optional[Any] = None,\n) -&gt; Template:\n    \"\"\"\n    Create a Template instance that will be cached as per the\n    [`COMPONENTS.template_cache_size`](../settings#django_components.app_settings.ComponentsSettings.template_cache_size)\n    setting.\n\n    Args:\n        template_string (str): Template as a string, same as the first argument to Django's\\\n            [`Template`](https://docs.djangoproject.com/en/5.1/topics/templates/#template). Required.\n        template_cls (Type[Template], optional): Specify the Template class that should be instantiated.\\\n            Defaults to Django's [`Template`](https://docs.djangoproject.com/en/5.1/topics/templates/#template) class.\n        origin (Type[Origin], optional): Sets \\\n            [`Template.Origin`](https://docs.djangoproject.com/en/5.1/howto/custom-template-backend/#origin-api-and-3rd-party-integration).\n        name (Type[str], optional): Sets `Template.name`\n        engine (Type[Any], optional): Sets `Template.engine`\n\n    ```python\n    from django_components import cached_template\n\n    template = cached_template(\"Variable: {{ variable }}\")\n\n    # You can optionally specify Template class, and other Template inputs:\n    class MyTemplate(Template):\n        pass\n\n    template = cached_template(\n        \"Variable: {{ variable }}\",\n        template_cls=MyTemplate,\n        name=...\n        origin=...\n        engine=...\n    )\n    ```\n    \"\"\"  # noqa: E501\n    template = _create_template(template_cls or Template, template_string, engine)\n\n    # Assign the origin and name separately, so the caching doesn't depend on them\n    # Since we might be accessing a template from cache, we want to define these only once\n    if not getattr(template, \"_dc_cached\", False):\n        template.origin = origin or Origin(UNKNOWN_SOURCE)\n        template.name = name\n        template._dc_cached = True\n\n    return template\n</code></pre>"},{"location":"reference/django_components/template_loader/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> template_loader","text":""},{"location":"reference/django_components/template_loader/#django_components.template_loader","title":"template_loader","text":"<p>Template loader that loads templates from each Django app's \"components\" directory.</p> <p>Classes:</p> <ul> <li> <code>Loader</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/template_loader/#django_components.template_loader.Loader","title":"Loader","text":"<p>               Bases: <code>Loader</code></p> <p>Methods:</p> <ul> <li> <code>get_dirs</code>             \u2013              <p>Prepare directories that may contain component files:</p> </li> </ul>"},{"location":"reference/django_components/template_loader/#django_components.template_loader.Loader.get_dirs","title":"get_dirs","text":"<pre><code>get_dirs(include_apps: bool = True) -&gt; List[Path]\n</code></pre> <p>Prepare directories that may contain component files:</p> <p>Searches for dirs set in <code>COMPONENTS.dirs</code> settings. If none set, defaults to searching for a \"components\" app. The dirs in <code>COMPONENTS.dirs</code> must be absolute paths.</p> <p>In addition to that, also all apps are checked for <code>[app]/components</code> dirs.</p> <p>Paths are accepted only if they resolve to a directory. E.g. <code>/path/to/django_project/my_app/components/</code>.</p> <p><code>BASE_DIR</code> setting is required.</p> Source code in <code>src/django_components/template_loader.py</code> <pre><code>def get_dirs(self, include_apps: bool = True) -&gt; List[Path]:\n    \"\"\"\n    Prepare directories that may contain component files:\n\n    Searches for dirs set in `COMPONENTS.dirs` settings. If none set, defaults to searching\n    for a \"components\" app. The dirs in `COMPONENTS.dirs` must be absolute paths.\n\n    In addition to that, also all apps are checked for `[app]/components` dirs.\n\n    Paths are accepted only if they resolve to a directory.\n    E.g. `/path/to/django_project/my_app/components/`.\n\n    `BASE_DIR` setting is required.\n    \"\"\"\n    return get_component_dirs(include_apps)\n</code></pre>"},{"location":"reference/django_components/template_parser/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> template_parser","text":""},{"location":"reference/django_components/template_parser/#django_components.template_parser","title":"template_parser","text":"<p>Overrides for the Django Template system to allow finer control over template parsing.</p> <p>Based on Django Slippers v0.6.2 - https://github.com/mixxorz/slippers/blob/main/slippers/template.py</p> <p>Functions:</p> <ul> <li> <code>parse_bits</code>             \u2013              <p>Parse bits for template tag helpers simple_tag and inclusion_tag, in</p> </li> <li> <code>token_kwargs</code>             \u2013              <p>Parse token keyword arguments and return a dictionary of the arguments</p> </li> </ul>"},{"location":"reference/django_components/template_parser/#django_components.template_parser.parse_bits","title":"parse_bits","text":"<pre><code>parse_bits(\n    parser: Parser, bits: List[str], params: List[str], name: str\n) -&gt; Tuple[List[FilterExpression], List[Tuple[str, FilterExpression]]]\n</code></pre> <p>Parse bits for template tag helpers simple_tag and inclusion_tag, in particular by detecting syntax errors and by extracting positional and keyword arguments.</p> <p>This is a simplified version of <code>django.template.library.parse_bits</code> where we use custom regex to handle special characters in keyword names.</p> <p>Furthermore, our version allows duplicate keys, and instead of return kwargs as a dict, we return it as a list of key-value pairs. So it is up to the user of this function to decide whether they support duplicate keys or not.</p> Source code in <code>src/django_components/template_parser.py</code> <pre><code>def parse_bits(\n    parser: Parser,\n    bits: List[str],\n    params: List[str],\n    name: str,\n) -&gt; Tuple[List[FilterExpression], List[Tuple[str, FilterExpression]]]:\n    \"\"\"\n    Parse bits for template tag helpers simple_tag and inclusion_tag, in\n    particular by detecting syntax errors and by extracting positional and\n    keyword arguments.\n\n    This is a simplified version of `django.template.library.parse_bits`\n    where we use custom regex to handle special characters in keyword names.\n\n    Furthermore, our version allows duplicate keys, and instead of return kwargs\n    as a dict, we return it as a list of key-value pairs. So it is up to the\n    user of this function to decide whether they support duplicate keys or not.\n    \"\"\"\n    args: List[FilterExpression] = []\n    kwargs: List[Tuple[str, FilterExpression]] = []\n    unhandled_params = list(params)\n    for bit in bits:\n        # First we try to extract a potential kwarg from the bit\n        kwarg = token_kwargs([bit], parser)\n        if kwarg:\n            # The kwarg was successfully extracted\n            param, value = kwarg.popitem()\n            # All good, record the keyword argument\n            kwargs.append((str(param), value))\n            if param in unhandled_params:\n                # If using the keyword syntax for a positional arg, then\n                # consume it.\n                unhandled_params.remove(param)\n        else:\n            if kwargs:\n                raise TemplateSyntaxError(\n                    \"'%s' received some positional argument(s) after some \" \"keyword argument(s)\" % name\n                )\n            else:\n                # Record the positional argument\n                args.append(parser.compile_filter(bit))\n                try:\n                    # Consume from the list of expected positional arguments\n                    unhandled_params.pop(0)\n                except IndexError:\n                    pass\n    if unhandled_params:\n        # Some positional arguments were not supplied\n        raise TemplateSyntaxError(\n            \"'%s' did not receive value(s) for the argument(s): %s\"\n            % (name, \", \".join(\"'%s'\" % p for p in unhandled_params))\n        )\n    return args, kwargs\n</code></pre>"},{"location":"reference/django_components/template_parser/#django_components.template_parser.token_kwargs","title":"token_kwargs","text":"<pre><code>token_kwargs(bits: List[str], parser: Parser) -&gt; Dict[str, FilterExpression]\n</code></pre> <p>Parse token keyword arguments and return a dictionary of the arguments retrieved from the <code>bits</code> token list.</p> <p><code>bits</code> is a list containing the remainder of the token (split by spaces) that is to be checked for arguments. Valid arguments are removed from this list.</p> <p>There is no requirement for all remaining token <code>bits</code> to be keyword arguments, so return the dictionary as soon as an invalid argument format is reached.</p> Source code in <code>src/django_components/template_parser.py</code> <pre><code>def token_kwargs(bits: List[str], parser: Parser) -&gt; Dict[str, FilterExpression]:\n    \"\"\"\n    Parse token keyword arguments and return a dictionary of the arguments\n    retrieved from the ``bits`` token list.\n\n    `bits` is a list containing the remainder of the token (split by spaces)\n    that is to be checked for arguments. Valid arguments are removed from this\n    list.\n\n    There is no requirement for all remaining token ``bits`` to be keyword\n    arguments, so return the dictionary as soon as an invalid argument format\n    is reached.\n    \"\"\"\n    if not bits:\n        return {}\n    match = kwarg_re.match(bits[0])\n    kwarg_format = match and match[1]\n    if not kwarg_format:\n        return {}\n\n    kwargs: Dict[str, FilterExpression] = {}\n    while bits:\n        if kwarg_format:\n            match = kwarg_re.match(bits[0])\n            if not match or not match[1]:\n                return kwargs\n            key, value = match.groups()\n            del bits[:1]\n        else:\n            if len(bits) &lt; 3 or bits[1] != \"as\":\n                return kwargs\n            key, value = bits[2], bits[0]\n            del bits[:3]\n\n        # This is the only difference from the original token_kwargs. We use\n        # the ComponentsFilterExpression instead of the original FilterExpression.\n        kwargs[key] = ComponentsFilterExpression(value, parser)\n        if bits and not kwarg_format:\n            if bits[0] != \"and\":\n                return kwargs\n            del bits[:1]\n    return kwargs\n</code></pre>"},{"location":"reference/django_components/templatetags/","title":"Index","text":""},{"location":"reference/django_components/templatetags/#django_components.templatetags","title":"templatetags","text":"<p>Modules:</p> <ul> <li> <code>component_tags</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags","title":"component_tags","text":"<p>Functions:</p> <ul> <li> <code>component</code>             \u2013              <p>Renders one of the components that was previously registered with</p> </li> <li> <code>component_css_dependencies</code>             \u2013              <p>Marks location where CSS link tags should be rendered after the whole HTML has been generated.</p> </li> <li> <code>component_js_dependencies</code>             \u2013              <p>Marks location where JS link tags should be rendered after the whole HTML has been generated.</p> </li> <li> <code>fill</code>             \u2013              <p>Use this tag to insert content into component's slots.</p> </li> <li> <code>html_attrs</code>             \u2013              <p>Generate HTML attributes (<code>key=\"value\"</code>), combining data from multiple sources,</p> </li> <li> <code>provide</code>             \u2013              <p>The \"provider\" part of the provide / inject feature.</p> </li> <li> <code>slot</code>             \u2013              <p>Slot tag marks a place inside a component where content can be inserted</p> </li> </ul>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.TagSpec","title":"TagSpec","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Definition of args, kwargs, flags, etc, for a template tag.</p> <p>Attributes:</p> <ul> <li> <code>end_tag</code>               (<code>Optional[str]</code>)           \u2013            <p>End tag.</p> </li> <li> <code>flags</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>List of allowed flags.</p> </li> <li> <code>keywordonly_args</code>               (<code>Optional[Union[bool, List[str]]]</code>)           \u2013            <p>Parameters that MUST be given only as kwargs (not accounting for <code>pos_or_keyword_args</code>).</p> </li> <li> <code>optional_kwargs</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Specify which kwargs can be optional.</p> </li> <li> <code>pos_or_keyword_args</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Like regular Python kwargs, these can be given EITHER as positional OR as keyword arguments.</p> </li> <li> <code>positional_args_allow_extra</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, allows variable number of positional args, e.g. <code>{% mytag val1 1234 val2 890 ... %}</code></p> </li> <li> <code>positional_only_args</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Arguments that MUST be given as positional args.</p> </li> <li> <code>repeatable_kwargs</code>               (<code>Optional[Union[bool, List[str]]]</code>)           \u2013            <p>Whether this tag allows all or certain kwargs to be repeated.</p> </li> <li> <code>tag</code>               (<code>str</code>)           \u2013            <p>Tag name. E.g. <code>\"slot\"</code> means the tag is written like so <code>{% slot ... %}</code></p> </li> </ul>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.TagSpec.end_tag","title":"end_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_tag: Optional[str] = None\n</code></pre> <p>End tag.</p> <p>E.g. <code>\"endslot\"</code> means anything between the start tag and <code>{% endslot %}</code> is considered the slot's body.</p>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.TagSpec.flags","title":"flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flags: Optional[List[str]] = None\n</code></pre> <p>List of allowed flags.</p> <p>Flags are like kwargs, but without the value part. E.g. in <code>{% mytag only required %}</code>: - <code>only</code> and <code>required</code> are treated as <code>only=True</code> and <code>required=True</code> if present - and treated as <code>only=False</code> and <code>required=False</code> if omitted</p>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.TagSpec.keywordonly_args","title":"keywordonly_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keywordonly_args: Optional[Union[bool, List[str]]] = False\n</code></pre> <p>Parameters that MUST be given only as kwargs (not accounting for <code>pos_or_keyword_args</code>).</p> <ul> <li>If <code>False</code>, NO extra kwargs allowed.</li> <li>If <code>True</code>, ANY number of extra kwargs allowed.</li> <li>If a list of strings, e.g. <code>[\"class\", \"style\"]</code>, then only those kwargs are allowed.</li> </ul>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.TagSpec.optional_kwargs","title":"optional_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>optional_kwargs: Optional[List[str]] = None\n</code></pre> <p>Specify which kwargs can be optional.</p>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.TagSpec.pos_or_keyword_args","title":"pos_or_keyword_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pos_or_keyword_args: Optional[List[str]] = None\n</code></pre> <p>Like regular Python kwargs, these can be given EITHER as positional OR as keyword arguments.</p>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.TagSpec.positional_args_allow_extra","title":"positional_args_allow_extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>positional_args_allow_extra: bool = False\n</code></pre> <p>If <code>True</code>, allows variable number of positional args, e.g. <code>{% mytag val1 1234 val2 890 ... %}</code></p>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.TagSpec.positional_only_args","title":"positional_only_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>positional_only_args: Optional[List[str]] = None\n</code></pre> <p>Arguments that MUST be given as positional args.</p>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.TagSpec.repeatable_kwargs","title":"repeatable_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>repeatable_kwargs: Optional[Union[bool, List[str]]] = False\n</code></pre> <p>Whether this tag allows all or certain kwargs to be repeated.</p> <ul> <li>If <code>False</code>, NO kwargs can repeat.</li> <li>If <code>True</code>, ALL kwargs can repeat.</li> <li>If a list of strings, e.g. <code>[\"class\", \"style\"]</code>, then only those kwargs can repeat.</li> </ul> <p>E.g. <code>[\"class\"]</code> means one can write <code>{% mytag class=\"one\" class=\"two\" %}</code></p>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.TagSpec.tag","title":"tag  <code>instance-attribute</code>","text":"<pre><code>tag: str\n</code></pre> <p>Tag name. E.g. <code>\"slot\"</code> means the tag is written like so <code>{% slot ... %}</code></p>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.component","title":"component","text":"<pre><code>component(parser: Parser, token: Token, registry: ComponentRegistry, tag_name: str, tag_spec: TagSpec) -&gt; ComponentNode\n</code></pre> <p>Renders one of the components that was previously registered with <code>@register()</code> decorator.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Registered name of the component to render</li> <li>All other args and kwargs are defined based on the component itself.</li> </ul> <p>If you defined a component <code>\"my_table\"</code></p> <pre><code>from django_component import Component, register\n\n@register(\"my_table\")\nclass MyTable(Component):\n    template = \"\"\"\n      &lt;table&gt;\n        &lt;thead&gt;\n          {% for header in headers %}\n            &lt;th&gt;{{ header }}&lt;/th&gt;\n          {% endfor %}\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          {% for row in rows %}\n            &lt;tr&gt;\n              {% for cell in row %}\n                &lt;td&gt;{{ cell }}&lt;/td&gt;\n              {% endfor %}\n            &lt;/tr&gt;\n          {% endfor %}\n        &lt;tbody&gt;\n      &lt;/table&gt;\n    \"\"\"\n\n    def get_context_data(self, rows: List, headers: List):\n        return {\n            \"rows\": rows,\n            \"headers\": headers,\n        }\n</code></pre> <p>Then you can render this component by referring to <code>MyTable</code> via its registered name <code>\"my_table\"</code>:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.component--component-input","title":"Component input","text":"<p>Positional and keyword arguments can be literals or template variables.</p> <p>The component name must be a single- or double-quotes string and must be either:</p> <ul> <li> <p>The first positional argument after <code>component</code>:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n</code></pre> </li> <li> <p>Passed as kwarg <code>name</code>:</p> <pre><code>{% component rows=rows headers=headers name=\"my_table\" ... / %}\n</code></pre> </li> </ul>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.component--inserting-into-slots","title":"Inserting into slots","text":"<p>If the component defined any slots, you can pass in the content to be placed inside those slots by inserting <code>{% fill %}</code> tags, directly within the <code>{% component %}</code> tag:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.component--isolating-components","title":"Isolating components","text":"<p>By default, components behave similarly to Django's <code>{% include %}</code>, and the template inside the component has access to the variables defined in the outer template.</p> <p>You can selectively isolate a component, using the <code>only</code> flag, so that the inner template can access only the data that was explicitly passed to it:</p> <pre><code>{% component \"name\" positional_arg keyword_arg=value ... only %}\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@with_tag_spec(\n    TagSpec(\n        tag=\"component\",\n        end_tag=\"endcomponent\",\n        positional_only_args=[],\n        positional_args_allow_extra=True,  # Allow many args\n        keywordonly_args=True,\n        repeatable_kwargs=False,\n        flags=[COMP_ONLY_FLAG],\n    )\n)\ndef component(\n    parser: Parser,\n    token: Token,\n    registry: ComponentRegistry,\n    tag_name: str,\n    tag_spec: TagSpec,\n) -&gt; ComponentNode:\n    \"\"\"\n    Renders one of the components that was previously registered with\n    [`@register()`](./api.md#django_components.register)\n    decorator.\n\n    **Args:**\n\n    - `name` (str, required): Registered name of the component to render\n    - All other args and kwargs are defined based on the component itself.\n\n    If you defined a component `\"my_table\"`\n\n    ```python\n    from django_component import Component, register\n\n    @register(\"my_table\")\n    class MyTable(Component):\n        template = \\\"\\\"\\\"\n          &lt;table&gt;\n            &lt;thead&gt;\n              {% for header in headers %}\n                &lt;th&gt;{{ header }}&lt;/th&gt;\n              {% endfor %}\n            &lt;/thead&gt;\n            &lt;tbody&gt;\n              {% for row in rows %}\n                &lt;tr&gt;\n                  {% for cell in row %}\n                    &lt;td&gt;{{ cell }}&lt;/td&gt;\n                  {% endfor %}\n                &lt;/tr&gt;\n              {% endfor %}\n            &lt;tbody&gt;\n          &lt;/table&gt;\n        \\\"\\\"\\\"\n\n        def get_context_data(self, rows: List, headers: List):\n            return {\n                \"rows\": rows,\n                \"headers\": headers,\n            }\n    ```\n\n    Then you can render this component by referring to `MyTable` via its\n    registered name `\"my_table\"`:\n\n    ```django\n    {% component \"my_table\" rows=rows headers=headers ... / %}\n    ```\n\n    ### Component input\n\n    Positional and keyword arguments can be literals or template variables.\n\n    The component name must be a single- or double-quotes string and must\n    be either:\n\n    - The first positional argument after `component`:\n\n        ```django\n        {% component \"my_table\" rows=rows headers=headers ... / %}\n        ```\n\n    - Passed as kwarg `name`:\n\n        ```django\n        {% component rows=rows headers=headers name=\"my_table\" ... / %}\n        ```\n\n    ### Inserting into slots\n\n    If the component defined any [slots](../concepts/fundamentals/slots.md), you can\n    pass in the content to be placed inside those slots by inserting [`{% fill %}`](#fill) tags,\n    directly within the `{% component %}` tag:\n\n    ```django\n    {% component \"my_table\" rows=rows headers=headers ... / %}\n      {% fill \"pagination\" %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Isolating components\n\n    By default, components behave similarly to Django's\n    [`{% include %}`](https://docs.djangoproject.com/en/5.1/ref/templates/builtins/#include),\n    and the template inside the component has access to the variables defined in the outer template.\n\n    You can selectively isolate a component, using the `only` flag, so that the inner template\n    can access only the data that was explicitly passed to it:\n\n    ```django\n    {% component \"name\" positional_arg keyword_arg=value ... only %}\n    ```\n    \"\"\"\n    _fix_nested_tags(parser, token)\n    bits = token.split_contents()\n\n    # Let the TagFormatter pre-process the tokens\n    formatter = get_tag_formatter(registry)\n    result = formatter.parse([*bits])\n    end_tag = formatter.end_tag(result.component_name)\n\n    # NOTE: The tokens returned from TagFormatter.parse do NOT include the tag itself\n    bits = [bits[0], *result.tokens]\n    token.contents = \" \".join(bits)\n\n    tag = _parse_tag(\n        parser,\n        token,\n        TagSpec(\n            **{\n                **tag_spec._asdict(),\n                \"tag\": tag_name,\n                \"end_tag\": end_tag,\n            }\n        ),\n    )\n\n    # Check for isolated context keyword\n    isolated_context = tag.flags[COMP_ONLY_FLAG]\n\n    trace_msg(\"PARSE\", \"COMP\", result.component_name, tag.id)\n\n    body = tag.parse_body()\n\n    component_node = ComponentNode(\n        name=result.component_name,\n        args=tag.args,\n        kwargs=tag.kwargs,\n        isolated_context=isolated_context,\n        nodelist=body,\n        node_id=tag.id,\n        registry=registry,\n    )\n\n    trace_msg(\"PARSE\", \"COMP\", result.component_name, tag.id, \"...Done!\")\n    return component_node\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.component_css_dependencies","title":"component_css_dependencies","text":"<pre><code>component_css_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode\n</code></pre> <p>Marks location where CSS link tags should be rendered after the whole HTML has been generated.</p> <p>Generally, this should be inserted into the <code>&lt;head&gt;</code> tag of the HTML.</p> <p>If the generated HTML does NOT contain any <code>{% component_css_dependencies %}</code> tags, CSS links are by default inserted into the <code>&lt;head&gt;</code> tag of the HTML. (See JS and CSS output locations)</p> <p>Note that there should be only one <code>{% component_css_dependencies %}</code> for the whole HTML document. If you insert this tag multiple times, ALL CSS links will be duplicately inserted into ALL these places.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"component_css_dependencies\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"component_css_dependencies\",\n        end_tag=None,  # inline-only\n    )\n)\ndef component_css_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode:\n    \"\"\"\n    Marks location where CSS link tags should be rendered after the whole HTML has been generated.\n\n    Generally, this should be inserted into the `&lt;head&gt;` tag of the HTML.\n\n    If the generated HTML does NOT contain any `{% component_css_dependencies %}` tags, CSS links\n    are by default inserted into the `&lt;head&gt;` tag of the HTML. (See\n    [JS and CSS output locations](../../concepts/advanced/rendering_js_css/#js-and-css-output-locations))\n\n    Note that there should be only one `{% component_css_dependencies %}` for the whole HTML document.\n    If you insert this tag multiple times, ALL CSS links will be duplicately inserted into ALL these places.\n    \"\"\"\n    # Parse to check that the syntax is valid\n    _parse_tag(parser, token, tag_spec)\n    return _component_dependencies(\"css\")\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.component_js_dependencies","title":"component_js_dependencies","text":"<pre><code>component_js_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode\n</code></pre> <p>Marks location where JS link tags should be rendered after the whole HTML has been generated.</p> <p>Generally, this should be inserted at the end of the <code>&lt;body&gt;</code> tag of the HTML.</p> <p>If the generated HTML does NOT contain any <code>{% component_js_dependencies %}</code> tags, JS scripts are by default inserted at the end of the <code>&lt;body&gt;</code> tag of the HTML. (See JS and CSS output locations)</p> <p>Note that there should be only one <code>{% component_js_dependencies %}</code> for the whole HTML document. If you insert this tag multiple times, ALL JS scripts will be duplicately inserted into ALL these places.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(name=\"component_js_dependencies\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"component_js_dependencies\",\n        end_tag=None,  # inline-only\n    )\n)\ndef component_js_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode:\n    \"\"\"\n    Marks location where JS link tags should be rendered after the whole HTML has been generated.\n\n    Generally, this should be inserted at the end of the `&lt;body&gt;` tag of the HTML.\n\n    If the generated HTML does NOT contain any `{% component_js_dependencies %}` tags, JS scripts\n    are by default inserted at the end of the `&lt;body&gt;` tag of the HTML. (See\n    [JS and CSS output locations](../../concepts/advanced/rendering_js_css/#js-and-css-output-locations))\n\n    Note that there should be only one `{% component_js_dependencies %}` for the whole HTML document.\n    If you insert this tag multiple times, ALL JS scripts will be duplicately inserted into ALL these places.\n    \"\"\"\n    # Parse to check that the syntax is valid\n    _parse_tag(parser, token, tag_spec)\n    return _component_dependencies(\"js\")\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.fill","title":"fill","text":"<pre><code>fill(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; FillNode\n</code></pre> <p>Use this tag to insert content into component's slots.</p> <p><code>{% fill %}</code> tag may be used only within a <code>{% component %}..{% endcomponent %}</code> block. Runtime checks should prohibit other usages.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Name of the slot to insert this content into. Use <code>\"default\"</code> for     the default slot.</li> <li><code>default</code> (str, optional): This argument allows you to access the original content of the slot     under the specified variable name. See     Accessing original content of slots</li> <li><code>data</code> (str, optional): This argument allows you to access the data passed to the slot     under the specified variable name. See Scoped slots</li> </ul> <p>Examples:</p> <p>Basic usage: <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre></p>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.fill--accessing-slots-default-content-with-the-default-kwarg","title":"Accessing slot's default content with the <code>default</code> kwarg","text":"<pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" default=\"default_pag\" %}\n    &lt;div class=\"my-class\"&gt;\n      {{ default_pag }}\n    &lt;/div&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.fill--accessing-slots-data-with-the-data-kwarg","title":"Accessing slot's data with the <code>data</code> kwarg","text":"<pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" pages=pages %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" data=\"slot_data\" %}\n    {% for page in slot_data.pages %}\n        &lt;a href=\"{{ page.link }}\"&gt;\n          {{ page.index }}\n        &lt;/a&gt;\n    {% endfor %}\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.fill--accessing-slot-data-and-default-content-on-the-default-slot","title":"Accessing slot data and default content on the default slot","text":"<p>To access slot data and the default slot content on the default slot, use <code>{% fill %}</code> with <code>name</code> set to <code>\"default\"</code>:</p> <pre><code>{% component \"button\" %}\n  {% fill name=\"default\" data=\"slot_data\" default=\"default_slot\" %}\n    You clicked me {{ slot_data.count }} times!\n    {{ default_slot }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"fill\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"fill\",\n        end_tag=\"endfill\",\n        positional_only_args=[],\n        pos_or_keyword_args=[SLOT_NAME_KWARG],\n        keywordonly_args=[SLOT_DATA_KWARG, SLOT_DEFAULT_KWARG],\n        optional_kwargs=[SLOT_DATA_KWARG, SLOT_DEFAULT_KWARG],\n        repeatable_kwargs=False,\n    )\n)\ndef fill(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; FillNode:\n    \"\"\"\n    Use this tag to insert content into component's slots.\n\n    `{% fill %}` tag may be used only within a `{% component %}..{% endcomponent %}` block.\n    Runtime checks should prohibit other usages.\n\n    **Args:**\n\n    - `name` (str, required): Name of the slot to insert this content into. Use `\"default\"` for\n        the default slot.\n    - `default` (str, optional): This argument allows you to access the original content of the slot\n        under the specified variable name. See\n        [Accessing original content of slots](../../concepts/fundamentals/slots#accessing-original-content-of-slots)\n    - `data` (str, optional): This argument allows you to access the data passed to the slot\n        under the specified variable name. See [Scoped slots](../../concepts/fundamentals/slots#scoped-slots)\n\n    **Examples:**\n\n    Basic usage:\n    ```django\n    {% component \"my_table\" %}\n      {% fill \"pagination\" %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Accessing slot's default content with the `default` kwarg\n\n    ```django\n    {# my_table.html #}\n    &lt;table&gt;\n      ...\n      {% slot \"pagination\" %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endslot %}\n    &lt;/table&gt;\n    ```\n\n    ```django\n    {% component \"my_table\" %}\n      {% fill \"pagination\" default=\"default_pag\" %}\n        &lt;div class=\"my-class\"&gt;\n          {{ default_pag }}\n        &lt;/div&gt;\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Accessing slot's data with the `data` kwarg\n\n    ```django\n    {# my_table.html #}\n    &lt;table&gt;\n      ...\n      {% slot \"pagination\" pages=pages %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endslot %}\n    &lt;/table&gt;\n    ```\n\n    ```django\n    {% component \"my_table\" %}\n      {% fill \"pagination\" data=\"slot_data\" %}\n        {% for page in slot_data.pages %}\n            &lt;a href=\"{{ page.link }}\"&gt;\n              {{ page.index }}\n            &lt;/a&gt;\n        {% endfor %}\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Accessing slot data and default content on the default slot\n\n    To access slot data and the default slot content on the default slot,\n    use `{% fill %}` with `name` set to `\"default\"`:\n\n    ```django\n    {% component \"button\" %}\n      {% fill name=\"default\" data=\"slot_data\" default=\"default_slot\" %}\n        You clicked me {{ slot_data.count }} times!\n        {{ default_slot }}\n      {% endfill %}\n    {% endcomponent %}\n    ```\n    \"\"\"\n    tag = _parse_tag(parser, token, tag_spec)\n\n    fill_name_kwarg = tag.kwargs.kwargs.get(SLOT_NAME_KWARG, None)\n    trace_id = f\"fill-id-{tag.id} ({fill_name_kwarg})\" if fill_name_kwarg else f\"fill-id-{tag.id}\"\n\n    trace_msg(\"PARSE\", \"FILL\", trace_id, tag.id)\n\n    body = tag.parse_body()\n    fill_node = FillNode(\n        nodelist=body,\n        node_id=tag.id,\n        kwargs=tag.kwargs,\n        trace_id=trace_id,\n    )\n\n    trace_msg(\"PARSE\", \"FILL\", trace_id, tag.id, \"...Done!\")\n    return fill_node\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.html_attrs","title":"html_attrs","text":"<pre><code>html_attrs(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; HtmlAttrsNode\n</code></pre> <p>Generate HTML attributes (<code>key=\"value\"</code>), combining data from multiple sources, whether its template variables or static text.</p> <p>It is designed to easily merge HTML attributes passed from outside with the internal. See how to in Passing HTML attributes to components.</p> <p>Args:</p> <ul> <li><code>attrs</code> (dict, optional): Optional dictionary that holds HTML attributes. On conflict, overrides     values in the <code>default</code> dictionary.</li> <li><code>default</code> (str, optional): Optional dictionary that holds HTML attributes. On conflict, is overriden     with values in the <code>attrs</code> dictionary.</li> <li>Any extra kwargs will be appended to the corresponding keys</li> </ul> <p>The attributes in <code>attrs</code> and <code>defaults</code> are merged and resulting dict is rendered as HTML attributes (<code>key=\"value\"</code>).</p> <p>Extra kwargs (<code>key=value</code>) are concatenated to existing keys. So if we have</p> <pre><code>attrs = {\"class\": \"my-class\"}\n</code></pre> <p>Then</p> <pre><code>{% html_attrs attrs class=\"extra-class\" %}\n</code></pre> <p>will result in <code>class=\"my-class extra-class\"</code>.</p> <p>Example: <pre><code>&lt;div {% html_attrs\n    attrs\n    defaults:class=\"default-class\"\n    class=\"extra-class\"\n    data-id=\"123\"\n%}&gt;\n</code></pre></p> <p>renders</p> <pre><code>&lt;div class=\"my-class extra-class\" data-id=\"123\"&gt;\n</code></pre> <p>See more usage examples in HTML attributes.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"html_attrs\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"html_attrs\",\n        end_tag=None,  # inline-only\n        positional_only_args=[],\n        pos_or_keyword_args=[HTML_ATTRS_ATTRS_KEY, HTML_ATTRS_DEFAULTS_KEY],\n        optional_kwargs=[HTML_ATTRS_ATTRS_KEY, HTML_ATTRS_DEFAULTS_KEY],\n        keywordonly_args=True,\n        repeatable_kwargs=True,\n        flags=[],\n    )\n)\ndef html_attrs(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; HtmlAttrsNode:\n    \"\"\"\n    Generate HTML attributes (`key=\"value\"`), combining data from multiple sources,\n    whether its template variables or static text.\n\n    It is designed to easily merge HTML attributes passed from outside with the internal.\n    See how to in [Passing HTML attributes to components](../../guides/howto/passing_html_attrs/).\n\n    **Args:**\n\n    - `attrs` (dict, optional): Optional dictionary that holds HTML attributes. On conflict, overrides\n        values in the `default` dictionary.\n    - `default` (str, optional): Optional dictionary that holds HTML attributes. On conflict, is overriden\n        with values in the `attrs` dictionary.\n    - Any extra kwargs will be appended to the corresponding keys\n\n    The attributes in `attrs` and `defaults` are merged and resulting dict is rendered as HTML attributes\n    (`key=\"value\"`).\n\n    Extra kwargs (`key=value`) are concatenated to existing keys. So if we have\n\n    ```python\n    attrs = {\"class\": \"my-class\"}\n    ```\n\n    Then\n\n    ```django\n    {% html_attrs attrs class=\"extra-class\" %}\n    ```\n\n    will result in `class=\"my-class extra-class\"`.\n\n    **Example:**\n    ```django\n    &lt;div {% html_attrs\n        attrs\n        defaults:class=\"default-class\"\n        class=\"extra-class\"\n        data-id=\"123\"\n    %}&gt;\n    ```\n\n    renders\n\n    ```html\n    &lt;div class=\"my-class extra-class\" data-id=\"123\"&gt;\n    ```\n\n    **See more usage examples in\n    [HTML attributes](../../concepts/fundamentals/html_attributes#examples-for-html_attrs).**\n    \"\"\"\n    tag = _parse_tag(parser, token, tag_spec)\n\n    return HtmlAttrsNode(\n        kwargs=tag.kwargs,\n        kwarg_pairs=tag.kwarg_pairs,\n    )\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.provide","title":"provide","text":"<pre><code>provide(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; ProvideNode\n</code></pre> <p>The \"provider\" part of the provide / inject feature. Pass kwargs to this tag to define the provider's data. Any components defined within the <code>{% provide %}..{% endprovide %}</code> tags will be able to access this data with <code>Component.inject()</code>.</p> <p>This is similar to React's <code>ContextProvider</code>, or Vue's <code>provide()</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Provider name. This is the name you will then use in     <code>Component.inject()</code>.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the provided data.</li> </ul> <p>Example:</p> <p>Provide the \"user_data\" in parent component:</p> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% provide \"user_data\" user=user %}\n          {% component \"child\" / %}\n        {% endprovide %}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_context_data(self, user: User):\n        return {\n            \"user\": user,\n        }\n</code></pre> <p>Since the \"child\" component is used within the <code>{% provide %} / {% endprovide %}</code> tags, we can request the \"user_data\" using <code>Component.inject(\"user_data\")</code>:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        User is: {{ user }}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_context_data(self):\n        user = self.inject(\"user_data\").user\n        return {\n            \"user\": user,\n        }\n</code></pre> <p>Notice that the keys defined on the <code>{% provide %}</code> tag are then accessed as attributes when accessing them with <code>Component.inject()</code>.</p> <p>\u2705 Do this <pre><code>user = self.inject(\"user_data\").user\n</code></pre></p> <p>\u274c Don't do this <pre><code>user = self.inject(\"user_data\")[\"user\"]\n</code></pre></p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"provide\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"provide\",\n        end_tag=\"endprovide\",\n        positional_only_args=[],\n        pos_or_keyword_args=[PROVIDE_NAME_KWARG],\n        keywordonly_args=True,\n        repeatable_kwargs=False,\n        flags=[],\n    )\n)\ndef provide(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; ProvideNode:\n    \"\"\"\n    The \"provider\" part of the [provide / inject feature](../../concepts/advanced/provide_inject).\n    Pass kwargs to this tag to define the provider's data.\n    Any components defined within the `{% provide %}..{% endprovide %}` tags will be able to access this data\n    with [`Component.inject()`](../api#django_components.Component.inject).\n\n    This is similar to React's [`ContextProvider`](https://react.dev/learn/passing-data-deeply-with-context),\n    or Vue's [`provide()`](https://vuejs.org/guide/components/provide-inject).\n\n    **Args:**\n\n    - `name` (str, required): Provider name. This is the name you will then use in\n        [`Component.inject()`](../api#django_components.Component.inject).\n    - `**kwargs`: Any extra kwargs will be passed as the provided data.\n\n    **Example:**\n\n    Provide the \"user_data\" in parent component:\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% provide \"user_data\" user=user %}\n              {% component \"child\" / %}\n            {% endprovide %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n\n        def get_context_data(self, user: User):\n            return {\n                \"user\": user,\n            }\n    ```\n\n    Since the \"child\" component is used within the `{% provide %} / {% endprovide %}` tags,\n    we can request the \"user_data\" using `Component.inject(\"user_data\")`:\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            User is: {{ user }}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n\n        def get_context_data(self):\n            user = self.inject(\"user_data\").user\n            return {\n                \"user\": user,\n            }\n    ```\n\n    Notice that the keys defined on the `{% provide %}` tag are then accessed as attributes\n    when accessing them with [`Component.inject()`](../api#django_components.Component.inject).\n\n    \u2705 Do this\n    ```python\n    user = self.inject(\"user_data\").user\n    ```\n\n    \u274c Don't do this\n    ```python\n    user = self.inject(\"user_data\")[\"user\"]\n    ```\n    \"\"\"\n    # e.g. {% provide &lt;name&gt; key=val key2=val2 %}\n    tag = _parse_tag(parser, token, tag_spec)\n\n    name_kwarg = tag.kwargs.kwargs.get(PROVIDE_NAME_KWARG, None)\n    trace_id = f\"provide-id-{tag.id} ({name_kwarg})\" if name_kwarg else f\"fill-id-{tag.id}\"\n\n    trace_msg(\"PARSE\", \"PROVIDE\", trace_id, tag.id)\n\n    body = tag.parse_body()\n    provide_node = ProvideNode(\n        nodelist=body,\n        node_id=tag.id,\n        kwargs=tag.kwargs,\n        trace_id=trace_id,\n    )\n\n    trace_msg(\"PARSE\", \"PROVIDE\", trace_id, tag.id, \"...Done!\")\n    return provide_node\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.slot","title":"slot","text":"<pre><code>slot(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; SlotNode\n</code></pre> <p>Slot tag marks a place inside a component where content can be inserted from outside.</p> <p>Learn more about using slots.</p> <p>This is similar to slots as seen in Web components, Vue or React's <code>children</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Registered name of the component to render</li> <li><code>default</code>: Optional flag. If there is a default slot, you can pass the component slot content     without using the <code>{% fill %}</code> tag. See     Default slot</li> <li><code>required</code>: Optional flag. Will raise an error if a slot is required but not given.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the slot data.</li> </ul> <p>Example:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" default %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n      &lt;aside&gt;\n        {% slot \"sidebar\" required / %}\n      &lt;/aside&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% component \"child\" %}\n          {% fill \"content\" %}\n            \ud83d\uddde\ufe0f\ud83d\udcf0\n          {% endfill %}\n\n          {% fill \"sidebar\" %}\n            \ud83c\udf77\ud83e\uddc9\ud83c\udf7e\n          {% endfill %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.slot--passing-data-to-slots","title":"Passing data to slots","text":"<p>Any extra kwargs will be considered as slot data, and will be accessible in the <code>{% fill %}</code> tag via fill's <code>data</code> kwarg:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {# Passing data to the slot #}\n        {% slot \"content\" user=user %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot data #}\n      {% component \"child\" %}\n        {% fill \"content\" data=\"data\" %}\n          &lt;div class=\"wrapper-class\"&gt;\n            {{ data.user }}\n          &lt;/div&gt;\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.slot--accessing-default-slot-content","title":"Accessing default slot content","text":"<p>The content between the <code>{% slot %}..{% endslot %}</code> tags is the default content that will be rendered if no fill is given for the slot.</p> <p>This default content can then be accessed from within the <code>{% fill %}</code> tag using the fill's <code>default</code> kwarg. This is useful if you need to wrap / prepend / append the original slot's content.</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" %}\n          This is default content!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot's default content #}\n      {% component \"child\" %}\n        {% fill \"content\" default=\"default\" %}\n          {{ default }}\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"slot\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"slot\",\n        end_tag=\"endslot\",\n        positional_only_args=[],\n        pos_or_keyword_args=[SLOT_NAME_KWARG],\n        keywordonly_args=True,\n        repeatable_kwargs=False,\n        flags=[SLOT_DEFAULT_KEYWORD, SLOT_REQUIRED_KEYWORD],\n    )\n)\ndef slot(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; SlotNode:\n    \"\"\"\n    Slot tag marks a place inside a component where content can be inserted\n    from outside.\n\n    [Learn more](../../concepts/fundamentals/slots) about using slots.\n\n    This is similar to slots as seen in\n    [Web components](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot),\n    [Vue](https://vuejs.org/guide/components/slots.html)\n    or [React's `children`](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children).\n\n    **Args:**\n\n    - `name` (str, required): Registered name of the component to render\n    - `default`: Optional flag. If there is a default slot, you can pass the component slot content\n        without using the [`{% fill %}`](#fill) tag. See\n        [Default slot](../../concepts/fundamentals/slots#default-slot)\n    - `required`: Optional flag. Will raise an error if a slot is required but not given.\n    - `**kwargs`: Any extra kwargs will be passed as the slot data.\n\n    **Example:**\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% slot \"content\" default %}\n              This is shown if not overriden!\n            {% endslot %}\n          &lt;/div&gt;\n          &lt;aside&gt;\n            {% slot \"sidebar\" required / %}\n          &lt;/aside&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% component \"child\" %}\n              {% fill \"content\" %}\n                \ud83d\uddde\ufe0f\ud83d\udcf0\n              {% endfill %}\n\n              {% fill \"sidebar\" %}\n                \ud83c\udf77\ud83e\uddc9\ud83c\udf7e\n              {% endfill %}\n            {% endcomponent %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ### Passing data to slots\n\n    Any extra kwargs will be considered as slot data, and will be accessible in the [`{% fill %}`](#fill)\n    tag via fill's `data` kwarg:\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {# Passing data to the slot #}\n            {% slot \"content\" user=user %}\n              This is shown if not overriden!\n            {% endslot %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          {# Parent can access the slot data #}\n          {% component \"child\" %}\n            {% fill \"content\" data=\"data\" %}\n              &lt;div class=\"wrapper-class\"&gt;\n                {{ data.user }}\n              &lt;/div&gt;\n            {% endfill %}\n          {% endcomponent %}\n        \\\"\\\"\\\"\n    ```\n\n    ### Accessing default slot content\n\n    The content between the `{% slot %}..{% endslot %}` tags is the default content that\n    will be rendered if no fill is given for the slot.\n\n    This default content can then be accessed from within the [`{% fill %}`](#fill) tag using\n    the fill's `default` kwarg.\n    This is useful if you need to wrap / prepend / append the original slot's content.\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% slot \"content\" %}\n              This is default content!\n            {% endslot %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          {# Parent can access the slot's default content #}\n          {% component \"child\" %}\n            {% fill \"content\" default=\"default\" %}\n              {{ default }}\n            {% endfill %}\n          {% endcomponent %}\n        \\\"\\\"\\\"\n    ```\n    \"\"\"\n    tag = _parse_tag(parser, token, tag_spec)\n\n    slot_name_kwarg = tag.kwargs.kwargs.get(SLOT_NAME_KWARG, None)\n    trace_id = f\"slot-id-{tag.id} ({slot_name_kwarg})\" if slot_name_kwarg else f\"slot-id-{tag.id}\"\n\n    trace_msg(\"PARSE\", \"SLOT\", trace_id, tag.id)\n\n    body = tag.parse_body()\n    slot_node = SlotNode(\n        nodelist=body,\n        node_id=tag.id,\n        kwargs=tag.kwargs,\n        is_required=tag.flags[SLOT_REQUIRED_KEYWORD],\n        is_default=tag.flags[SLOT_DEFAULT_KEYWORD],\n        trace_id=trace_id,\n    )\n\n    trace_msg(\"PARSE\", \"SLOT\", trace_id, tag.id, \"...Done!\")\n    return slot_node\n</code></pre>"},{"location":"reference/django_components/templatetags/#django_components.templatetags.component_tags.with_tag_spec","title":"with_tag_spec","text":"<pre><code>with_tag_spec(tag_spec: TagSpec) -&gt; Callable\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def with_tag_spec(tag_spec: TagSpec) -&gt; Callable:\n    \"\"\"\"\"\"\n\n    def decorator(fn: Callable) -&gt; Any:\n        fn._tag_spec = tag_spec  # type: ignore[attr-defined]\n\n        @functools.wraps(fn)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            return fn(*args, **kwargs, tag_spec=tag_spec)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> component_tags","text":""},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags","title":"component_tags","text":"<p>Functions:</p> <ul> <li> <code>component</code>             \u2013              <p>Renders one of the components that was previously registered with</p> </li> <li> <code>component_css_dependencies</code>             \u2013              <p>Marks location where CSS link tags should be rendered after the whole HTML has been generated.</p> </li> <li> <code>component_js_dependencies</code>             \u2013              <p>Marks location where JS link tags should be rendered after the whole HTML has been generated.</p> </li> <li> <code>fill</code>             \u2013              <p>Use this tag to insert content into component's slots.</p> </li> <li> <code>html_attrs</code>             \u2013              <p>Generate HTML attributes (<code>key=\"value\"</code>), combining data from multiple sources,</p> </li> <li> <code>provide</code>             \u2013              <p>The \"provider\" part of the provide / inject feature.</p> </li> <li> <code>slot</code>             \u2013              <p>Slot tag marks a place inside a component where content can be inserted</p> </li> </ul>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.TagSpec","title":"TagSpec","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Definition of args, kwargs, flags, etc, for a template tag.</p> <p>Attributes:</p> <ul> <li> <code>end_tag</code>               (<code>Optional[str]</code>)           \u2013            <p>End tag.</p> </li> <li> <code>flags</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>List of allowed flags.</p> </li> <li> <code>keywordonly_args</code>               (<code>Optional[Union[bool, List[str]]]</code>)           \u2013            <p>Parameters that MUST be given only as kwargs (not accounting for <code>pos_or_keyword_args</code>).</p> </li> <li> <code>optional_kwargs</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Specify which kwargs can be optional.</p> </li> <li> <code>pos_or_keyword_args</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Like regular Python kwargs, these can be given EITHER as positional OR as keyword arguments.</p> </li> <li> <code>positional_args_allow_extra</code>               (<code>bool</code>)           \u2013            <p>If <code>True</code>, allows variable number of positional args, e.g. <code>{% mytag val1 1234 val2 890 ... %}</code></p> </li> <li> <code>positional_only_args</code>               (<code>Optional[List[str]]</code>)           \u2013            <p>Arguments that MUST be given as positional args.</p> </li> <li> <code>repeatable_kwargs</code>               (<code>Optional[Union[bool, List[str]]]</code>)           \u2013            <p>Whether this tag allows all or certain kwargs to be repeated.</p> </li> <li> <code>tag</code>               (<code>str</code>)           \u2013            <p>Tag name. E.g. <code>\"slot\"</code> means the tag is written like so <code>{% slot ... %}</code></p> </li> </ul>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.TagSpec.end_tag","title":"end_tag  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>end_tag: Optional[str] = None\n</code></pre> <p>End tag.</p> <p>E.g. <code>\"endslot\"</code> means anything between the start tag and <code>{% endslot %}</code> is considered the slot's body.</p>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.TagSpec.flags","title":"flags  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flags: Optional[List[str]] = None\n</code></pre> <p>List of allowed flags.</p> <p>Flags are like kwargs, but without the value part. E.g. in <code>{% mytag only required %}</code>: - <code>only</code> and <code>required</code> are treated as <code>only=True</code> and <code>required=True</code> if present - and treated as <code>only=False</code> and <code>required=False</code> if omitted</p>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.TagSpec.keywordonly_args","title":"keywordonly_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>keywordonly_args: Optional[Union[bool, List[str]]] = False\n</code></pre> <p>Parameters that MUST be given only as kwargs (not accounting for <code>pos_or_keyword_args</code>).</p> <ul> <li>If <code>False</code>, NO extra kwargs allowed.</li> <li>If <code>True</code>, ANY number of extra kwargs allowed.</li> <li>If a list of strings, e.g. <code>[\"class\", \"style\"]</code>, then only those kwargs are allowed.</li> </ul>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.TagSpec.optional_kwargs","title":"optional_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>optional_kwargs: Optional[List[str]] = None\n</code></pre> <p>Specify which kwargs can be optional.</p>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.TagSpec.pos_or_keyword_args","title":"pos_or_keyword_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pos_or_keyword_args: Optional[List[str]] = None\n</code></pre> <p>Like regular Python kwargs, these can be given EITHER as positional OR as keyword arguments.</p>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.TagSpec.positional_args_allow_extra","title":"positional_args_allow_extra  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>positional_args_allow_extra: bool = False\n</code></pre> <p>If <code>True</code>, allows variable number of positional args, e.g. <code>{% mytag val1 1234 val2 890 ... %}</code></p>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.TagSpec.positional_only_args","title":"positional_only_args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>positional_only_args: Optional[List[str]] = None\n</code></pre> <p>Arguments that MUST be given as positional args.</p>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.TagSpec.repeatable_kwargs","title":"repeatable_kwargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>repeatable_kwargs: Optional[Union[bool, List[str]]] = False\n</code></pre> <p>Whether this tag allows all or certain kwargs to be repeated.</p> <ul> <li>If <code>False</code>, NO kwargs can repeat.</li> <li>If <code>True</code>, ALL kwargs can repeat.</li> <li>If a list of strings, e.g. <code>[\"class\", \"style\"]</code>, then only those kwargs can repeat.</li> </ul> <p>E.g. <code>[\"class\"]</code> means one can write <code>{% mytag class=\"one\" class=\"two\" %}</code></p>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.TagSpec.tag","title":"tag  <code>instance-attribute</code>","text":"<pre><code>tag: str\n</code></pre> <p>Tag name. E.g. <code>\"slot\"</code> means the tag is written like so <code>{% slot ... %}</code></p>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.component","title":"component","text":"<pre><code>component(parser: Parser, token: Token, registry: ComponentRegistry, tag_name: str, tag_spec: TagSpec) -&gt; ComponentNode\n</code></pre> <p>Renders one of the components that was previously registered with <code>@register()</code> decorator.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Registered name of the component to render</li> <li>All other args and kwargs are defined based on the component itself.</li> </ul> <p>If you defined a component <code>\"my_table\"</code></p> <pre><code>from django_component import Component, register\n\n@register(\"my_table\")\nclass MyTable(Component):\n    template = \"\"\"\n      &lt;table&gt;\n        &lt;thead&gt;\n          {% for header in headers %}\n            &lt;th&gt;{{ header }}&lt;/th&gt;\n          {% endfor %}\n        &lt;/thead&gt;\n        &lt;tbody&gt;\n          {% for row in rows %}\n            &lt;tr&gt;\n              {% for cell in row %}\n                &lt;td&gt;{{ cell }}&lt;/td&gt;\n              {% endfor %}\n            &lt;/tr&gt;\n          {% endfor %}\n        &lt;tbody&gt;\n      &lt;/table&gt;\n    \"\"\"\n\n    def get_context_data(self, rows: List, headers: List):\n        return {\n            \"rows\": rows,\n            \"headers\": headers,\n        }\n</code></pre> <p>Then you can render this component by referring to <code>MyTable</code> via its registered name <code>\"my_table\"</code>:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.component--component-input","title":"Component input","text":"<p>Positional and keyword arguments can be literals or template variables.</p> <p>The component name must be a single- or double-quotes string and must be either:</p> <ul> <li> <p>The first positional argument after <code>component</code>:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n</code></pre> </li> <li> <p>Passed as kwarg <code>name</code>:</p> <pre><code>{% component rows=rows headers=headers name=\"my_table\" ... / %}\n</code></pre> </li> </ul>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.component--inserting-into-slots","title":"Inserting into slots","text":"<p>If the component defined any slots, you can pass in the content to be placed inside those slots by inserting <code>{% fill %}</code> tags, directly within the <code>{% component %}</code> tag:</p> <pre><code>{% component \"my_table\" rows=rows headers=headers ... / %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.component--isolating-components","title":"Isolating components","text":"<p>By default, components behave similarly to Django's <code>{% include %}</code>, and the template inside the component has access to the variables defined in the outer template.</p> <p>You can selectively isolate a component, using the <code>only</code> flag, so that the inner template can access only the data that was explicitly passed to it:</p> <pre><code>{% component \"name\" positional_arg keyword_arg=value ... only %}\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@with_tag_spec(\n    TagSpec(\n        tag=\"component\",\n        end_tag=\"endcomponent\",\n        positional_only_args=[],\n        positional_args_allow_extra=True,  # Allow many args\n        keywordonly_args=True,\n        repeatable_kwargs=False,\n        flags=[COMP_ONLY_FLAG],\n    )\n)\ndef component(\n    parser: Parser,\n    token: Token,\n    registry: ComponentRegistry,\n    tag_name: str,\n    tag_spec: TagSpec,\n) -&gt; ComponentNode:\n    \"\"\"\n    Renders one of the components that was previously registered with\n    [`@register()`](./api.md#django_components.register)\n    decorator.\n\n    **Args:**\n\n    - `name` (str, required): Registered name of the component to render\n    - All other args and kwargs are defined based on the component itself.\n\n    If you defined a component `\"my_table\"`\n\n    ```python\n    from django_component import Component, register\n\n    @register(\"my_table\")\n    class MyTable(Component):\n        template = \\\"\\\"\\\"\n          &lt;table&gt;\n            &lt;thead&gt;\n              {% for header in headers %}\n                &lt;th&gt;{{ header }}&lt;/th&gt;\n              {% endfor %}\n            &lt;/thead&gt;\n            &lt;tbody&gt;\n              {% for row in rows %}\n                &lt;tr&gt;\n                  {% for cell in row %}\n                    &lt;td&gt;{{ cell }}&lt;/td&gt;\n                  {% endfor %}\n                &lt;/tr&gt;\n              {% endfor %}\n            &lt;tbody&gt;\n          &lt;/table&gt;\n        \\\"\\\"\\\"\n\n        def get_context_data(self, rows: List, headers: List):\n            return {\n                \"rows\": rows,\n                \"headers\": headers,\n            }\n    ```\n\n    Then you can render this component by referring to `MyTable` via its\n    registered name `\"my_table\"`:\n\n    ```django\n    {% component \"my_table\" rows=rows headers=headers ... / %}\n    ```\n\n    ### Component input\n\n    Positional and keyword arguments can be literals or template variables.\n\n    The component name must be a single- or double-quotes string and must\n    be either:\n\n    - The first positional argument after `component`:\n\n        ```django\n        {% component \"my_table\" rows=rows headers=headers ... / %}\n        ```\n\n    - Passed as kwarg `name`:\n\n        ```django\n        {% component rows=rows headers=headers name=\"my_table\" ... / %}\n        ```\n\n    ### Inserting into slots\n\n    If the component defined any [slots](../concepts/fundamentals/slots.md), you can\n    pass in the content to be placed inside those slots by inserting [`{% fill %}`](#fill) tags,\n    directly within the `{% component %}` tag:\n\n    ```django\n    {% component \"my_table\" rows=rows headers=headers ... / %}\n      {% fill \"pagination\" %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Isolating components\n\n    By default, components behave similarly to Django's\n    [`{% include %}`](https://docs.djangoproject.com/en/5.1/ref/templates/builtins/#include),\n    and the template inside the component has access to the variables defined in the outer template.\n\n    You can selectively isolate a component, using the `only` flag, so that the inner template\n    can access only the data that was explicitly passed to it:\n\n    ```django\n    {% component \"name\" positional_arg keyword_arg=value ... only %}\n    ```\n    \"\"\"\n    _fix_nested_tags(parser, token)\n    bits = token.split_contents()\n\n    # Let the TagFormatter pre-process the tokens\n    formatter = get_tag_formatter(registry)\n    result = formatter.parse([*bits])\n    end_tag = formatter.end_tag(result.component_name)\n\n    # NOTE: The tokens returned from TagFormatter.parse do NOT include the tag itself\n    bits = [bits[0], *result.tokens]\n    token.contents = \" \".join(bits)\n\n    tag = _parse_tag(\n        parser,\n        token,\n        TagSpec(\n            **{\n                **tag_spec._asdict(),\n                \"tag\": tag_name,\n                \"end_tag\": end_tag,\n            }\n        ),\n    )\n\n    # Check for isolated context keyword\n    isolated_context = tag.flags[COMP_ONLY_FLAG]\n\n    trace_msg(\"PARSE\", \"COMP\", result.component_name, tag.id)\n\n    body = tag.parse_body()\n\n    component_node = ComponentNode(\n        name=result.component_name,\n        args=tag.args,\n        kwargs=tag.kwargs,\n        isolated_context=isolated_context,\n        nodelist=body,\n        node_id=tag.id,\n        registry=registry,\n    )\n\n    trace_msg(\"PARSE\", \"COMP\", result.component_name, tag.id, \"...Done!\")\n    return component_node\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.component_css_dependencies","title":"component_css_dependencies","text":"<pre><code>component_css_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode\n</code></pre> <p>Marks location where CSS link tags should be rendered after the whole HTML has been generated.</p> <p>Generally, this should be inserted into the <code>&lt;head&gt;</code> tag of the HTML.</p> <p>If the generated HTML does NOT contain any <code>{% component_css_dependencies %}</code> tags, CSS links are by default inserted into the <code>&lt;head&gt;</code> tag of the HTML. (See JS and CSS output locations)</p> <p>Note that there should be only one <code>{% component_css_dependencies %}</code> for the whole HTML document. If you insert this tag multiple times, ALL CSS links will be duplicately inserted into ALL these places.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"component_css_dependencies\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"component_css_dependencies\",\n        end_tag=None,  # inline-only\n    )\n)\ndef component_css_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode:\n    \"\"\"\n    Marks location where CSS link tags should be rendered after the whole HTML has been generated.\n\n    Generally, this should be inserted into the `&lt;head&gt;` tag of the HTML.\n\n    If the generated HTML does NOT contain any `{% component_css_dependencies %}` tags, CSS links\n    are by default inserted into the `&lt;head&gt;` tag of the HTML. (See\n    [JS and CSS output locations](../../concepts/advanced/rendering_js_css/#js-and-css-output-locations))\n\n    Note that there should be only one `{% component_css_dependencies %}` for the whole HTML document.\n    If you insert this tag multiple times, ALL CSS links will be duplicately inserted into ALL these places.\n    \"\"\"\n    # Parse to check that the syntax is valid\n    _parse_tag(parser, token, tag_spec)\n    return _component_dependencies(\"css\")\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.component_js_dependencies","title":"component_js_dependencies","text":"<pre><code>component_js_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode\n</code></pre> <p>Marks location where JS link tags should be rendered after the whole HTML has been generated.</p> <p>Generally, this should be inserted at the end of the <code>&lt;body&gt;</code> tag of the HTML.</p> <p>If the generated HTML does NOT contain any <code>{% component_js_dependencies %}</code> tags, JS scripts are by default inserted at the end of the <code>&lt;body&gt;</code> tag of the HTML. (See JS and CSS output locations)</p> <p>Note that there should be only one <code>{% component_js_dependencies %}</code> for the whole HTML document. If you insert this tag multiple times, ALL JS scripts will be duplicately inserted into ALL these places.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(name=\"component_js_dependencies\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"component_js_dependencies\",\n        end_tag=None,  # inline-only\n    )\n)\ndef component_js_dependencies(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; TextNode:\n    \"\"\"\n    Marks location where JS link tags should be rendered after the whole HTML has been generated.\n\n    Generally, this should be inserted at the end of the `&lt;body&gt;` tag of the HTML.\n\n    If the generated HTML does NOT contain any `{% component_js_dependencies %}` tags, JS scripts\n    are by default inserted at the end of the `&lt;body&gt;` tag of the HTML. (See\n    [JS and CSS output locations](../../concepts/advanced/rendering_js_css/#js-and-css-output-locations))\n\n    Note that there should be only one `{% component_js_dependencies %}` for the whole HTML document.\n    If you insert this tag multiple times, ALL JS scripts will be duplicately inserted into ALL these places.\n    \"\"\"\n    # Parse to check that the syntax is valid\n    _parse_tag(parser, token, tag_spec)\n    return _component_dependencies(\"js\")\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.fill","title":"fill","text":"<pre><code>fill(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; FillNode\n</code></pre> <p>Use this tag to insert content into component's slots.</p> <p><code>{% fill %}</code> tag may be used only within a <code>{% component %}..{% endcomponent %}</code> block. Runtime checks should prohibit other usages.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Name of the slot to insert this content into. Use <code>\"default\"</code> for     the default slot.</li> <li><code>default</code> (str, optional): This argument allows you to access the original content of the slot     under the specified variable name. See     Accessing original content of slots</li> <li><code>data</code> (str, optional): This argument allows you to access the data passed to the slot     under the specified variable name. See Scoped slots</li> </ul> <p>Examples:</p> <p>Basic usage: <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre></p>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.fill--accessing-slots-default-content-with-the-default-kwarg","title":"Accessing slot's default content with the <code>default</code> kwarg","text":"<pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" default=\"default_pag\" %}\n    &lt;div class=\"my-class\"&gt;\n      {{ default_pag }}\n    &lt;/div&gt;\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.fill--accessing-slots-data-with-the-data-kwarg","title":"Accessing slot's data with the <code>data</code> kwarg","text":"<pre><code>{# my_table.html #}\n&lt;table&gt;\n  ...\n  {% slot \"pagination\" pages=pages %}\n    &lt; 1 | 2 | 3 &gt;\n  {% endslot %}\n&lt;/table&gt;\n</code></pre> <pre><code>{% component \"my_table\" %}\n  {% fill \"pagination\" data=\"slot_data\" %}\n    {% for page in slot_data.pages %}\n        &lt;a href=\"{{ page.link }}\"&gt;\n          {{ page.index }}\n        &lt;/a&gt;\n    {% endfor %}\n  {% endfill %}\n{% endcomponent %}\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.fill--accessing-slot-data-and-default-content-on-the-default-slot","title":"Accessing slot data and default content on the default slot","text":"<p>To access slot data and the default slot content on the default slot, use <code>{% fill %}</code> with <code>name</code> set to <code>\"default\"</code>:</p> <pre><code>{% component \"button\" %}\n  {% fill name=\"default\" data=\"slot_data\" default=\"default_slot\" %}\n    You clicked me {{ slot_data.count }} times!\n    {{ default_slot }}\n  {% endfill %}\n{% endcomponent %}\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"fill\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"fill\",\n        end_tag=\"endfill\",\n        positional_only_args=[],\n        pos_or_keyword_args=[SLOT_NAME_KWARG],\n        keywordonly_args=[SLOT_DATA_KWARG, SLOT_DEFAULT_KWARG],\n        optional_kwargs=[SLOT_DATA_KWARG, SLOT_DEFAULT_KWARG],\n        repeatable_kwargs=False,\n    )\n)\ndef fill(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; FillNode:\n    \"\"\"\n    Use this tag to insert content into component's slots.\n\n    `{% fill %}` tag may be used only within a `{% component %}..{% endcomponent %}` block.\n    Runtime checks should prohibit other usages.\n\n    **Args:**\n\n    - `name` (str, required): Name of the slot to insert this content into. Use `\"default\"` for\n        the default slot.\n    - `default` (str, optional): This argument allows you to access the original content of the slot\n        under the specified variable name. See\n        [Accessing original content of slots](../../concepts/fundamentals/slots#accessing-original-content-of-slots)\n    - `data` (str, optional): This argument allows you to access the data passed to the slot\n        under the specified variable name. See [Scoped slots](../../concepts/fundamentals/slots#scoped-slots)\n\n    **Examples:**\n\n    Basic usage:\n    ```django\n    {% component \"my_table\" %}\n      {% fill \"pagination\" %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Accessing slot's default content with the `default` kwarg\n\n    ```django\n    {# my_table.html #}\n    &lt;table&gt;\n      ...\n      {% slot \"pagination\" %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endslot %}\n    &lt;/table&gt;\n    ```\n\n    ```django\n    {% component \"my_table\" %}\n      {% fill \"pagination\" default=\"default_pag\" %}\n        &lt;div class=\"my-class\"&gt;\n          {{ default_pag }}\n        &lt;/div&gt;\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Accessing slot's data with the `data` kwarg\n\n    ```django\n    {# my_table.html #}\n    &lt;table&gt;\n      ...\n      {% slot \"pagination\" pages=pages %}\n        &lt; 1 | 2 | 3 &gt;\n      {% endslot %}\n    &lt;/table&gt;\n    ```\n\n    ```django\n    {% component \"my_table\" %}\n      {% fill \"pagination\" data=\"slot_data\" %}\n        {% for page in slot_data.pages %}\n            &lt;a href=\"{{ page.link }}\"&gt;\n              {{ page.index }}\n            &lt;/a&gt;\n        {% endfor %}\n      {% endfill %}\n    {% endcomponent %}\n    ```\n\n    ### Accessing slot data and default content on the default slot\n\n    To access slot data and the default slot content on the default slot,\n    use `{% fill %}` with `name` set to `\"default\"`:\n\n    ```django\n    {% component \"button\" %}\n      {% fill name=\"default\" data=\"slot_data\" default=\"default_slot\" %}\n        You clicked me {{ slot_data.count }} times!\n        {{ default_slot }}\n      {% endfill %}\n    {% endcomponent %}\n    ```\n    \"\"\"\n    tag = _parse_tag(parser, token, tag_spec)\n\n    fill_name_kwarg = tag.kwargs.kwargs.get(SLOT_NAME_KWARG, None)\n    trace_id = f\"fill-id-{tag.id} ({fill_name_kwarg})\" if fill_name_kwarg else f\"fill-id-{tag.id}\"\n\n    trace_msg(\"PARSE\", \"FILL\", trace_id, tag.id)\n\n    body = tag.parse_body()\n    fill_node = FillNode(\n        nodelist=body,\n        node_id=tag.id,\n        kwargs=tag.kwargs,\n        trace_id=trace_id,\n    )\n\n    trace_msg(\"PARSE\", \"FILL\", trace_id, tag.id, \"...Done!\")\n    return fill_node\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.html_attrs","title":"html_attrs","text":"<pre><code>html_attrs(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; HtmlAttrsNode\n</code></pre> <p>Generate HTML attributes (<code>key=\"value\"</code>), combining data from multiple sources, whether its template variables or static text.</p> <p>It is designed to easily merge HTML attributes passed from outside with the internal. See how to in Passing HTML attributes to components.</p> <p>Args:</p> <ul> <li><code>attrs</code> (dict, optional): Optional dictionary that holds HTML attributes. On conflict, overrides     values in the <code>default</code> dictionary.</li> <li><code>default</code> (str, optional): Optional dictionary that holds HTML attributes. On conflict, is overriden     with values in the <code>attrs</code> dictionary.</li> <li>Any extra kwargs will be appended to the corresponding keys</li> </ul> <p>The attributes in <code>attrs</code> and <code>defaults</code> are merged and resulting dict is rendered as HTML attributes (<code>key=\"value\"</code>).</p> <p>Extra kwargs (<code>key=value</code>) are concatenated to existing keys. So if we have</p> <pre><code>attrs = {\"class\": \"my-class\"}\n</code></pre> <p>Then</p> <pre><code>{% html_attrs attrs class=\"extra-class\" %}\n</code></pre> <p>will result in <code>class=\"my-class extra-class\"</code>.</p> <p>Example: <pre><code>&lt;div {% html_attrs\n    attrs\n    defaults:class=\"default-class\"\n    class=\"extra-class\"\n    data-id=\"123\"\n%}&gt;\n</code></pre></p> <p>renders</p> <pre><code>&lt;div class=\"my-class extra-class\" data-id=\"123\"&gt;\n</code></pre> <p>See more usage examples in HTML attributes.</p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"html_attrs\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"html_attrs\",\n        end_tag=None,  # inline-only\n        positional_only_args=[],\n        pos_or_keyword_args=[HTML_ATTRS_ATTRS_KEY, HTML_ATTRS_DEFAULTS_KEY],\n        optional_kwargs=[HTML_ATTRS_ATTRS_KEY, HTML_ATTRS_DEFAULTS_KEY],\n        keywordonly_args=True,\n        repeatable_kwargs=True,\n        flags=[],\n    )\n)\ndef html_attrs(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; HtmlAttrsNode:\n    \"\"\"\n    Generate HTML attributes (`key=\"value\"`), combining data from multiple sources,\n    whether its template variables or static text.\n\n    It is designed to easily merge HTML attributes passed from outside with the internal.\n    See how to in [Passing HTML attributes to components](../../guides/howto/passing_html_attrs/).\n\n    **Args:**\n\n    - `attrs` (dict, optional): Optional dictionary that holds HTML attributes. On conflict, overrides\n        values in the `default` dictionary.\n    - `default` (str, optional): Optional dictionary that holds HTML attributes. On conflict, is overriden\n        with values in the `attrs` dictionary.\n    - Any extra kwargs will be appended to the corresponding keys\n\n    The attributes in `attrs` and `defaults` are merged and resulting dict is rendered as HTML attributes\n    (`key=\"value\"`).\n\n    Extra kwargs (`key=value`) are concatenated to existing keys. So if we have\n\n    ```python\n    attrs = {\"class\": \"my-class\"}\n    ```\n\n    Then\n\n    ```django\n    {% html_attrs attrs class=\"extra-class\" %}\n    ```\n\n    will result in `class=\"my-class extra-class\"`.\n\n    **Example:**\n    ```django\n    &lt;div {% html_attrs\n        attrs\n        defaults:class=\"default-class\"\n        class=\"extra-class\"\n        data-id=\"123\"\n    %}&gt;\n    ```\n\n    renders\n\n    ```html\n    &lt;div class=\"my-class extra-class\" data-id=\"123\"&gt;\n    ```\n\n    **See more usage examples in\n    [HTML attributes](../../concepts/fundamentals/html_attributes#examples-for-html_attrs).**\n    \"\"\"\n    tag = _parse_tag(parser, token, tag_spec)\n\n    return HtmlAttrsNode(\n        kwargs=tag.kwargs,\n        kwarg_pairs=tag.kwarg_pairs,\n    )\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.provide","title":"provide","text":"<pre><code>provide(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; ProvideNode\n</code></pre> <p>The \"provider\" part of the provide / inject feature. Pass kwargs to this tag to define the provider's data. Any components defined within the <code>{% provide %}..{% endprovide %}</code> tags will be able to access this data with <code>Component.inject()</code>.</p> <p>This is similar to React's <code>ContextProvider</code>, or Vue's <code>provide()</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Provider name. This is the name you will then use in     <code>Component.inject()</code>.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the provided data.</li> </ul> <p>Example:</p> <p>Provide the \"user_data\" in parent component:</p> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% provide \"user_data\" user=user %}\n          {% component \"child\" / %}\n        {% endprovide %}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_context_data(self, user: User):\n        return {\n            \"user\": user,\n        }\n</code></pre> <p>Since the \"child\" component is used within the <code>{% provide %} / {% endprovide %}</code> tags, we can request the \"user_data\" using <code>Component.inject(\"user_data\")</code>:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        User is: {{ user }}\n      &lt;/div&gt;\n    \"\"\"\n\n    def get_context_data(self):\n        user = self.inject(\"user_data\").user\n        return {\n            \"user\": user,\n        }\n</code></pre> <p>Notice that the keys defined on the <code>{% provide %}</code> tag are then accessed as attributes when accessing them with <code>Component.inject()</code>.</p> <p>\u2705 Do this <pre><code>user = self.inject(\"user_data\").user\n</code></pre></p> <p>\u274c Don't do this <pre><code>user = self.inject(\"user_data\")[\"user\"]\n</code></pre></p> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"provide\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"provide\",\n        end_tag=\"endprovide\",\n        positional_only_args=[],\n        pos_or_keyword_args=[PROVIDE_NAME_KWARG],\n        keywordonly_args=True,\n        repeatable_kwargs=False,\n        flags=[],\n    )\n)\ndef provide(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; ProvideNode:\n    \"\"\"\n    The \"provider\" part of the [provide / inject feature](../../concepts/advanced/provide_inject).\n    Pass kwargs to this tag to define the provider's data.\n    Any components defined within the `{% provide %}..{% endprovide %}` tags will be able to access this data\n    with [`Component.inject()`](../api#django_components.Component.inject).\n\n    This is similar to React's [`ContextProvider`](https://react.dev/learn/passing-data-deeply-with-context),\n    or Vue's [`provide()`](https://vuejs.org/guide/components/provide-inject).\n\n    **Args:**\n\n    - `name` (str, required): Provider name. This is the name you will then use in\n        [`Component.inject()`](../api#django_components.Component.inject).\n    - `**kwargs`: Any extra kwargs will be passed as the provided data.\n\n    **Example:**\n\n    Provide the \"user_data\" in parent component:\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% provide \"user_data\" user=user %}\n              {% component \"child\" / %}\n            {% endprovide %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n\n        def get_context_data(self, user: User):\n            return {\n                \"user\": user,\n            }\n    ```\n\n    Since the \"child\" component is used within the `{% provide %} / {% endprovide %}` tags,\n    we can request the \"user_data\" using `Component.inject(\"user_data\")`:\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            User is: {{ user }}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n\n        def get_context_data(self):\n            user = self.inject(\"user_data\").user\n            return {\n                \"user\": user,\n            }\n    ```\n\n    Notice that the keys defined on the `{% provide %}` tag are then accessed as attributes\n    when accessing them with [`Component.inject()`](../api#django_components.Component.inject).\n\n    \u2705 Do this\n    ```python\n    user = self.inject(\"user_data\").user\n    ```\n\n    \u274c Don't do this\n    ```python\n    user = self.inject(\"user_data\")[\"user\"]\n    ```\n    \"\"\"\n    # e.g. {% provide &lt;name&gt; key=val key2=val2 %}\n    tag = _parse_tag(parser, token, tag_spec)\n\n    name_kwarg = tag.kwargs.kwargs.get(PROVIDE_NAME_KWARG, None)\n    trace_id = f\"provide-id-{tag.id} ({name_kwarg})\" if name_kwarg else f\"fill-id-{tag.id}\"\n\n    trace_msg(\"PARSE\", \"PROVIDE\", trace_id, tag.id)\n\n    body = tag.parse_body()\n    provide_node = ProvideNode(\n        nodelist=body,\n        node_id=tag.id,\n        kwargs=tag.kwargs,\n        trace_id=trace_id,\n    )\n\n    trace_msg(\"PARSE\", \"PROVIDE\", trace_id, tag.id, \"...Done!\")\n    return provide_node\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.slot","title":"slot","text":"<pre><code>slot(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; SlotNode\n</code></pre> <p>Slot tag marks a place inside a component where content can be inserted from outside.</p> <p>Learn more about using slots.</p> <p>This is similar to slots as seen in Web components, Vue or React's <code>children</code>.</p> <p>Args:</p> <ul> <li><code>name</code> (str, required): Registered name of the component to render</li> <li><code>default</code>: Optional flag. If there is a default slot, you can pass the component slot content     without using the <code>{% fill %}</code> tag. See     Default slot</li> <li><code>required</code>: Optional flag. Will raise an error if a slot is required but not given.</li> <li><code>**kwargs</code>: Any extra kwargs will be passed as the slot data.</li> </ul> <p>Example:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" default %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n      &lt;aside&gt;\n        {% slot \"sidebar\" required / %}\n      &lt;/aside&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% component \"child\" %}\n          {% fill \"content\" %}\n            \ud83d\uddde\ufe0f\ud83d\udcf0\n          {% endfill %}\n\n          {% fill \"sidebar\" %}\n            \ud83c\udf77\ud83e\uddc9\ud83c\udf7e\n          {% endfill %}\n        {% endcomponent %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.slot--passing-data-to-slots","title":"Passing data to slots","text":"<p>Any extra kwargs will be considered as slot data, and will be accessible in the <code>{% fill %}</code> tag via fill's <code>data</code> kwarg:</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {# Passing data to the slot #}\n        {% slot \"content\" user=user %}\n          This is shown if not overriden!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot data #}\n      {% component \"child\" %}\n        {% fill \"content\" data=\"data\" %}\n          &lt;div class=\"wrapper-class\"&gt;\n            {{ data.user }}\n          &lt;/div&gt;\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.slot--accessing-default-slot-content","title":"Accessing default slot content","text":"<p>The content between the <code>{% slot %}..{% endslot %}</code> tags is the default content that will be rendered if no fill is given for the slot.</p> <p>This default content can then be accessed from within the <code>{% fill %}</code> tag using the fill's <code>default</code> kwarg. This is useful if you need to wrap / prepend / append the original slot's content.</p> <pre><code>@register(\"child\")\nclass Child(Component):\n    template = \"\"\"\n      &lt;div&gt;\n        {% slot \"content\" %}\n          This is default content!\n        {% endslot %}\n      &lt;/div&gt;\n    \"\"\"\n</code></pre> <pre><code>@register(\"parent\")\nclass Parent(Component):\n    template = \"\"\"\n      {# Parent can access the slot's default content #}\n      {% component \"child\" %}\n        {% fill \"content\" default=\"default\" %}\n          {{ default }}\n        {% endfill %}\n      {% endcomponent %}\n    \"\"\"\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>@register.tag(\"slot\")\n@with_tag_spec(\n    TagSpec(\n        tag=\"slot\",\n        end_tag=\"endslot\",\n        positional_only_args=[],\n        pos_or_keyword_args=[SLOT_NAME_KWARG],\n        keywordonly_args=True,\n        repeatable_kwargs=False,\n        flags=[SLOT_DEFAULT_KEYWORD, SLOT_REQUIRED_KEYWORD],\n    )\n)\ndef slot(parser: Parser, token: Token, tag_spec: TagSpec) -&gt; SlotNode:\n    \"\"\"\n    Slot tag marks a place inside a component where content can be inserted\n    from outside.\n\n    [Learn more](../../concepts/fundamentals/slots) about using slots.\n\n    This is similar to slots as seen in\n    [Web components](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot),\n    [Vue](https://vuejs.org/guide/components/slots.html)\n    or [React's `children`](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children).\n\n    **Args:**\n\n    - `name` (str, required): Registered name of the component to render\n    - `default`: Optional flag. If there is a default slot, you can pass the component slot content\n        without using the [`{% fill %}`](#fill) tag. See\n        [Default slot](../../concepts/fundamentals/slots#default-slot)\n    - `required`: Optional flag. Will raise an error if a slot is required but not given.\n    - `**kwargs`: Any extra kwargs will be passed as the slot data.\n\n    **Example:**\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% slot \"content\" default %}\n              This is shown if not overriden!\n            {% endslot %}\n          &lt;/div&gt;\n          &lt;aside&gt;\n            {% slot \"sidebar\" required / %}\n          &lt;/aside&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% component \"child\" %}\n              {% fill \"content\" %}\n                \ud83d\uddde\ufe0f\ud83d\udcf0\n              {% endfill %}\n\n              {% fill \"sidebar\" %}\n                \ud83c\udf77\ud83e\uddc9\ud83c\udf7e\n              {% endfill %}\n            {% endcomponent %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ### Passing data to slots\n\n    Any extra kwargs will be considered as slot data, and will be accessible in the [`{% fill %}`](#fill)\n    tag via fill's `data` kwarg:\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {# Passing data to the slot #}\n            {% slot \"content\" user=user %}\n              This is shown if not overriden!\n            {% endslot %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          {# Parent can access the slot data #}\n          {% component \"child\" %}\n            {% fill \"content\" data=\"data\" %}\n              &lt;div class=\"wrapper-class\"&gt;\n                {{ data.user }}\n              &lt;/div&gt;\n            {% endfill %}\n          {% endcomponent %}\n        \\\"\\\"\\\"\n    ```\n\n    ### Accessing default slot content\n\n    The content between the `{% slot %}..{% endslot %}` tags is the default content that\n    will be rendered if no fill is given for the slot.\n\n    This default content can then be accessed from within the [`{% fill %}`](#fill) tag using\n    the fill's `default` kwarg.\n    This is useful if you need to wrap / prepend / append the original slot's content.\n\n    ```python\n    @register(\"child\")\n    class Child(Component):\n        template = \\\"\\\"\\\"\n          &lt;div&gt;\n            {% slot \"content\" %}\n              This is default content!\n            {% endslot %}\n          &lt;/div&gt;\n        \\\"\\\"\\\"\n    ```\n\n    ```python\n    @register(\"parent\")\n    class Parent(Component):\n        template = \\\"\\\"\\\"\n          {# Parent can access the slot's default content #}\n          {% component \"child\" %}\n            {% fill \"content\" default=\"default\" %}\n              {{ default }}\n            {% endfill %}\n          {% endcomponent %}\n        \\\"\\\"\\\"\n    ```\n    \"\"\"\n    tag = _parse_tag(parser, token, tag_spec)\n\n    slot_name_kwarg = tag.kwargs.kwargs.get(SLOT_NAME_KWARG, None)\n    trace_id = f\"slot-id-{tag.id} ({slot_name_kwarg})\" if slot_name_kwarg else f\"slot-id-{tag.id}\"\n\n    trace_msg(\"PARSE\", \"SLOT\", trace_id, tag.id)\n\n    body = tag.parse_body()\n    slot_node = SlotNode(\n        nodelist=body,\n        node_id=tag.id,\n        kwargs=tag.kwargs,\n        is_required=tag.flags[SLOT_REQUIRED_KEYWORD],\n        is_default=tag.flags[SLOT_DEFAULT_KEYWORD],\n        trace_id=trace_id,\n    )\n\n    trace_msg(\"PARSE\", \"SLOT\", trace_id, tag.id, \"...Done!\")\n    return slot_node\n</code></pre>"},{"location":"reference/django_components/templatetags/component_tags/#django_components.templatetags.component_tags.with_tag_spec","title":"with_tag_spec","text":"<pre><code>with_tag_spec(tag_spec: TagSpec) -&gt; Callable\n</code></pre> Source code in <code>src/django_components/templatetags/component_tags.py</code> <pre><code>def with_tag_spec(tag_spec: TagSpec) -&gt; Callable:\n    \"\"\"\"\"\"\n\n    def decorator(fn: Callable) -&gt; Any:\n        fn._tag_spec = tag_spec  # type: ignore[attr-defined]\n\n        @functools.wraps(fn)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            return fn(*args, **kwargs, tag_spec=tag_spec)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/types/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> types","text":""},{"location":"reference/django_components/types/#django_components.types","title":"types","text":"<p>Helper types for IDEs.</p>"},{"location":"reference/django_components/urls/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> urls","text":""},{"location":"reference/django_components/urls/#django_components.urls","title":"urls","text":""},{"location":"reference/django_components/util/","title":"Index","text":""},{"location":"reference/django_components/util/#django_components.util","title":"util","text":"<p>Modules:</p> <ul> <li> <code>cache</code>           \u2013            </li> <li> <code>html</code>           \u2013            </li> <li> <code>loader</code>           \u2013            </li> <li> <code>logger</code>           \u2013            </li> <li> <code>misc</code>           \u2013            </li> <li> <code>tag_parser</code>           \u2013            </li> <li> <code>types</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/util/#django_components.util.cache","title":"cache","text":"<p>Functions:</p> <ul> <li> <code>lazy_cache</code>             \u2013              <p>Decorator that caches the given function similarly to <code>functools.lru_cache</code>.</p> </li> </ul>"},{"location":"reference/django_components/util/#django_components.util.cache.lazy_cache","title":"lazy_cache","text":"<pre><code>lazy_cache(make_cache: Callable[[], Callable[[Callable], Callable]]) -&gt; Callable[[TFunc], TFunc]\n</code></pre> <p>Decorator that caches the given function similarly to <code>functools.lru_cache</code>. But the cache is instantiated only at first invocation.</p> <p><code>cache</code> argument is a function that generates the cache function, e.g. <code>functools.lru_cache()</code>.</p> Source code in <code>src/django_components/util/cache.py</code> <pre><code>def lazy_cache(\n    make_cache: Callable[[], Callable[[Callable], Callable]],\n) -&gt; Callable[[TFunc], TFunc]:\n    \"\"\"\n    Decorator that caches the given function similarly to `functools.lru_cache`.\n    But the cache is instantiated only at first invocation.\n\n    `cache` argument is a function that generates the cache function,\n    e.g. `functools.lru_cache()`.\n    \"\"\"\n    _cached_fn = None\n\n    def decorator(fn: TFunc) -&gt; TFunc:\n        @functools.wraps(fn)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            # Lazily initialize the cache\n            nonlocal _cached_fn\n            if not _cached_fn:\n                # E.g. `lambda: functools.lru_cache(maxsize=app_settings.TEMPLATE_CACHE_SIZE)`\n                cache = make_cache()\n                _cached_fn = cache(fn)\n\n            return _cached_fn(*args, **kwargs)\n\n        # Allow to access the LRU cache methods\n        # See https://stackoverflow.com/a/37654201/9788634\n        wrapper.cache_info = lambda: _cached_fn.cache_info()  # type: ignore\n        wrapper.cache_clear = lambda: _cached_fn.cache_clear()  # type: ignore\n\n        # And allow to remove the cache instance (mostly for tests)\n        def cache_remove() -&gt; None:\n            nonlocal _cached_fn\n            _cached_fn = None\n\n        wrapper.cache_remove = cache_remove  # type: ignore\n\n        return cast(TFunc, wrapper)\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.html","title":"html","text":"<p>Functions:</p> <ul> <li> <code>parse_document_or_nodes</code>             \u2013              <p>Use this if you do NOT know whether the given HTML is a full document</p> </li> <li> <code>parse_multiroot_html</code>             \u2013              <p>Use this when you know the given HTML is a multiple nodes like</p> </li> <li> <code>parse_node</code>             \u2013              <p>Use this when you know the given HTML is a single node like</p> </li> </ul>"},{"location":"reference/django_components/util/#django_components.util.html.parse_document_or_nodes","title":"parse_document_or_nodes","text":"<pre><code>parse_document_or_nodes(html: str) -&gt; Union[List[LexborNode], LexborHTMLParser]\n</code></pre> <p>Use this if you do NOT know whether the given HTML is a full document with <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, and <code>&lt;body&gt;</code> tags, or an HTML fragment.</p> Source code in <code>src/django_components/util/html.py</code> <pre><code>def parse_document_or_nodes(html: str) -&gt; Union[List[LexborNode], LexborHTMLParser]:\n    \"\"\"\n    Use this if you do NOT know whether the given HTML is a full document\n    with `&lt;html&gt;`, `&lt;head&gt;`, and `&lt;body&gt;` tags, or an HTML fragment.\n    \"\"\"\n    html = html.strip()\n    tree = LexborHTMLParser(html)\n    is_fragment = is_html_parser_fragment(html, tree)\n\n    if is_fragment:\n        nodes = parse_multiroot_html(html)\n        return nodes\n    else:\n        return tree\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.html.parse_multiroot_html","title":"parse_multiroot_html","text":"<pre><code>parse_multiroot_html(html: str) -&gt; List[LexborNode]\n</code></pre> <p>Use this when you know the given HTML is a multiple nodes like</p> <p><code>&lt;div&gt; Hi &lt;/div&gt; &lt;span&gt; Hello &lt;/span&gt;</code></p> Source code in <code>src/django_components/util/html.py</code> <pre><code>def parse_multiroot_html(html: str) -&gt; List[LexborNode]:\n    \"\"\"\n    Use this when you know the given HTML is a multiple nodes like\n\n    `&lt;div&gt; Hi &lt;/div&gt; &lt;span&gt; Hello &lt;/span&gt;`\n    \"\"\"\n    # NOTE: HTML / XML MUST have a single root. So, to support multiple\n    # top-level elements, we wrap them in a dummy singular root.\n    parser = LexborHTMLParser(f\"&lt;root&gt;{html}&lt;/root&gt;\")\n\n    # Get all contents of the root\n    root_elem = parser.css_first(\"root\")\n    elems = [*root_elem.iter()] if root_elem else []\n    return elems\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.html.parse_node","title":"parse_node","text":"<pre><code>parse_node(html: str) -&gt; LexborNode\n</code></pre> <p>Use this when you know the given HTML is a single node like</p> <p><code>&lt;div&gt; Hi &lt;/div&gt;</code></p> Source code in <code>src/django_components/util/html.py</code> <pre><code>def parse_node(html: str) -&gt; LexborNode:\n    \"\"\"\n    Use this when you know the given HTML is a single node like\n\n    `&lt;div&gt; Hi &lt;/div&gt;`\n    \"\"\"\n    tree = LexborHTMLParser(html)\n    # NOTE: The parser automatically places &lt;style&gt; tags inside &lt;head&gt;\n    # while &lt;script&gt; tags are inside &lt;body&gt;.\n    return tree.body.child or tree.head.child  # type: ignore[union-attr, return-value]\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.loader","title":"loader","text":"<p>Classes:</p> <ul> <li> <code>ComponentFileEntry</code>           \u2013            <p>Result returned by <code>get_component_files()</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_component_dirs</code>             \u2013              <p>Get directories that may contain component files.</p> </li> <li> <code>get_component_files</code>             \u2013              <p>Search for files within the component directories (as defined in</p> </li> </ul>"},{"location":"reference/django_components/util/#django_components.util.loader.ComponentFileEntry","title":"ComponentFileEntry","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Result returned by <code>get_component_files()</code>.</p> <p>Attributes:</p> <ul> <li> <code>dot_path</code>               (<code>str</code>)           \u2013            <p>The python import path for the module. E.g. <code>app.components.mycomp</code></p> </li> <li> <code>filepath</code>               (<code>Path</code>)           \u2013            <p>The filesystem path to the module. E.g. <code>/path/to/project/app/components/mycomp.py</code></p> </li> </ul>"},{"location":"reference/django_components/util/#django_components.util.loader.ComponentFileEntry.dot_path","title":"dot_path  <code>instance-attribute</code>","text":"<pre><code>dot_path: str\n</code></pre> <p>The python import path for the module. E.g. <code>app.components.mycomp</code></p>"},{"location":"reference/django_components/util/#django_components.util.loader.ComponentFileEntry.filepath","title":"filepath  <code>instance-attribute</code>","text":"<pre><code>filepath: Path\n</code></pre> <p>The filesystem path to the module. E.g. <code>/path/to/project/app/components/mycomp.py</code></p>"},{"location":"reference/django_components/util/#django_components.util.loader.get_component_dirs","title":"get_component_dirs","text":"<pre><code>get_component_dirs(include_apps: bool = True) -&gt; List[Path]\n</code></pre> <p>Get directories that may contain component files.</p> <p>This is the heart of all features that deal with filesystem and file lookup. Autodiscovery, Django template resolution, static file resolution - They all use this.</p> <p>Parameters:</p> <ul> <li> <code>include_apps</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Include directories from installed Django apps.            Defaults to <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Path]</code>           \u2013            <p>List[Path]: A list of directories that may contain component files.</p> </li> </ul> <p><code>get_component_dirs()</code> searches for dirs set in <code>COMPONENTS.dirs</code> settings. If none set, defaults to searching for a <code>\"components\"</code> app.</p> <p>In addition to that, also all installed Django apps are checked whether they contain directories as set in <code>COMPONENTS.app_dirs</code> (e.g. <code>[app]/components</code>).</p> <p>Notes:</p> <ul> <li> <p>Paths that do not point to directories are ignored.</p> </li> <li> <p><code>BASE_DIR</code> setting is required.</p> </li> <li> <p>The paths in <code>COMPONENTS.dirs</code>     must be absolute paths.</p> </li> </ul> Source code in <code>src/django_components/util/loader.py</code> <pre><code>def get_component_dirs(include_apps: bool = True) -&gt; List[Path]:\n    \"\"\"\n    Get directories that may contain component files.\n\n    This is the heart of all features that deal with filesystem and file lookup.\n    Autodiscovery, Django template resolution, static file resolution - They all use this.\n\n    Args:\n        include_apps (bool, optional): Include directories from installed Django apps.\\\n            Defaults to `True`.\n\n    Returns:\n        List[Path]: A list of directories that may contain component files.\n\n    `get_component_dirs()` searches for dirs set in\n    [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n    settings. If none set, defaults to searching for a `\"components\"` app.\n\n    In addition to that, also all installed Django apps are checked whether they contain\n    directories as set in\n    [`COMPONENTS.app_dirs`](../settings#django_components.app_settings.ComponentsSettings.app_dirs)\n    (e.g. `[app]/components`).\n\n    **Notes:**\n\n    - Paths that do not point to directories are ignored.\n\n    - `BASE_DIR` setting is required.\n\n    - The paths in [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n        must be absolute paths.\n    \"\"\"\n    # Allow to configure from settings which dirs should be checked for components\n    component_dirs = app_settings.DIRS\n\n    # TODO_REMOVE_IN_V1\n    raw_component_settings = getattr(settings, \"COMPONENTS\", {})\n    if isinstance(raw_component_settings, dict):\n        raw_dirs_value = raw_component_settings.get(\"dirs\", None)\n    elif isinstance(raw_component_settings, ComponentsSettings):\n        raw_dirs_value = raw_component_settings.dirs\n    else:\n        raw_dirs_value = None\n    is_component_dirs_set = raw_dirs_value is not None\n    is_legacy_paths = (\n        # Use value of `STATICFILES_DIRS` ONLY if `COMPONENT.dirs` not set\n        not is_component_dirs_set\n        and hasattr(settings, \"STATICFILES_DIRS\")\n        and settings.STATICFILES_DIRS\n    )\n    if is_legacy_paths:\n        # NOTE: For STATICFILES_DIRS, we use the defaults even for empty list.\n        # We don't do this for COMPONENTS.dirs, so user can explicitly specify \"NO dirs\".\n        component_dirs = settings.STATICFILES_DIRS or [settings.BASE_DIR / \"components\"]\n    # END TODO_REMOVE_IN_V1\n\n    source = \"STATICFILES_DIRS\" if is_legacy_paths else \"COMPONENTS.dirs\"\n\n    logger.debug(\n        \"get_component_dirs will search for valid dirs from following options:\\n\"\n        + \"\\n\".join([f\" - {str(d)}\" for d in component_dirs])\n    )\n\n    # Add `[app]/[APP_DIR]` to the directories. This is, by default `[app]/components`\n    app_paths: List[Path] = []\n    if include_apps:\n        for conf in apps.get_app_configs():\n            for app_dir in app_settings.APP_DIRS:\n                comps_path = Path(conf.path).joinpath(app_dir)\n                if comps_path.exists():\n                    app_paths.append(comps_path)\n\n    directories: Set[Path] = set(app_paths)\n\n    # Validate and add other values from the config\n    for component_dir in component_dirs:\n        # Consider tuples for STATICFILES_DIRS (See #489)\n        # See https://docs.djangoproject.com/en/5.0/ref/settings/#prefixes-optional\n        if isinstance(component_dir, (tuple, list)):\n            component_dir = component_dir[1]\n        try:\n            Path(component_dir)\n        except TypeError:\n            logger.warning(\n                f\"{source} expected str, bytes or os.PathLike object, or tuple/list of length 2. \"\n                f\"See Django documentation for STATICFILES_DIRS. Got {type(component_dir)} : {component_dir}\"\n            )\n            continue\n\n        if not Path(component_dir).is_absolute():\n            raise ValueError(f\"{source} must contain absolute paths, got '{component_dir}'\")\n        else:\n            directories.add(Path(component_dir).resolve())\n\n    logger.debug(\n        \"get_component_dirs matched following template dirs:\\n\" + \"\\n\".join([f\" - {str(d)}\" for d in directories])\n    )\n    return list(directories)\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.loader.get_component_files","title":"get_component_files","text":"<pre><code>get_component_files(suffix: Optional[str] = None) -&gt; List[ComponentFileEntry]\n</code></pre> <p>Search for files within the component directories (as defined in <code>get_component_dirs()</code>).</p> <p>Requires <code>BASE_DIR</code> setting to be set.</p> <p>Parameters:</p> <ul> <li> <code>suffix</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The suffix to search for. E.g. <code>.py</code>, <code>.js</code>, <code>.css</code>.            Defaults to <code>None</code>, which will search for all files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[ComponentFileEntry]</code>           \u2013            <p>List[ComponentFileEntry] A list of entries that contain both the filesystem path and             the python import path (dot path).</p> </li> </ul> <p>Example:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre> Source code in <code>src/django_components/util/loader.py</code> <pre><code>def get_component_files(suffix: Optional[str] = None) -&gt; List[ComponentFileEntry]:\n    \"\"\"\n    Search for files within the component directories (as defined in\n    [`get_component_dirs()`](../api#django_components.get_component_dirs)).\n\n    Requires `BASE_DIR` setting to be set.\n\n    Args:\n        suffix (Optional[str], optional): The suffix to search for. E.g. `.py`, `.js`, `.css`.\\\n            Defaults to `None`, which will search for all files.\n\n    Returns:\n        List[ComponentFileEntry] A list of entries that contain both the filesystem path and \\\n            the python import path (dot path).\n\n    **Example:**\n\n    ```python\n    from django_components import get_component_files\n\n    modules = get_component_files(\".py\")\n    ```\n    \"\"\"\n    search_glob = f\"**/*{suffix}\" if suffix else \"**/*\"\n\n    dirs = get_component_dirs(include_apps=False)\n    component_filepaths = _search_dirs(dirs, search_glob)\n\n    if hasattr(settings, \"BASE_DIR\") and settings.BASE_DIR:\n        project_root = str(settings.BASE_DIR)\n    else:\n        # Fallback for getting the root dir, see https://stackoverflow.com/a/16413955/9788634\n        project_root = os.path.abspath(os.path.dirname(__name__))\n\n    # NOTE: We handle dirs from `COMPONENTS.dirs` and from individual apps separately.\n    modules: List[ComponentFileEntry] = []\n\n    # First let's handle the dirs from `COMPONENTS.dirs`\n    #\n    # Because for dirs in `COMPONENTS.dirs`, we assume they will be nested under `BASE_DIR`,\n    # and that `BASE_DIR` is the current working dir (CWD). So the path relatively to `BASE_DIR`\n    # is ALSO the python import path.\n    for filepath in component_filepaths:\n        module_path = _filepath_to_python_module(filepath, project_root, None)\n        # Ignore files starting with dot `.` or files in dirs that start with dot.\n        #\n        # If any of the parts of the path start with a dot, e.g. the filesystem path\n        # is `./abc/.def`, then this gets converted to python module as `abc..def`\n        #\n        # NOTE: This approach also ignores files:\n        #   - with two dots in the middle (ab..cd.py)\n        #   - an extra dot at the end (abcd..py)\n        #   - files outside of the parent component (../abcd.py).\n        # But all these are NOT valid python modules so that's fine.\n        if \"..\" in module_path:\n            continue\n\n        entry = ComponentFileEntry(dot_path=module_path, filepath=filepath)\n        modules.append(entry)\n\n    # For for apps, the directories may be outside of the project, e.g. in case of third party\n    # apps. So we have to resolve the python import path relative to the package name / the root\n    # import path for the app.\n    # See https://github.com/EmilStenstrom/django-components/issues/669\n    for conf in apps.get_app_configs():\n        for app_dir in app_settings.APP_DIRS:\n            comps_path = Path(conf.path).joinpath(app_dir)\n            if not comps_path.exists():\n                continue\n            app_component_filepaths = _search_dirs([comps_path], search_glob)\n            for filepath in app_component_filepaths:\n                app_component_module = _filepath_to_python_module(filepath, conf.path, conf.name)\n                entry = ComponentFileEntry(dot_path=app_component_module, filepath=filepath)\n                modules.append(entry)\n\n    return modules\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.logger","title":"logger","text":"<p>Functions:</p> <ul> <li> <code>trace</code>             \u2013              <p>TRACE level logger.</p> </li> <li> <code>trace_msg</code>             \u2013              <p>TRACE level logger with opinionated format for tracing interaction of components,</p> </li> </ul>"},{"location":"reference/django_components/util/#django_components.util.logger.trace","title":"trace","text":"<pre><code>trace(logger: Logger, message: str, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>TRACE level logger.</p> <p>To display TRACE logs, set the logging level to 5.</p> <p>Example: <pre><code>LOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": sys.stdout,\n        },\n    },\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": 5,\n            \"handlers\": [\"console\"],\n        },\n    },\n}\n</code></pre></p> Source code in <code>src/django_components/util/logger.py</code> <pre><code>def trace(logger: logging.Logger, message: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    TRACE level logger.\n\n    To display TRACE logs, set the logging level to 5.\n\n    Example:\n    ```py\n    LOGGING = {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"handlers\": {\n            \"console\": {\n                \"class\": \"logging.StreamHandler\",\n                \"stream\": sys.stdout,\n            },\n        },\n        \"loggers\": {\n            \"django_components\": {\n                \"level\": 5,\n                \"handlers\": [\"console\"],\n            },\n        },\n    }\n    ```\n    \"\"\"\n    if actual_trace_level_num == -1:\n        setup_logging()\n    if logger.isEnabledFor(actual_trace_level_num):\n        logger.log(actual_trace_level_num, message, *args, **kwargs)\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.logger.trace_msg","title":"trace_msg","text":"<pre><code>trace_msg(\n    action: Literal[\"PARSE\", \"RENDR\", \"GET\", \"SET\"],\n    node_type: Literal[\"COMP\", \"FILL\", \"SLOT\", \"PROVIDE\", \"N/A\"],\n    node_name: str,\n    node_id: str,\n    msg: str = \"\",\n    component_id: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>TRACE level logger with opinionated format for tracing interaction of components, nodes, and slots. Formats messages like so:</p> <p><code>\"ASSOC SLOT test_slot ID 0088 TO COMP 0087\"</code></p> Source code in <code>src/django_components/util/logger.py</code> <pre><code>def trace_msg(\n    action: Literal[\"PARSE\", \"RENDR\", \"GET\", \"SET\"],\n    node_type: Literal[\"COMP\", \"FILL\", \"SLOT\", \"PROVIDE\", \"N/A\"],\n    node_name: str,\n    node_id: str,\n    msg: str = \"\",\n    component_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    TRACE level logger with opinionated format for tracing interaction of components,\n    nodes, and slots. Formats messages like so:\n\n    `\"ASSOC SLOT test_slot ID 0088 TO COMP 0087\"`\n    \"\"\"\n    msg_prefix = \"\"\n    if action == \"RENDR\" and node_type == \"FILL\":\n        if not component_id:\n            raise ValueError(\"component_id must be set for the RENDER action\")\n        msg_prefix = f\"FOR COMP {component_id}\"\n\n    msg_parts = [f\"{action} {node_type} {node_name} ID {node_id}\", *([msg_prefix] if msg_prefix else []), msg]\n    full_msg = \" \".join(msg_parts)\n\n    # NOTE: When debugging tests during development, it may be easier to change\n    # this to `print()`\n    trace(logger, full_msg)\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.misc","title":"misc","text":"<p>Functions:</p> <ul> <li> <code>gen_id</code>             \u2013              <p>Generate a unique ID that can be associated with a Node</p> </li> <li> <code>get_import_path</code>             \u2013              <p>Get the full import path for a class or a function, e.g. <code>\"path.to.MyClass\"</code></p> </li> </ul>"},{"location":"reference/django_components/util/#django_components.util.misc.gen_id","title":"gen_id","text":"<pre><code>gen_id() -&gt; str\n</code></pre> <p>Generate a unique ID that can be associated with a Node</p> Source code in <code>src/django_components/util/misc.py</code> <pre><code>def gen_id() -&gt; str:\n    \"\"\"Generate a unique ID that can be associated with a Node\"\"\"\n    # Alphabet is only alphanumeric. Compared to the default alphabet used by nanoid,\n    # we've omitted `-` and `_`.\n    # With this alphabet, at 6 chars, the chance of collision is 1 in 3.3M.\n    # See https://zelark.github.io/nano-id-cc/\n    return generate(\n        \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n        size=6,\n    )\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.misc.get_import_path","title":"get_import_path","text":"<pre><code>get_import_path(cls_or_fn: Type[Any]) -&gt; str\n</code></pre> <p>Get the full import path for a class or a function, e.g. <code>\"path.to.MyClass\"</code></p> Source code in <code>src/django_components/util/misc.py</code> <pre><code>def get_import_path(cls_or_fn: Type[Any]) -&gt; str:\n    \"\"\"\n    Get the full import path for a class or a function, e.g. `\"path.to.MyClass\"`\n    \"\"\"\n    module = cls_or_fn.__module__\n    if module == \"builtins\":\n        return cls_or_fn.__qualname__  # avoid outputs like 'builtins.str'\n    return module + \".\" + cls_or_fn.__qualname__\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.tag_parser","title":"tag_parser","text":"<p>Classes:</p> <ul> <li> <code>TagAttr</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/util/#django_components.util.tag_parser.TagAttr","title":"TagAttr  <code>dataclass</code>","text":"<pre><code>TagAttr(key: Optional[str], value: str, start_index: int, quoted: bool)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>quoted</code>               (<code>bool</code>)           \u2013            <p>Whether the value is quoted (either with single or double quotes)</p> </li> <li> <code>start_index</code>               (<code>int</code>)           \u2013            <p>Start index of the attribute (include both key and value),</p> </li> </ul>"},{"location":"reference/django_components/util/#django_components.util.tag_parser.TagAttr.quoted","title":"quoted  <code>instance-attribute</code>","text":"<pre><code>quoted: bool\n</code></pre> <p>Whether the value is quoted (either with single or double quotes)</p>"},{"location":"reference/django_components/util/#django_components.util.tag_parser.TagAttr.start_index","title":"start_index  <code>instance-attribute</code>","text":"<pre><code>start_index: int\n</code></pre> <p>Start index of the attribute (include both key and value), relative to the start of the owner Tag.</p>"},{"location":"reference/django_components/util/#django_components.util.types","title":"types","text":"<p>Classes:</p> <ul> <li> <code>EmptyDict</code>           \u2013            <p>TypedDict with no members.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>EmptyTuple</code>           \u2013            <p>Tuple with no members.</p> </li> </ul>"},{"location":"reference/django_components/util/#django_components.util.types.EmptyTuple","title":"EmptyTuple  <code>module-attribute</code>","text":"<pre><code>EmptyTuple = Tuple[]\n</code></pre> <p>Tuple with no members.</p> <p>You can use this to define a Component that accepts NO positional arguments:</p> <pre><code>from django_components import Component, EmptyTuple\n\nclass Table(Component(EmptyTuple, Any, Any, Any, Any, Any))\n    ...\n</code></pre> <p>After that, when you call <code>Component.render()</code> or <code>Component.render_to_response()</code>, the <code>args</code> parameter will raise type error if <code>args</code> is anything else than an empty tuple.</p> <pre><code>Table.render(\n    args: (),\n)\n</code></pre> <p>Omitting <code>args</code> is also fine:</p> <pre><code>Table.render()\n</code></pre> <p>Other values are not allowed. This will raise an error with MyPy:</p> <pre><code>Table.render(\n    args: (\"one\", 2, \"three\"),\n)\n</code></pre>"},{"location":"reference/django_components/util/#django_components.util.types.EmptyDict","title":"EmptyDict","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict with no members.</p> <p>You can use this to define a Component that accepts NO kwargs, or NO slots, or returns NO data from <code>Component.get_context_data()</code> / <code>Component.get_js_data()</code> / <code>Component.get_css_data()</code>:</p> <p>Accepts NO kwargs:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, EmptyDict, Any, Any, Any, Any))\n    ...\n</code></pre> <p>Accepts NO slots:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, Any, EmptyDict, Any, Any, Any))\n    ...\n</code></pre> <p>Returns NO data from <code>get_context_data()</code>:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, Any, Any, EmptyDict, Any, Any))\n    ...\n</code></pre> <p>Going back to the example with NO kwargs, when you then call <code>Component.render()</code> or <code>Component.render_to_response()</code>, the <code>kwargs</code> parameter will raise type error if <code>kwargs</code> is anything else than an empty dict.</p> <pre><code>Table.render(\n    kwargs: {},\n)\n</code></pre> <p>Omitting <code>kwargs</code> is also fine:</p> <pre><code>Table.render()\n</code></pre> <p>Other values are not allowed. This will raise an error with MyPy:</p> <pre><code>Table.render(\n    kwargs: {\n        \"one\": 2,\n        \"three\": 4,\n    },\n)\n</code></pre>"},{"location":"reference/django_components/util/cache/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> cache","text":""},{"location":"reference/django_components/util/cache/#django_components.util.cache","title":"cache","text":"<p>Functions:</p> <ul> <li> <code>lazy_cache</code>             \u2013              <p>Decorator that caches the given function similarly to <code>functools.lru_cache</code>.</p> </li> </ul>"},{"location":"reference/django_components/util/cache/#django_components.util.cache.lazy_cache","title":"lazy_cache","text":"<pre><code>lazy_cache(make_cache: Callable[[], Callable[[Callable], Callable]]) -&gt; Callable[[TFunc], TFunc]\n</code></pre> <p>Decorator that caches the given function similarly to <code>functools.lru_cache</code>. But the cache is instantiated only at first invocation.</p> <p><code>cache</code> argument is a function that generates the cache function, e.g. <code>functools.lru_cache()</code>.</p> Source code in <code>src/django_components/util/cache.py</code> <pre><code>def lazy_cache(\n    make_cache: Callable[[], Callable[[Callable], Callable]],\n) -&gt; Callable[[TFunc], TFunc]:\n    \"\"\"\n    Decorator that caches the given function similarly to `functools.lru_cache`.\n    But the cache is instantiated only at first invocation.\n\n    `cache` argument is a function that generates the cache function,\n    e.g. `functools.lru_cache()`.\n    \"\"\"\n    _cached_fn = None\n\n    def decorator(fn: TFunc) -&gt; TFunc:\n        @functools.wraps(fn)\n        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n            # Lazily initialize the cache\n            nonlocal _cached_fn\n            if not _cached_fn:\n                # E.g. `lambda: functools.lru_cache(maxsize=app_settings.TEMPLATE_CACHE_SIZE)`\n                cache = make_cache()\n                _cached_fn = cache(fn)\n\n            return _cached_fn(*args, **kwargs)\n\n        # Allow to access the LRU cache methods\n        # See https://stackoverflow.com/a/37654201/9788634\n        wrapper.cache_info = lambda: _cached_fn.cache_info()  # type: ignore\n        wrapper.cache_clear = lambda: _cached_fn.cache_clear()  # type: ignore\n\n        # And allow to remove the cache instance (mostly for tests)\n        def cache_remove() -&gt; None:\n            nonlocal _cached_fn\n            _cached_fn = None\n\n        wrapper.cache_remove = cache_remove  # type: ignore\n\n        return cast(TFunc, wrapper)\n\n    return decorator\n</code></pre>"},{"location":"reference/django_components/util/html/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> html","text":""},{"location":"reference/django_components/util/html/#django_components.util.html","title":"html","text":"<p>Functions:</p> <ul> <li> <code>parse_document_or_nodes</code>             \u2013              <p>Use this if you do NOT know whether the given HTML is a full document</p> </li> <li> <code>parse_multiroot_html</code>             \u2013              <p>Use this when you know the given HTML is a multiple nodes like</p> </li> <li> <code>parse_node</code>             \u2013              <p>Use this when you know the given HTML is a single node like</p> </li> </ul>"},{"location":"reference/django_components/util/html/#django_components.util.html.parse_document_or_nodes","title":"parse_document_or_nodes","text":"<pre><code>parse_document_or_nodes(html: str) -&gt; Union[List[LexborNode], LexborHTMLParser]\n</code></pre> <p>Use this if you do NOT know whether the given HTML is a full document with <code>&lt;html&gt;</code>, <code>&lt;head&gt;</code>, and <code>&lt;body&gt;</code> tags, or an HTML fragment.</p> Source code in <code>src/django_components/util/html.py</code> <pre><code>def parse_document_or_nodes(html: str) -&gt; Union[List[LexborNode], LexborHTMLParser]:\n    \"\"\"\n    Use this if you do NOT know whether the given HTML is a full document\n    with `&lt;html&gt;`, `&lt;head&gt;`, and `&lt;body&gt;` tags, or an HTML fragment.\n    \"\"\"\n    html = html.strip()\n    tree = LexborHTMLParser(html)\n    is_fragment = is_html_parser_fragment(html, tree)\n\n    if is_fragment:\n        nodes = parse_multiroot_html(html)\n        return nodes\n    else:\n        return tree\n</code></pre>"},{"location":"reference/django_components/util/html/#django_components.util.html.parse_multiroot_html","title":"parse_multiroot_html","text":"<pre><code>parse_multiroot_html(html: str) -&gt; List[LexborNode]\n</code></pre> <p>Use this when you know the given HTML is a multiple nodes like</p> <p><code>&lt;div&gt; Hi &lt;/div&gt; &lt;span&gt; Hello &lt;/span&gt;</code></p> Source code in <code>src/django_components/util/html.py</code> <pre><code>def parse_multiroot_html(html: str) -&gt; List[LexborNode]:\n    \"\"\"\n    Use this when you know the given HTML is a multiple nodes like\n\n    `&lt;div&gt; Hi &lt;/div&gt; &lt;span&gt; Hello &lt;/span&gt;`\n    \"\"\"\n    # NOTE: HTML / XML MUST have a single root. So, to support multiple\n    # top-level elements, we wrap them in a dummy singular root.\n    parser = LexborHTMLParser(f\"&lt;root&gt;{html}&lt;/root&gt;\")\n\n    # Get all contents of the root\n    root_elem = parser.css_first(\"root\")\n    elems = [*root_elem.iter()] if root_elem else []\n    return elems\n</code></pre>"},{"location":"reference/django_components/util/html/#django_components.util.html.parse_node","title":"parse_node","text":"<pre><code>parse_node(html: str) -&gt; LexborNode\n</code></pre> <p>Use this when you know the given HTML is a single node like</p> <p><code>&lt;div&gt; Hi &lt;/div&gt;</code></p> Source code in <code>src/django_components/util/html.py</code> <pre><code>def parse_node(html: str) -&gt; LexborNode:\n    \"\"\"\n    Use this when you know the given HTML is a single node like\n\n    `&lt;div&gt; Hi &lt;/div&gt;`\n    \"\"\"\n    tree = LexborHTMLParser(html)\n    # NOTE: The parser automatically places &lt;style&gt; tags inside &lt;head&gt;\n    # while &lt;script&gt; tags are inside &lt;body&gt;.\n    return tree.body.child or tree.head.child  # type: ignore[union-attr, return-value]\n</code></pre>"},{"location":"reference/django_components/util/loader/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> loader","text":""},{"location":"reference/django_components/util/loader/#django_components.util.loader","title":"loader","text":"<p>Classes:</p> <ul> <li> <code>ComponentFileEntry</code>           \u2013            <p>Result returned by <code>get_component_files()</code>.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_component_dirs</code>             \u2013              <p>Get directories that may contain component files.</p> </li> <li> <code>get_component_files</code>             \u2013              <p>Search for files within the component directories (as defined in</p> </li> </ul>"},{"location":"reference/django_components/util/loader/#django_components.util.loader.ComponentFileEntry","title":"ComponentFileEntry","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Result returned by <code>get_component_files()</code>.</p> <p>Attributes:</p> <ul> <li> <code>dot_path</code>               (<code>str</code>)           \u2013            <p>The python import path for the module. E.g. <code>app.components.mycomp</code></p> </li> <li> <code>filepath</code>               (<code>Path</code>)           \u2013            <p>The filesystem path to the module. E.g. <code>/path/to/project/app/components/mycomp.py</code></p> </li> </ul>"},{"location":"reference/django_components/util/loader/#django_components.util.loader.ComponentFileEntry.dot_path","title":"dot_path  <code>instance-attribute</code>","text":"<pre><code>dot_path: str\n</code></pre> <p>The python import path for the module. E.g. <code>app.components.mycomp</code></p>"},{"location":"reference/django_components/util/loader/#django_components.util.loader.ComponentFileEntry.filepath","title":"filepath  <code>instance-attribute</code>","text":"<pre><code>filepath: Path\n</code></pre> <p>The filesystem path to the module. E.g. <code>/path/to/project/app/components/mycomp.py</code></p>"},{"location":"reference/django_components/util/loader/#django_components.util.loader.get_component_dirs","title":"get_component_dirs","text":"<pre><code>get_component_dirs(include_apps: bool = True) -&gt; List[Path]\n</code></pre> <p>Get directories that may contain component files.</p> <p>This is the heart of all features that deal with filesystem and file lookup. Autodiscovery, Django template resolution, static file resolution - They all use this.</p> <p>Parameters:</p> <ul> <li> <code>include_apps</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Include directories from installed Django apps.            Defaults to <code>True</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[Path]</code>           \u2013            <p>List[Path]: A list of directories that may contain component files.</p> </li> </ul> <p><code>get_component_dirs()</code> searches for dirs set in <code>COMPONENTS.dirs</code> settings. If none set, defaults to searching for a <code>\"components\"</code> app.</p> <p>In addition to that, also all installed Django apps are checked whether they contain directories as set in <code>COMPONENTS.app_dirs</code> (e.g. <code>[app]/components</code>).</p> <p>Notes:</p> <ul> <li> <p>Paths that do not point to directories are ignored.</p> </li> <li> <p><code>BASE_DIR</code> setting is required.</p> </li> <li> <p>The paths in <code>COMPONENTS.dirs</code>     must be absolute paths.</p> </li> </ul> Source code in <code>src/django_components/util/loader.py</code> <pre><code>def get_component_dirs(include_apps: bool = True) -&gt; List[Path]:\n    \"\"\"\n    Get directories that may contain component files.\n\n    This is the heart of all features that deal with filesystem and file lookup.\n    Autodiscovery, Django template resolution, static file resolution - They all use this.\n\n    Args:\n        include_apps (bool, optional): Include directories from installed Django apps.\\\n            Defaults to `True`.\n\n    Returns:\n        List[Path]: A list of directories that may contain component files.\n\n    `get_component_dirs()` searches for dirs set in\n    [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n    settings. If none set, defaults to searching for a `\"components\"` app.\n\n    In addition to that, also all installed Django apps are checked whether they contain\n    directories as set in\n    [`COMPONENTS.app_dirs`](../settings#django_components.app_settings.ComponentsSettings.app_dirs)\n    (e.g. `[app]/components`).\n\n    **Notes:**\n\n    - Paths that do not point to directories are ignored.\n\n    - `BASE_DIR` setting is required.\n\n    - The paths in [`COMPONENTS.dirs`](../settings#django_components.app_settings.ComponentsSettings.dirs)\n        must be absolute paths.\n    \"\"\"\n    # Allow to configure from settings which dirs should be checked for components\n    component_dirs = app_settings.DIRS\n\n    # TODO_REMOVE_IN_V1\n    raw_component_settings = getattr(settings, \"COMPONENTS\", {})\n    if isinstance(raw_component_settings, dict):\n        raw_dirs_value = raw_component_settings.get(\"dirs\", None)\n    elif isinstance(raw_component_settings, ComponentsSettings):\n        raw_dirs_value = raw_component_settings.dirs\n    else:\n        raw_dirs_value = None\n    is_component_dirs_set = raw_dirs_value is not None\n    is_legacy_paths = (\n        # Use value of `STATICFILES_DIRS` ONLY if `COMPONENT.dirs` not set\n        not is_component_dirs_set\n        and hasattr(settings, \"STATICFILES_DIRS\")\n        and settings.STATICFILES_DIRS\n    )\n    if is_legacy_paths:\n        # NOTE: For STATICFILES_DIRS, we use the defaults even for empty list.\n        # We don't do this for COMPONENTS.dirs, so user can explicitly specify \"NO dirs\".\n        component_dirs = settings.STATICFILES_DIRS or [settings.BASE_DIR / \"components\"]\n    # END TODO_REMOVE_IN_V1\n\n    source = \"STATICFILES_DIRS\" if is_legacy_paths else \"COMPONENTS.dirs\"\n\n    logger.debug(\n        \"get_component_dirs will search for valid dirs from following options:\\n\"\n        + \"\\n\".join([f\" - {str(d)}\" for d in component_dirs])\n    )\n\n    # Add `[app]/[APP_DIR]` to the directories. This is, by default `[app]/components`\n    app_paths: List[Path] = []\n    if include_apps:\n        for conf in apps.get_app_configs():\n            for app_dir in app_settings.APP_DIRS:\n                comps_path = Path(conf.path).joinpath(app_dir)\n                if comps_path.exists():\n                    app_paths.append(comps_path)\n\n    directories: Set[Path] = set(app_paths)\n\n    # Validate and add other values from the config\n    for component_dir in component_dirs:\n        # Consider tuples for STATICFILES_DIRS (See #489)\n        # See https://docs.djangoproject.com/en/5.0/ref/settings/#prefixes-optional\n        if isinstance(component_dir, (tuple, list)):\n            component_dir = component_dir[1]\n        try:\n            Path(component_dir)\n        except TypeError:\n            logger.warning(\n                f\"{source} expected str, bytes or os.PathLike object, or tuple/list of length 2. \"\n                f\"See Django documentation for STATICFILES_DIRS. Got {type(component_dir)} : {component_dir}\"\n            )\n            continue\n\n        if not Path(component_dir).is_absolute():\n            raise ValueError(f\"{source} must contain absolute paths, got '{component_dir}'\")\n        else:\n            directories.add(Path(component_dir).resolve())\n\n    logger.debug(\n        \"get_component_dirs matched following template dirs:\\n\" + \"\\n\".join([f\" - {str(d)}\" for d in directories])\n    )\n    return list(directories)\n</code></pre>"},{"location":"reference/django_components/util/loader/#django_components.util.loader.get_component_files","title":"get_component_files","text":"<pre><code>get_component_files(suffix: Optional[str] = None) -&gt; List[ComponentFileEntry]\n</code></pre> <p>Search for files within the component directories (as defined in <code>get_component_dirs()</code>).</p> <p>Requires <code>BASE_DIR</code> setting to be set.</p> <p>Parameters:</p> <ul> <li> <code>suffix</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>The suffix to search for. E.g. <code>.py</code>, <code>.js</code>, <code>.css</code>.            Defaults to <code>None</code>, which will search for all files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[ComponentFileEntry]</code>           \u2013            <p>List[ComponentFileEntry] A list of entries that contain both the filesystem path and             the python import path (dot path).</p> </li> </ul> <p>Example:</p> <pre><code>from django_components import get_component_files\n\nmodules = get_component_files(\".py\")\n</code></pre> Source code in <code>src/django_components/util/loader.py</code> <pre><code>def get_component_files(suffix: Optional[str] = None) -&gt; List[ComponentFileEntry]:\n    \"\"\"\n    Search for files within the component directories (as defined in\n    [`get_component_dirs()`](../api#django_components.get_component_dirs)).\n\n    Requires `BASE_DIR` setting to be set.\n\n    Args:\n        suffix (Optional[str], optional): The suffix to search for. E.g. `.py`, `.js`, `.css`.\\\n            Defaults to `None`, which will search for all files.\n\n    Returns:\n        List[ComponentFileEntry] A list of entries that contain both the filesystem path and \\\n            the python import path (dot path).\n\n    **Example:**\n\n    ```python\n    from django_components import get_component_files\n\n    modules = get_component_files(\".py\")\n    ```\n    \"\"\"\n    search_glob = f\"**/*{suffix}\" if suffix else \"**/*\"\n\n    dirs = get_component_dirs(include_apps=False)\n    component_filepaths = _search_dirs(dirs, search_glob)\n\n    if hasattr(settings, \"BASE_DIR\") and settings.BASE_DIR:\n        project_root = str(settings.BASE_DIR)\n    else:\n        # Fallback for getting the root dir, see https://stackoverflow.com/a/16413955/9788634\n        project_root = os.path.abspath(os.path.dirname(__name__))\n\n    # NOTE: We handle dirs from `COMPONENTS.dirs` and from individual apps separately.\n    modules: List[ComponentFileEntry] = []\n\n    # First let's handle the dirs from `COMPONENTS.dirs`\n    #\n    # Because for dirs in `COMPONENTS.dirs`, we assume they will be nested under `BASE_DIR`,\n    # and that `BASE_DIR` is the current working dir (CWD). So the path relatively to `BASE_DIR`\n    # is ALSO the python import path.\n    for filepath in component_filepaths:\n        module_path = _filepath_to_python_module(filepath, project_root, None)\n        # Ignore files starting with dot `.` or files in dirs that start with dot.\n        #\n        # If any of the parts of the path start with a dot, e.g. the filesystem path\n        # is `./abc/.def`, then this gets converted to python module as `abc..def`\n        #\n        # NOTE: This approach also ignores files:\n        #   - with two dots in the middle (ab..cd.py)\n        #   - an extra dot at the end (abcd..py)\n        #   - files outside of the parent component (../abcd.py).\n        # But all these are NOT valid python modules so that's fine.\n        if \"..\" in module_path:\n            continue\n\n        entry = ComponentFileEntry(dot_path=module_path, filepath=filepath)\n        modules.append(entry)\n\n    # For for apps, the directories may be outside of the project, e.g. in case of third party\n    # apps. So we have to resolve the python import path relative to the package name / the root\n    # import path for the app.\n    # See https://github.com/EmilStenstrom/django-components/issues/669\n    for conf in apps.get_app_configs():\n        for app_dir in app_settings.APP_DIRS:\n            comps_path = Path(conf.path).joinpath(app_dir)\n            if not comps_path.exists():\n                continue\n            app_component_filepaths = _search_dirs([comps_path], search_glob)\n            for filepath in app_component_filepaths:\n                app_component_module = _filepath_to_python_module(filepath, conf.path, conf.name)\n                entry = ComponentFileEntry(dot_path=app_component_module, filepath=filepath)\n                modules.append(entry)\n\n    return modules\n</code></pre>"},{"location":"reference/django_components/util/logger/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> logger","text":""},{"location":"reference/django_components/util/logger/#django_components.util.logger","title":"logger","text":"<p>Functions:</p> <ul> <li> <code>trace</code>             \u2013              <p>TRACE level logger.</p> </li> <li> <code>trace_msg</code>             \u2013              <p>TRACE level logger with opinionated format for tracing interaction of components,</p> </li> </ul>"},{"location":"reference/django_components/util/logger/#django_components.util.logger.trace","title":"trace","text":"<pre><code>trace(logger: Logger, message: str, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>TRACE level logger.</p> <p>To display TRACE logs, set the logging level to 5.</p> <p>Example: <pre><code>LOGGING = {\n    \"version\": 1,\n    \"disable_existing_loggers\": False,\n    \"handlers\": {\n        \"console\": {\n            \"class\": \"logging.StreamHandler\",\n            \"stream\": sys.stdout,\n        },\n    },\n    \"loggers\": {\n        \"django_components\": {\n            \"level\": 5,\n            \"handlers\": [\"console\"],\n        },\n    },\n}\n</code></pre></p> Source code in <code>src/django_components/util/logger.py</code> <pre><code>def trace(logger: logging.Logger, message: str, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    TRACE level logger.\n\n    To display TRACE logs, set the logging level to 5.\n\n    Example:\n    ```py\n    LOGGING = {\n        \"version\": 1,\n        \"disable_existing_loggers\": False,\n        \"handlers\": {\n            \"console\": {\n                \"class\": \"logging.StreamHandler\",\n                \"stream\": sys.stdout,\n            },\n        },\n        \"loggers\": {\n            \"django_components\": {\n                \"level\": 5,\n                \"handlers\": [\"console\"],\n            },\n        },\n    }\n    ```\n    \"\"\"\n    if actual_trace_level_num == -1:\n        setup_logging()\n    if logger.isEnabledFor(actual_trace_level_num):\n        logger.log(actual_trace_level_num, message, *args, **kwargs)\n</code></pre>"},{"location":"reference/django_components/util/logger/#django_components.util.logger.trace_msg","title":"trace_msg","text":"<pre><code>trace_msg(\n    action: Literal[\"PARSE\", \"RENDR\", \"GET\", \"SET\"],\n    node_type: Literal[\"COMP\", \"FILL\", \"SLOT\", \"PROVIDE\", \"N/A\"],\n    node_name: str,\n    node_id: str,\n    msg: str = \"\",\n    component_id: Optional[str] = None,\n) -&gt; None\n</code></pre> <p>TRACE level logger with opinionated format for tracing interaction of components, nodes, and slots. Formats messages like so:</p> <p><code>\"ASSOC SLOT test_slot ID 0088 TO COMP 0087\"</code></p> Source code in <code>src/django_components/util/logger.py</code> <pre><code>def trace_msg(\n    action: Literal[\"PARSE\", \"RENDR\", \"GET\", \"SET\"],\n    node_type: Literal[\"COMP\", \"FILL\", \"SLOT\", \"PROVIDE\", \"N/A\"],\n    node_name: str,\n    node_id: str,\n    msg: str = \"\",\n    component_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    TRACE level logger with opinionated format for tracing interaction of components,\n    nodes, and slots. Formats messages like so:\n\n    `\"ASSOC SLOT test_slot ID 0088 TO COMP 0087\"`\n    \"\"\"\n    msg_prefix = \"\"\n    if action == \"RENDR\" and node_type == \"FILL\":\n        if not component_id:\n            raise ValueError(\"component_id must be set for the RENDER action\")\n        msg_prefix = f\"FOR COMP {component_id}\"\n\n    msg_parts = [f\"{action} {node_type} {node_name} ID {node_id}\", *([msg_prefix] if msg_prefix else []), msg]\n    full_msg = \" \".join(msg_parts)\n\n    # NOTE: When debugging tests during development, it may be easier to change\n    # this to `print()`\n    trace(logger, full_msg)\n</code></pre>"},{"location":"reference/django_components/util/misc/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> misc","text":""},{"location":"reference/django_components/util/misc/#django_components.util.misc","title":"misc","text":"<p>Functions:</p> <ul> <li> <code>gen_id</code>             \u2013              <p>Generate a unique ID that can be associated with a Node</p> </li> <li> <code>get_import_path</code>             \u2013              <p>Get the full import path for a class or a function, e.g. <code>\"path.to.MyClass\"</code></p> </li> </ul>"},{"location":"reference/django_components/util/misc/#django_components.util.misc.gen_id","title":"gen_id","text":"<pre><code>gen_id() -&gt; str\n</code></pre> <p>Generate a unique ID that can be associated with a Node</p> Source code in <code>src/django_components/util/misc.py</code> <pre><code>def gen_id() -&gt; str:\n    \"\"\"Generate a unique ID that can be associated with a Node\"\"\"\n    # Alphabet is only alphanumeric. Compared to the default alphabet used by nanoid,\n    # we've omitted `-` and `_`.\n    # With this alphabet, at 6 chars, the chance of collision is 1 in 3.3M.\n    # See https://zelark.github.io/nano-id-cc/\n    return generate(\n        \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n        size=6,\n    )\n</code></pre>"},{"location":"reference/django_components/util/misc/#django_components.util.misc.get_import_path","title":"get_import_path","text":"<pre><code>get_import_path(cls_or_fn: Type[Any]) -&gt; str\n</code></pre> <p>Get the full import path for a class or a function, e.g. <code>\"path.to.MyClass\"</code></p> Source code in <code>src/django_components/util/misc.py</code> <pre><code>def get_import_path(cls_or_fn: Type[Any]) -&gt; str:\n    \"\"\"\n    Get the full import path for a class or a function, e.g. `\"path.to.MyClass\"`\n    \"\"\"\n    module = cls_or_fn.__module__\n    if module == \"builtins\":\n        return cls_or_fn.__qualname__  # avoid outputs like 'builtins.str'\n    return module + \".\" + cls_or_fn.__qualname__\n</code></pre>"},{"location":"reference/django_components/util/nanoid/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> nanoid","text":""},{"location":"reference/django_components/util/nanoid/#django_components.util.nanoid","title":"nanoid","text":""},{"location":"reference/django_components/util/tag_parser/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> tag_parser","text":""},{"location":"reference/django_components/util/tag_parser/#django_components.util.tag_parser","title":"tag_parser","text":"<p>Classes:</p> <ul> <li> <code>TagAttr</code>           \u2013            </li> </ul>"},{"location":"reference/django_components/util/tag_parser/#django_components.util.tag_parser.TagAttr","title":"TagAttr  <code>dataclass</code>","text":"<pre><code>TagAttr(key: Optional[str], value: str, start_index: int, quoted: bool)\n</code></pre> <p>Attributes:</p> <ul> <li> <code>quoted</code>               (<code>bool</code>)           \u2013            <p>Whether the value is quoted (either with single or double quotes)</p> </li> <li> <code>start_index</code>               (<code>int</code>)           \u2013            <p>Start index of the attribute (include both key and value),</p> </li> </ul>"},{"location":"reference/django_components/util/tag_parser/#django_components.util.tag_parser.TagAttr.quoted","title":"quoted  <code>instance-attribute</code>","text":"<pre><code>quoted: bool\n</code></pre> <p>Whether the value is quoted (either with single or double quotes)</p>"},{"location":"reference/django_components/util/tag_parser/#django_components.util.tag_parser.TagAttr.start_index","title":"start_index  <code>instance-attribute</code>","text":"<pre><code>start_index: int\n</code></pre> <p>Start index of the attribute (include both key and value), relative to the start of the owner Tag.</p>"},{"location":"reference/django_components/util/types/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> types","text":""},{"location":"reference/django_components/util/types/#django_components.util.types","title":"types","text":"<p>Classes:</p> <ul> <li> <code>EmptyDict</code>           \u2013            <p>TypedDict with no members.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>EmptyTuple</code>           \u2013            <p>Tuple with no members.</p> </li> </ul>"},{"location":"reference/django_components/util/types/#django_components.util.types.EmptyTuple","title":"EmptyTuple  <code>module-attribute</code>","text":"<pre><code>EmptyTuple = Tuple[]\n</code></pre> <p>Tuple with no members.</p> <p>You can use this to define a Component that accepts NO positional arguments:</p> <pre><code>from django_components import Component, EmptyTuple\n\nclass Table(Component(EmptyTuple, Any, Any, Any, Any, Any))\n    ...\n</code></pre> <p>After that, when you call <code>Component.render()</code> or <code>Component.render_to_response()</code>, the <code>args</code> parameter will raise type error if <code>args</code> is anything else than an empty tuple.</p> <pre><code>Table.render(\n    args: (),\n)\n</code></pre> <p>Omitting <code>args</code> is also fine:</p> <pre><code>Table.render()\n</code></pre> <p>Other values are not allowed. This will raise an error with MyPy:</p> <pre><code>Table.render(\n    args: (\"one\", 2, \"three\"),\n)\n</code></pre>"},{"location":"reference/django_components/util/types/#django_components.util.types.EmptyDict","title":"EmptyDict","text":"<p>               Bases: <code>TypedDict</code></p> <p>TypedDict with no members.</p> <p>You can use this to define a Component that accepts NO kwargs, or NO slots, or returns NO data from <code>Component.get_context_data()</code> / <code>Component.get_js_data()</code> / <code>Component.get_css_data()</code>:</p> <p>Accepts NO kwargs:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, EmptyDict, Any, Any, Any, Any))\n    ...\n</code></pre> <p>Accepts NO slots:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, Any, EmptyDict, Any, Any, Any))\n    ...\n</code></pre> <p>Returns NO data from <code>get_context_data()</code>:</p> <pre><code>from django_components import Component, EmptyDict\n\nclass Table(Component(Any, Any, Any, EmptyDict, Any, Any))\n    ...\n</code></pre> <p>Going back to the example with NO kwargs, when you then call <code>Component.render()</code> or <code>Component.render_to_response()</code>, the <code>kwargs</code> parameter will raise type error if <code>kwargs</code> is anything else than an empty dict.</p> <pre><code>Table.render(\n    kwargs: {},\n)\n</code></pre> <p>Omitting <code>kwargs</code> is also fine:</p> <pre><code>Table.render()\n</code></pre> <p>Other values are not allowed. This will raise an error with MyPy:</p> <pre><code>Table.render(\n    kwargs: {\n        \"one\": 2,\n        \"three\": 4,\n    },\n)\n</code></pre>"},{"location":"reference/django_components/util/validation/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> validation","text":""},{"location":"reference/django_components/util/validation/#django_components.util.validation","title":"validation","text":""},{"location":"reference/django_components_js/build/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> build","text":""},{"location":"reference/django_components_js/build/#django_components_js.build","title":"build","text":""},{"location":"reference/docs/","title":"Index","text":""},{"location":"reference/docs/#docs","title":"docs","text":"<p>Modules:</p> <ul> <li> <code>scripts</code>           \u2013            </li> </ul>"},{"location":"reference/docs/#docs.scripts","title":"scripts","text":"<p>Modules:</p> <ul> <li> <code>reference</code>           \u2013            <p>Generate the code reference pages and navigation.</p> </li> </ul>"},{"location":"reference/docs/#docs.scripts.reference","title":"reference","text":"<p>Generate the code reference pages and navigation.</p> <p>No need to run this script manually, it is called by mkdocs-material during the build process.</p> <p>You can run it manually to test the output.</p>"},{"location":"reference/docs/scripts/","title":"Index","text":""},{"location":"reference/docs/scripts/#docs.scripts","title":"scripts","text":"<p>Modules:</p> <ul> <li> <code>reference</code>           \u2013            <p>Generate the code reference pages and navigation.</p> </li> </ul>"},{"location":"reference/docs/scripts/#docs.scripts.reference","title":"reference","text":"<p>Generate the code reference pages and navigation.</p> <p>No need to run this script manually, it is called by mkdocs-material during the build process.</p> <p>You can run it manually to test the output.</p>"},{"location":"reference/docs/scripts/reference/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> reference","text":""},{"location":"reference/docs/scripts/reference/#docs.scripts.reference","title":"reference","text":"<p>Generate the code reference pages and navigation.</p> <p>No need to run this script manually, it is called by mkdocs-material during the build process.</p> <p>You can run it manually to test the output.</p>"}]}