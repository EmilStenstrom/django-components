import glob
from pathlib import Path
from typing import Any, Callable, Dict, List, NamedTuple, Optional, no_type_check
from collections import UserDict

from django.template.engine import Engine

from django_components.template_loader import Loader


class SearchResult(NamedTuple):
    searched_dirs: List[Path]
    matched_files: List[Path]


def search(search_glob: Optional[str] = None, engine: Optional[Engine] = None) -> SearchResult:
    """
    Search for directories that may contain components.

    If `search_glob` is given, the directories are searched for said glob pattern,
    and glob search results are returned as a flattened list.
    """
    current_engine = engine
    if current_engine is None:
        current_engine = Engine.get_default()

    loader = Loader(current_engine)
    dirs = loader.get_dirs()

    if search_glob is None:
        return SearchResult(searched_dirs=dirs, matched_files=[])

    component_filenames: List[Path] = []
    for directory in dirs:
        for path in glob.iglob(str(Path(directory) / search_glob), recursive=True):
            component_filenames.append(Path(path))

    return SearchResult(searched_dirs=dirs, matched_files=component_filenames)


# Global counter to ensure that all IDs generated by `gen_id` WILL be unique
_id = 0


def gen_id(length: int = 5) -> str:
    """Generate a unique ID that can be associated with a Node"""
    # Global counter to avoid conflicts
    global _id
    _id += 1

    # Pad the ID with `0`s up to 4 digits, e.g. `0007`
    return f"{_id:04}"


def find_last_index(lst: List, predicate: Callable[[Any], bool]) -> Any:
    for r_idx, elem in enumerate(reversed(lst)):
        if predicate(elem):
            return len(lst) - 1 - r_idx
    return -1


# See https://stackoverflow.com/a/48725499/9788634
class FrozenDict(UserDict):
    # NOTE: This __init__ is taken from `UserDict`, except `UserDict` calls
    # `self.update`, which we make immutable
    def __init__(self, dict: Dict|None=None, /, **kwargs: Any):
        self._hash = None
        self.data = {}
        if dict is not None:
            self.data.update(dict)
        if kwargs:
            self.data.update(kwargs)

    @no_type_check
    def __hash__(self) -> int:
        if self._hash is None:
            self._hash = hash(tuple(sorted(self.items())))
        return self._hash

    def _immutable(self, *args: Any, **kws: Any) -> None:
        raise TypeError('cannot change object - object is immutable')

    # makes (deep)copy more efficient
    def __copy__(self) -> "FrozenDict":
        return self

    def __deepcopy__(self, memo: Dict | None =None) -> "FrozenDict":
        if memo is not None:
            memo[id(self)] = self
        return self

    __setitem__ = _immutable
    __delitem__ = _immutable
    pop = _immutable  # type: ignore
    popitem = _immutable  # type: ignore
    clear = _immutable  # type: ignore
    update = _immutable  # type: ignore
    setdefault = _immutable  # type: ignore
